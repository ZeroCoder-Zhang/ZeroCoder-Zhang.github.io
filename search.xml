<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Linux操作系统】简学深悟启示录：Linux环境基础开发工具使用</title>
      <link href="/2025/07/28/Linux/Linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/07/28/Linux/Linux%E7%8E%AF%E5%A2%83%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍关于Linux系统常用的工具包，便于后续的代码操作</p><h1 id="软件包管理器yum"><a href="#软件包管理器yum" class="headerlink" title="软件包管理器yum"></a>软件包管理器yum</h1><p>对于 <code>Linux</code> 系统来说，下载软件是必不可少的，就像平常使用手机下载软件一样满足我们的日常需求，一般 <code>Linux</code> 有三种下载方式：</p><ul><li><strong>源代码下载：</strong> 从官网下载代码自行配置，虽说可以充分利用代码自行调配，但是上手使用难度太高</li><li><strong>rpm下载：</strong> 使用命令获取文件安装，但是会涉及该安装包依赖于其他安装包等问题，需要手动解决，过程繁琐</li><li><strong>yum下载：</strong> 也是使用命令获取文件安装，能够自动分析软件包的依赖关系，并从 <code>yum</code> 源中下载并安装所需的依赖包，大大简化了软件安装过程，虽说安装的版本可能不是最新的，但是简单易上手，通常来说是够用的</li></ul><p>因此我们主要使用 <code>yum</code></p><p>🤔<strong>那么yum是如何下载的呢？</strong></p><p>其实也没那么复杂，就拿手机来举例，跟 <code>Linux</code> 系统一样都叫做客户端，<code>yum</code> 就相当于是手机里的应用市场，是一个软件的仓库地址，告诉 <code>yum</code> 去哪里找软件，然后通过网络在服务器里找到对应的软件源来下载软件包，软件源又分为官方和第三方的</p><hr><p>通常我们通过 <code>yum list</code> 查看可安装软件列表，或者 <code>yum search 软件名</code> 进行软件搜索</p><p><strong>以rz、sz命令的下载为例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ yum list | grep rzsz</span><br><span class="line">lrzsz.x86_64                             0.12.20-36.el7                @base    </span><br></pre></td></tr></table></figure><p>我们查询到该命令的安装包为 <code>lrzsz</code></p><blockquote><p><code>yum install -y 软件包名</code></p></blockquote><p>下载的命令通常如上所示，<code>-y</code> 表示省略输入是否同意安装的步骤</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/804b8129822847bf9bf417c592e9dd43.png" alt="在这里插入图片描述"></p><p>对于该红框的信息可以解释为：</p><p><strong>软件包名称:</strong> 主版本号，次版本号，源程序发行号-软件包的发行号，主机平台，cpu架构 </p><p><code>x86_64</code> 后缀表示 <code>64</code> 位系统的安装包，<code>i686</code> 后缀表示 <code>32</code> 位系统安装包，选择包时要和系统匹配，<code>el7</code> 表示操作系统发行版的版本，<code>el7</code> 表示的是 <code>centos7/redhat7</code>，<code>el6</code> 表示  <code>centos6/redhat6</code>，最后一列，<code>base</code> 表示的是 “软件源” 的名称，类似于 “小米应用商店”，”华为应用商店” 这样的概念</p><p>顺便一提，<code>rz</code> 命令用于从 <code>Windows</code> 上传文件到 <code>Linux</code>，<code>sz</code> 命令用于从 <code>Linux</code> 下载文件到 <code>Windows</code>，输入命令后会弹出文件选择对话框，选择要上传的文件即可，在本地直接拖动文件到窗口也是一样的</p><blockquote><p><code>yum remove 软件包名</code></p></blockquote><p>想要删除可以输入以上命令</p><p>🔥<strong>值得注意的是：</strong></p><ul><li>安装软件时由于需要向系统目录中写入内容，一般需要 <code>sudo</code> 或者切到 <code>root</code> 账户下才能完成</li><li><code>yum</code> 安装软件只能一个装完了再装另一个，正在 <code>yum</code> 安装一个软件的过程中, 如果再尝试用 <code>yum</code> 安装另外一个软件，<code>yum</code> 会报错</li></ul><h1 id="Linux编辑器vim"><a href="#Linux编辑器vim" class="headerlink" title="Linux编辑器vim"></a>Linux编辑器vim</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f6cf1f73b9ab4a85ac6c01925b49934f.png" alt="在这里插入图片描述"></p><p><code>vim 文件名</code> 进入编辑界面，可以理解为记事本，初始状态下是命令模式</p><h2 id="三模式切换"><a href="#三模式切换" class="headerlink" title="三模式切换"></a>三模式切换</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6674a3b6d70e41e8855ea4daa0cb296e.png" alt="在这里插入图片描述"><br>通常最常用的三个模式：</p><ul><li><strong>命令模式：</strong> <code>i</code> 切换到插入模式，<code>:(shift + ;)</code> 切换到底行模式</li><li><strong>插入模式：</strong> <code>esc</code> 回到命令模式</li><li><strong>底行模式：</strong> <code>esc</code> 回到命令模式</li></ul><p>命令模式就是使用命令控制屏幕光标的移动，字符、字或行的删除，一般不做文本输入；插入模式就是允许编辑的模式，是我们后面用的最频繁的编辑模式；底行模式用于文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作</p><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>正常模式就是命令模式，通常使用命令进行一些简单的操作</p><p><strong>移动：</strong></p><ul><li><code>gg</code>：定位光标到开头行第一位</li><li><code>G(shift + g)</code>：定位到结尾行第一位</li><li><code>n + shift + g</code> ：定位到第 <code>n</code> 行文本第一位</li><li><code>$(shift + 4)</code>：定位到当前行的文本最后一位</li><li><code>^(shift + 6)</code>：定位到当前行的文本第一位</li><li><code>w、b</code>：光标按照单词进行行内、跨行移动</li><li><code>h、j、k、l</code>：左下上右移动光标</li></ul><p><strong>复制粘贴：</strong></p><ul><li><code>(n)yy</code>：复制光标所在(<code>n</code>)行</li><li><code>(n)dd</code>：删除(<code>n</code>)行</li><li><code>(n)p</code>：粘贴 <code>n</code> </li><li><code>u</code>：撤回</li><li><code>ctrl + r</code>：撤回之前的撤回</li></ul><p><strong>转换：</strong></p><ul><li><code>~</code>：大小写转换</li><li><code>(n)r</code>：对光标字符之后的所有字符进行批量化替换</li><li><code>R(shirf + r)</code>：进入替换模式，对内容整体替换</li><li><code>(n)x</code>：对光标字符之后的字符进行删除</li></ul><h2 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h2><p>在使用底行模式之前，请记住先按 <code>esc</code> 键确定您已经处于正常模式，再按 <code>:</code> 冒号即可进入底行模式</p><p><strong>跳到文件中的某一行：</strong></p><ul><li><code>#</code>：<code>#</code> 号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字 <code>15</code>，再回车，就会跳到文章的第15行</li></ul><p><strong>查找字符：</strong></p><ul><li><p><code>/ + 关键字</code>：先按 <code>/</code> 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 <code>n</code> 会往后寻找到您要的关键字为止，从当前光标位置向下（往后） 查找</p></li><li><p><code>? + 关键字</code>：先按 <code>?</code> 键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按 <code>n</code> 会往前寻找到您要的关键字为止，从当前光标位置向上（往前） 查找</p></li></ul><p> <strong>保存文件：</strong></p><ul><li><code>w</code>：在冒号输入字母 <code>w</code> 就可以将文件保存起来离开 <code>vim</code></li><li><code>q</code>：按 <code>q</code> 就是退出，如果无法离开 <code>vim</code>，可以在 <code>q</code> 后跟一个 <code>!</code> 强制离开 <code>vim</code></li><li><code>wq</code>：一般建议离开时，搭配 <code>w</code> 一起使用，这样在退出的时候还可以保存文件</li></ul><h2 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h2><p><strong>可视化模式一般用于批量操作，比如批量加注释：</strong></p><p><strong>批量注释：</strong></p><p>在正常模式下按 <code>ctrl + v</code> ，进入 <code>V-BLOCK</code> 模式，按 <code>J</code> 键 或 <code>K</code> 键选择要注释的内容，<code>J</code> 向上 <code>K</code> 向下，按住 <code>shift + i</code> 进入插入模式，输入 <code>//</code>，点击 <code>esc</code> 键，完成注释</p><p><strong>批量取消注释：</strong></p><p>在正常模式下按 <code>ctrl + v</code> ，进入 <code>V-BLOCK</code> 模式，然后按两下 <code>L</code> 键(右移两格)，选中注释的符号，按 <code>J</code> 键或 <code>K</code> 键选择要取消注释的内容，按 <code>d</code> 键完成批量取消注释</p><h2 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h2><p><code>vim</code> 可以通过在自己用户下添加 <code>.vimrc</code> 的文件进行功能、风格等配置，为了能够像在VS<br>、IDEA中那样使用方便，可以自行上网进行配置搜索，这里我推荐一个配置项目</p><blockquote><p>传送门：<a href="https://gitee.com/HGtz2222/VimForCpp">VimForCpp</a></p></blockquote><h1 id="Linux编译器gcc-g"><a href="#Linux编译器gcc-g" class="headerlink" title="Linux编译器gcc&#x2F;g++"></a>Linux编译器gcc&#x2F;g++</h1><blockquote><p>gcc&#x2F;g++ [选项] 要编译的文件 [选项] [目标文件]</p></blockquote><p><code>gcc/g++</code> 是一款语言编译器，相当于 <code>Linux</code> 系统的 <code>VS</code>，<code>gcc</code> 专门编译 <code>C</code> 语言，<code>g++</code> 既可以编译 <code>C</code> 语言，也可以编译 <code>C++</code></p><p>生成可执行文件直接 <code>./目标文件</code> 执行即可</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ gcc -E processBar.c -o processBar.i</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h  processBar.i</span><br></pre></td></tr></table></figure><p>预处理功能主要包括宏定义，文件包含，条件编译，去注释等</p><p><code>-E</code> 表示让 <code>gcc</code> 在预处理结束后停止编译过程，<code>-o</code> 后面一定是接目标文件，源头文件放哪儿无所谓</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h  processBar.i</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ gcc -S processBar.i -o processBar.s</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar  processBar.c  processBar.h  processBar.i  processBar.s</span><br></pre></td></tr></table></figure><p>编译主要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后， <code>gcc</code> 把代码翻译成汇编语言</p><p><code>-S</code> 表示让 <code>gcc</code> 在编译结束后停止编译过程，生成汇编代码</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar  processBar.c  processBar.h  processBar.i  processBar.s</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ gcc -c processBar.s -o processBar.o</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h  processBar.i  processBar.o  processBar.s</span><br></pre></td></tr></table></figure><p>汇编主要生成机器可识别代码</p><p><code>-c</code> 表示让 <code>gcc</code> 在汇编结束后停止编译过程，生成二进制代码</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h  processBar.i  processBar.o  processBar.s</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ gcc processBar.o -o processBar</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar  processBar.c  processBar.h  processBar.i  processBar.o  processBar.s</span><br></pre></td></tr></table></figure><p>连接表示连接函数库生成可执行文件</p><h2 id="函数库"><a href="#函数库" class="headerlink" title="函数库"></a>函数库</h2><p>函数库分为两种类型的库：</p><p><strong>静态库：</strong></p><p>静态库就是将需要展开的函数在函数定义的地方直接展开，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了，其后缀名一般为 <code>.a</code></p><p><strong>动态库：</strong></p><p>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。所以动态库也叫共享库，动态库一般后缀名为 <code>.so</code>，如前面所述的 <code>libc.so.6</code> 就是动态库，<code>gcc</code> 在编译时默认使用动态库</p><h1 id="Linux自动化构建工具Makefile"><a href="#Linux自动化构建工具Makefile" class="headerlink" title="Linux自动化构建工具Makefile"></a>Linux自动化构建工具Makefile</h1><p><code>make</code> 是一条命令，<code>makefile</code> 是一个文件，两个搭配使用，完成项目自动化构建</p><p>通常我们需要不断的进行 <code>gcc</code> &#x2F; <code>g++</code> 编译、<code>rm</code> 删除执行文件等等指令，如果有大量文件需要多次重复以上操作的话，那么每次都手动输入一大长串必然是麻烦的，因此就需要编写 <code>Makefile</code>（ <code>makefile</code> 也行，大小写无所谓）文件自动化使用指令</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/757b6617e4744bcd9bfc840ea9ea0ab2.png" alt="在这里插入图片描述"></p><p>如图所示可解释为：</p><p><code>processBar</code> 可执行文件依赖于 <code>processBar.c、main.c</code>，<code>$^</code> 表示 <code>:</code> 后面的文件，<code>$@</code> 表示 <code>:</code> 前面的文件，直接写文件名也可以，不过用符号比较方便就是了，下面的 <code>clean</code> 同理，<code>:</code> 后面是空的表示不依赖于任何文件就可以执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h</span><br><span class="line"></span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ make processBar</span><br><span class="line">gcc processBar.c main.c -o processBar </span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar  processBar.c  processBar.h</span><br><span class="line"></span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ make clean</span><br><span class="line"><span class="built_in">rm</span> -rf processBar</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 progressbar]$ <span class="built_in">ls</span></span><br><span class="line">main.c  makefile  processBar.c  processBar.h</span><br></pre></td></tr></table></figure><p>通常使用 <code>make+冒号前的依赖名</code> 的方式执行自动化，如果只输入 <code>make</code> 指令的话默认执行第一条自动化指令，被依赖的文件总会更新，所以要多次执行 <code>make processBar</code> 的指令</p><p><code>make</code> 的默认行为是：基于时间戳判断更新，检查目标是否是一个已存在的文件，如果文件存在且没有更新（即依赖项未变化），则跳过该目标的命令。像 <code>clean</code> 这种没有具体依赖目标的叫做 <code>伪目标</code></p><p>但有些场景下，目标并不是实际文件（比如常见的 <code>clean</code>、<code>all</code>、<code>install</code> 等），若目录中恰好有与这些目标同名的文件（比如名为 <code>clean</code> 的文件），<code>make</code> 会误将其当作 “已完成的目标文件”，认为无需执行，从而跳过本应运行的命令（如 <code>rm -f *.o</code>），导致清理、构建等预期操作失败</p><p>因此需要用 <code>.PHONY</code> 声明伪目标 —— 强制 <code>make</code> 忽略同名文件，始终执行命令</p><p>🔥<strong>值得注意的是：</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello:hello.o </span><br><span class="line">gcc hello.o -o hello </span><br><span class="line"></span><br><span class="line">hello.o:hello.s </span><br><span class="line">gcc -c hello.s -o hello.o </span><br><span class="line"></span><br><span class="line">hello.s:hello.i </span><br><span class="line">gcc -S hello.i -o hello.s </span><br><span class="line"></span><br><span class="line">hello.i:hello.c </span><br><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><p><code>make</code> 会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件，在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么 <code>make</code> 就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，<code>make</code> 根本不理，<code>make</code> 只管文件的依赖性，即如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦</p><h1 id="Linux调试器gdb"><a href="#Linux调试器gdb" class="headerlink" title="Linux调试器gdb"></a>Linux调试器gdb</h1><p><code>Linux</code> 系统中，程序的发布默认是 <code>release</code> 版本，无法直接发布，所以调试的前提是处于 <code>debug</code> 版本，那么在 <code>gcc</code> &#x2F; <code>g++</code> 编译时要加上 <code>-g</code> 使文件以 <code>debug</code> 版本输出</p><p><code>gdb</code> 是用来调试可执行文件或者目标文件的，所以用 <code>gdb 目标文件</code> 指令启动调试器</p><p>以下是 <code>gdb</code> 代码调试时的指令</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a2741ed9a16149e6b82fb59c7a2c86ac.png" alt="在这里插入图片描述"><br>一般我们还是在 <code>VS</code> 里调试比较方便，因此 <code>gdb</code> 的调试就不过多叙述</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5893ed3a6c4a48d6b27698290c42de27.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux操作系统】简学深悟启示录：Linux权限</title>
      <link href="/2025/07/14/Linux/Linux%E6%9D%83%E9%99%90/"/>
      <url>/2025/07/14/Linux/Linux%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p><code>Linux</code> 权限是系统通过对文件 &#x2F; 目录设置读（<code>r</code>）、写（<code>w</code>）、执行（<code>x</code>）权限，分别管控文件所有者、所属组及其他用户对其的访问操作，以保障系统安全</p><h1 id="shell的运行原理"><a href="#shell的运行原理" class="headerlink" title="shell的运行原理"></a>shell的运行原理</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3c8dbbcbd6ab4550aea172d8a59b0691.png" alt="在这里插入图片描述"></p><p>对于 <code>Linux</code> 来说，我们输入的命令行本质上就是在输入字符串，指令的本质就是调用在特定路径下存放的可执行文件，所有的指令最终都要在 <code>OS</code>（操作系统）内执行，但是 <code>OS</code> 的使用难度比较高，用户一般很难直接使用 <code>OS</code> 和他打交道，所以在用户输入的指令和 <code>OS</code> 之间设置了一层命令行解释器</p><p>命令行解释器会将命令翻译给核心（<code>kernel</code>）处理，同时将翻译后的结果给到使用者</p><p><strong>存在的意义：</strong></p><ul><li>进行命令行解释 </li><li>保护 <code>OS</code>，对于用户的非法请求直接拦截，起到过滤器的效果</li></ul><h1 id="用户的分类"><a href="#用户的分类" class="headerlink" title="用户的分类"></a>用户的分类</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c7533a13a922423c82c06356f4bb63da.png" alt="在这里插入图片描述"></p><p><strong>用户一般分为：</strong></p><ul><li><code>root</code>：超级用户</li><li>普通用户：我们新建的用户，即 <code>adduser</code></li></ul><p>由于某些情况下，比如下载依赖的时候就需要切换到 <code>root</code> 账号才能下载，可以使用 <code>su</code> 指令进行切换</p><p>超级用户的命令提示符是 <code>#</code>，普通用户的命令提示符是 <code>$</code></p><h1 id="用户的切换"><a href="#用户的切换" class="headerlink" title="用户的切换"></a>用户的切换</h1><ul><li><strong>root用户切换普通用户</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-6aa4 ~]# su zzh_test</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 root]$</span><br></pre></td></tr></table></figure><p><code>su user</code> 表示切换到普通用户，也可以使用<code>exit</code> 或 <code>ctrl+d</code> 退出 <code>root</code> 账号，普通用户切换普通用户同理</p><ul><li><strong>普通用户切换root用户</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ su -</span><br><span class="line">Password: </span><br><span class="line">Last login: Wed Jul  9 09:07:24 CST 2025 from IP on pts/0</span><br><span class="line">Last failed login: Wed Jul  9 22:23:47 CST 2025 from IP on ssh:notty</span><br><span class="line">There were 4128 failed login attempts since the last successful login.</span><br><span class="line">[root@hcss-ecs-6aa4 ~]#</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ su</span><br><span class="line">Password: </span><br><span class="line">[root@hcss-ecs-6aa4 zzh_test]#</span><br></pre></td></tr></table></figure><p><code>su</code> 后面不加 <code>user</code> 默认表示切换到 <code>root</code> 用户，<code>su -</code> 也是切换到 <code>root</code> 用户，但是会显示登录时的时间、<code>IP</code> 等信息</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/16e90fdecf0649ee92fcc2df7f20e97a.png" alt="在这里插入图片描述"></p><p> <strong>关键差异对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><code>su</code>（无 <code>-</code>）</th><th><code>su -</code>（带 <code>-</code>）</th></tr></thead><tbody><tr><td><strong>环境变量</strong></td><td>保留当前用户的环境变量</td><td>加载目标用户的环境变量</td></tr><tr><td><strong>工作目录</strong></td><td>保持当前目录</td><td>切换到目标用户的主目录</td></tr><tr><td><strong>用户体验</strong></td><td>部分命令可能因环境变量不匹配而无法正常工作（如找不到命令）</td><td>完全进入目标用户的环境，命令路径正常</td></tr><tr><td><strong>使用场景</strong></td><td>临时执行特定命令，无需完整环境</td><td>需要以目标用户身份进行完整操作</td></tr></tbody></table><p>例如，若要以<code>root</code>身份执行单个命令，可直接用 <code>su -c &quot;command&quot; root</code>；若要完整登录<code>root</code>环境，则用 <code>su -</code></p><p>🔥<strong>值得注意的是：</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">sudo</span> <span class="built_in">whoami</span></span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> zzh_test:</span><br><span class="line">root</span><br></pre></td></tr></table></figure><p>我们如果想要对特定指令进行 <code>root</code> 身份运行又不想登录那么麻烦的话，可以用 <code>sudo</code> 进行提权，那么以后就可以使用 <code>sudo command</code> 的方式在 <code>root</code> 身份下快速执行命令</p><p>但是这种使用方式就会有疑问，因为输入的是普通账户的密码就能使用 <code>root</code> 的权限，那么这样岂不是显得 <code>su</code> 很没用，人人都可以用 <code>root</code> 了？</p><p>其实不是这样的，目前我们用 <code>adduser</code> 新建的用户，没有办法执行 <code>sudo</code>，系统不信任你，除非你添加到系统信任的白名单里才能执行以上操作</p><p>关于这部分知识到了后面会做介绍</p><h1 id="权限的访问属性"><a href="#权限的访问属性" class="headerlink" title="权限的访问属性"></a>权限的访问属性</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d13274bd6da449a68957aa6a8809f0a7.png" alt="在这里插入图片描述"></p><p>一件事是否允许被执行，取决于权限的属性，相当于一个人的身份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 zzh_test zzh_test 44 Jun 29 20:41 text1</span><br></pre></td></tr></table></figure><p>看一个例子，该代码展示的是一个文件的详细信息</p><ul><li><code>r</code>表示可读</li><li><code>w</code> 表示可写</li><li><code>x</code> 表示可执行</li><li><code>-</code> 对应权限位置，表示没有权限</li></ul><p>对于文件和目录来说，<code>rwx</code> 的意思稍微有些区别：</p><ul><li><code>r</code> 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</li><li><code>w</code> 对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</li><li><code>x</code> 对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</li></ul><p><strong>但是这么一长串表示什么意思呢？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7d92475dc1594889bc656f2213c04a6c.png" alt="在这里插入图片描述"></p><p>在 <code>Linux</code> 里分为三种身份：<code>拥有者</code>，<code>所属组</code>，<code>其他人</code>（即除了拥有者，所属组以外的）</p><p><strong>举个例子讲解下所属组的具体作用：</strong></p><blockquote><p>假设有甲和乙分别在同一家公司的 <code>A</code> 和 <code>B</code> 组，他们虽然在不同组但是负责同一项目，由于公司竞争机制，所以他们并不想所做的成果被互相看到，比如甲刚做好一个部分不想给乙看到，那么他可以直接设置该文件的其他人权限为 <code>---</code> ，但是这就无法给老板看成果了，因此就需要所属组，可以理解为白名单，把老板拉到这个所属组里，让老板有权限进行操作</p></blockquote><p>回到这个例子上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 zzh_test zzh_test 44 Jun 29 20:41 text1</span><br></pre></td></tr></table></figure><ul><li>第一位表示文件类型，之前讲过，<code>-</code> 表示文件，<code>d</code> 表示文件夹</li><li><code>2-4</code> 位表示拥有者的权限，对于该例子表示拥有者<code>可读可写可执行</code></li><li><code>5-7</code> 位表示所属组的权限，对于该例子表示所属组成员<code>可读可写</code></li><li><code>8-10</code> 位表示其他人的权限，对于该例子表示其他人<code>可读</code></li></ul><p>再往后看，第一个 <code>zzh_test</code> 表示文件所属用户，第二个 <code>zzh_test</code> 表示文件所属用户组</p><p>🔥<strong>值得注意的是：</strong> </p><ol><li><code>Linux</code> 系统中，文件名都是我们自己取的，例如 <code>test.c</code>，加上 <code>.c</code> 是为了方便我们知道这是个 <code>C</code> 语言文件，对于 <code>Linux</code> 系统来说这个文件名后缀没有直接意义，系统识别类型主要还是通过第一位的符号</li><li>创建用户时会默认创建一个同名的基本组，用户所属组的名字和用户名相同，默认情况下该用户会被包含在这个所属组中，即 <code>zzh_test</code> 用户默认是包含在 <code>zzh_test</code> 所属组的</li></ol><h1 id="权限的修改"><a href="#权限的修改" class="headerlink" title="权限的修改"></a>权限的修改</h1><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ ll text1</span><br><span class="line">---------- 1 zzh_test zzh_test 44 Jun 29 20:41 text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">chmod</span> u+rwx,g+rw,o+r text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ ll text1</span><br><span class="line">-rwxrw-r-- 1 zzh_test zzh_test 44 Jun 29 20:41 text1</span><br></pre></td></tr></table></figure><p><code>chmod</code> 用于设置文件的访问权限，只有文件的拥有者和 <code>root</code> 才可以改变文件的权限，<code>-R</code>  递归修改目录文件的权限</p><ul><li><code>+</code>：向权限范围增加权限代号所表示的权限</li><li><code>-</code>：向权限范围取消权限代号所表示的权限</li><li><code>=</code>：向权限范围赋予权限代号所表示的权限</li></ul><p><strong>用户符号：</strong>   </p><ul><li><code>u</code>：拥有者</li><li><code>g</code>：拥有者同组用</li><li><code>o</code>：其它用户</li><li><code>a</code>：所有用户</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>也可以通过 <code>chmod 000 text1</code> 的方式来修改权限，即将所有角色的权限取消，但一般修改不同角色的权限时用八进制，比如 <code>chmod 420 text1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ec5fcbd5b9c4fd4a93baa7b7daec656.png" alt="在这里插入图片描述"></p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-6aa4 zzh_test]# ll text1</span><br><span class="line">-rwxrw-r-- 1 zzh_test zzh_test 44 Jun 29 20:41 text1</span><br><span class="line">[root@hcss-ecs-6aa4 zzh_test]# <span class="built_in">chown</span> root text1</span><br><span class="line">[root@hcss-ecs-6aa4 zzh_test]# ll text1</span><br><span class="line">-rwxrw-r-- 1 root zzh_test 44 Jun 29 20:41 text1</span><br></pre></td></tr></table></figure><p><code>chown</code> 用于修改文件的拥有者，此命令只能由 <code>root</code> 使用，<code>-R</code> 递归修改文件或目录的所有者</p><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ charge other_group text1</span><br></pre></td></tr></table></figure><p>修改文件或目录的所属组，<code>-R</code> 递归修改文件或目录的所属组</p><p>假设你是用户 <code>zzh_test</code>，属于 <code>zzh_group</code> 和 <code>dev_group</code> 两个组，你有一个自己的文件 <code>text1</code>（所有者是 <code>zzh_test</code>）。你可以把 <code>text1</code> 的所属组改成 <code>zzh_group</code> 或 <code>dev_group</code>（因为你是这两个组的成员），但不能改成 <code>root</code> 组或 <code>other_group</code>（如果你不在这些组里），会提示权限不足</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="umask掩码的作用？"><a href="#umask掩码的作用？" class="headerlink" title="umask掩码的作用？"></a>umask掩码的作用？</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9e784f36ffef4d0782f1ec8ec61a9427.png" alt="在这里插入图片描述"></p><p>系统会为新文件默认分配权限（通常文件是 <code>666</code>，目录是 <code>777</code>），而 <code>umask</code> 会 “屏蔽” 掉其中某些权限，最终权限 &#x3D; 默认权限 - <code>umask</code> 权限</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c732f28159574868a77955d622ee6c38.png" alt="在这里插入图片描述"><br>其实实际权限的计算是通过位运算实现的，但是为了计算简便直接相减也是可以的</p><p>例如：若 <code>umask</code> 为 <code>022</code>，则新文件权限为 <code>666 - 022 = 644</code>（即 <code>-rw-r--r--</code>），新目录权限为 <code>777 - 022 = 755</code>（即 <code>drwxr-xr-x</code>）</p><ul><li><p>默认情况下，系统创建文件和目录的权限可能过于宽松（如文件 <code>666</code>、目录 <code>777</code>），这会导致所有用户都能读写甚至执行文件，存在安全风险。通过 <code>umask</code> 屏蔽不必要的权限，确保文件和目录仅拥有完成任务所需的最低权限。例如，日志文件通常只需所有者可写，其他用户只读（<code>644</code>），此时 <code>umask</code> 可设为 <code>022</code></p></li><li><p>每次创建文件时手动指定权限（如 <code>chmod</code>）繁琐且易出错，<code>umask</code> 提供了自动化的默认权限设置机制。团队协作规范：团队环境中，统一的 <code>umask</code> 配置可确保所有成员创建的文件权限一致，避免因权限混乱导致的协作问题</p></li></ul><h2 id="如何防止文件被删除？"><a href="#如何防止文件被删除？" class="headerlink" title="如何防止文件被删除？"></a>如何防止文件被删除？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# <span class="built_in">chmod</span> +t /home/ <span class="comment"># 加上粘滞位</span></span><br><span class="line">[root@localhost ~]# <span class="built_in">ls</span> -ld /home/</span><br><span class="line">drwxrwxrwt. 3 root root 4096 9月 19 16:00 /home/</span><br><span class="line">[root@localhost ~]# su - litao</span><br><span class="line">[litao@localhost ~]$ <span class="built_in">rm</span> /home/abc.c <span class="comment">#litao不能删除别人的文件</span></span><br><span class="line"><span class="built_in">rm</span>：是否删除有写保护的普通空文件 <span class="string">&quot;/home/abc.c&quot;</span>？y</span><br><span class="line"><span class="built_in">rm</span>: 无法删除<span class="string">&quot;/home/abc.c&quot;</span>: 不允许的操作</span><br></pre></td></tr></table></figure><p>我们知道对于一个目录来说，<code>other</code> 只要具有 <code>w</code> 权限就可以对文件进行修改删除，但是常常我们只希望别人写入，而不是删除，为了实现只可写的权限，可以使用粘滞位 <code>chmod +t</code>，即 <code>x</code> 的位置被替换成 <code>t</code></p><p><strong>此时该目录下的文件只能由</strong></p><ul><li><code>root</code> 删除</li><li>该目录的所有者删除</li><li>该文件的所有者删除</li></ul><p>🔥<strong>值得注意的是：</strong> 一个文件能否被删除，并不由文件本身决定的，是由文件所处的目录权限决定的。因此粘滞位是给目录设置的，目录设置了粘滞位，文件除了上述所说的角色，其他人就无法删除了</p><h2 id="目录权限的区分"><a href="#目录权限的区分" class="headerlink" title="目录权限的区分"></a>目录权限的区分</h2><p><strong>目录的可执行权限是表示你可否在目录下执行命令：</strong></p><ul><li>如果目录没有 <code>-x</code> 权限，则无法对目录执行任何命令，甚至无法 <code>cd</code> 进入目，即使目录仍然有 <code>-r</code> 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件）</li><li>如果目录具有 <code>-x</code> 权限，但没有 <code>-r</code> 权限，则用户可以执行命令，可以 <code>cd</code> 进入目录。但由于没有目录的读权限，所以在目录下，即使可以执行 <code>ls</code> 命令，但仍然没有权限读出目录下的文档（可以执行和可以实现是两码事）</li></ul><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0f2bdb8b2b24fbda51d00ec3304d54d.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux操作系统】简学深悟启示录：Linux基本指令</title>
      <link href="/2025/07/07/Linux/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/"/>
      <url>/2025/07/07/Linux/Linux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>本篇将开启 <code>Linux</code> 操作系统的全面学习，默认使用的是 <code>CentOS</code> 操作系统，使用 <code>Xshell</code> 进行远程登录服务器进行操作测试</p><h1 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6acb5bb684f042f694c705148f2b80ec.png" alt="在这里插入图片描述"></p><p>这是一个计算机系统层次结构的示意图，运行的过程是从上往下实现的，操作系统其实本质也是一种软件，是一种基础软件，对下提供软硬件资源的管理，对上提供稳定、快速、安全的操作环境，给予应用软件功能的支撑，因此所有的软件最终都会转化为硬件行为，都要经过操作系统的管理</p><h1 id="Xshell的使用"><a href="#Xshell的使用" class="headerlink" title="Xshell的使用"></a>Xshell的使用</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c95794e6bba548ef9dc5d5c4ab416651.png" alt="在这里插入图片描述"></p><p>目前更新的最新的是<a href="https://www.xshell.com/zh/free-for-home-school/">Xshell8</a>，可以直接下载家庭学校的免费版本，能够满足基本的 <code>Linux</code> 学习，再就是需要自己购买一台轻量级云服务器进行登录使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[C:\~]$ ssh root@公网IP地址</span><br></pre></td></tr></table></figure><p>首先初始状态下只有一个主用户，即 <code>root</code>，输入 <code>ssh root@公网IP地址</code>，然后会弹出窗口让你输入密码，公网 <code>IP</code> 和密码都能在你购买服务器的地方找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[C:\~]$ </span><br><span class="line"></span><br><span class="line">Connecting to 公网IP:22...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to <span class="built_in">local</span> shell, press <span class="string">&#x27;Ctrl+Alt+]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">WARNING! The remote SSH server rejected X11 forwarding request.</span><br><span class="line">Last failed login: Tue Jun 17 21:39:20 CST 2025 from 公网IP on ssh:notty</span><br><span class="line">There was 1 failed login attempt since the last successful login.</span><br><span class="line">Last login: Tue Jun 17 21:21:28 2025 from 公网IP</span><br><span class="line"></span><br><span class="line">Welcome to Huawei Cloud Service</span><br></pre></td></tr></table></figure><p>显示这一段说明就连接成功了，这个警告不用管，我使用的是华为云，可能会出现些许不兼容的情况，但是这不影响后续的学习，但是我们一般不使用主用户，<code>root</code> 操作记录混杂，出问题时难以定位责任；普通账户操作留痕，便于排查。所以一般创建普通用户来使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-6aa4 ~]# adduser 用户名</span><br></pre></td></tr></table></figure><p><code>adduser 用户名</code> 用于增加普通用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-6aa4 ~]# passwd 用户名</span><br><span class="line">Changing password <span class="keyword">for</span> user 用户名.</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><p><code>passwd 用户名</code> 设置刚创立的普通用户的密码，一般输入的时候密码不回显</p><p>然后可以输入 <code>exit</code> 退出 <code>root</code> 账户（其实也能用命令直接切换，后面会讲），切换用户名即可登录普通用户账号</p><p>🔥<strong>值得注意的是：</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-6aa4 ~]# userdel -r 用户名</span><br></pre></td></tr></table></figure><p>由于 <code>root</code> 用户权限比普通用户高，所以只有在 <code>root</code> 用户下才能通过 <code>userdel -r 用户名</code> 来删除普通用户</p><h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><p><code>Linux</code> 通常都在后端运行，纯命令行能降低消耗，提高效率，因此一般不需要图形化界面，<code>指令一般都会搭配选项使用</code></p><h2 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bc5ab53c450e4ef9bb2884aa7e5b29e7.png" alt="在这里插入图片描述"></p><p><code>ls</code> 的作用是列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息</p><p>在 <code>Linux</code> 中，目录指的就是我们平常创建的文件夹，蓝色的是目录，白色的是文件</p><ul><li><code>-a</code> 列出目录下的所有文件，包括以 <code>.</code> 开头的隐含文件</li><li><code>-d</code> 将目录象文件一样显示，而不是显示其下的文件。 如：<code>ls –d 指定目录</code></li><li><code>-i</code> 输出文件的 <code>i</code> 节点的索引信息。 如 <code>ls –ai</code> 指定文件</li><li><code>-k</code> 以 <code>k</code> 字节的形式表示文件的大小。<code>ls –alk</code> 指定文件</li><li><code>-l</code> 列出文件的详细信息</li><li><code>-n</code> 用数字的 <code>UID</code>、<code>GID</code> 代替名称（介绍 <code>UID</code>、<code>GID</code>）</li><li><code>-F</code> 在每个文件名后附上一个字符以说明该文件的类型，<code>*</code> 表示可执行的普通文件；<code>/</code> 表示目录；<code>@</code> 表示符号链接；<code>|</code> 表示 <code>FIFOs</code>；<code>=</code> 表示套接字( <code>sockets</code> )（目录类型识别）</li><li><code>-r</code> 对目录反向排序</li><li><code>-t</code> 以时间排序</li><li><code>-s</code> 在 <code>l</code> 文件名后输出该文件的大小（大小排序，如何找到目录下最大的文件）</li><li><code>-R</code> 列出所有子目录下的文件(递归) </li><li><code>-1</code> 一行只输出一个文件</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>常用的是 <code>-a</code>、<code>-l</code>、<code>-F</code>、<code>-d</code>，其他一般不怎么用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ ll</span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test 4096 Jun 18 19:14 dir1</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test    0 Jun 17 23:23 text1</span><br></pre></td></tr></table></figure><p><code>ls -l</code> 可以缩写成 <code>ll</code></p><p><strong>第三行：</strong> 以 <code>d</code> 开头的表示目录<br><strong>第四行：</strong> 以 <code>-</code> 开头的表示普通文件</p><h2 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a>pwd指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/zzh_test</span><br></pre></td></tr></table></figure><p><code>pwd</code> 的作用是显示当前所在的路径，没有搭配的选项</p><h2 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h2><p><code>Linux</code> 任何一个目录下都有两个隐藏文件</p><ul><li><code>.</code>：表示当前路径</li><li><code>..</code>：表示上一级路径</li></ul><p>这两个文件都是为了帮助定位文件位置，即相对路径，平常见到的路径一般是绝对路径</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9592f7b559574a2193de9c322d1fead4.png" alt="在这里插入图片描述"></p><p>所有的文件都是从根目录 <code>/</code> 开始的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">ls</span></span><br><span class="line">dir1  text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">cd</span> dir1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">pwd</span></span><br><span class="line">/home/zzh_test/dir1</span><br></pre></td></tr></table></figure><p>改变工作目录，将当前工作目录改变到指定的目录下</p><ul><li><code>cd ..</code>：返回上级目录</li><li><code>cd /home/litao/linux/</code>：绝对路径</li><li><code>cd ../day02/</code> ：相对路径</li><li><code>cd ~</code> ：进入用户家目录</li><li><code>cd -</code> ：返回最近访问目录</li></ul><h2 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">touch</span> text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">ls</span></span><br><span class="line">dir1  text1  text2</span><br></pre></td></tr></table></figure><p><code>touch</code> 指令可更改文档或目录的相关属性，或者新建一个不存在的文件</p><ul><li><code>-a</code>   或 <code>--time=atime</code> 或 <code>--time=access</code> 或 <code>--time=use</code> 只更改存取时间</li><li><code>-c</code>   或 <code>--no-create</code>  不建立任何文档</li><li><code>-d</code>  使用指定的日期时间，而非现在的时间</li><li><code>-f</code>  此参数将忽略不予处理，仅负责解决 <code>BSD</code> 版本 <code>touch</code> 指令的兼容性问题</li><li><code>-m</code>   或 <code>--time=mtime</code> 或 <code>--time=modify</code> 只更改变动时间</li><li><code>-r</code>  把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同</li><li><code>-t</code>  使用指定的日期时间，而非现在的时间</li></ul><h2 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">mkdir</span> -p dir1/dir2/dir3</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ tree</span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   └── dir2</span><br><span class="line">│       └── dir3</span><br><span class="line">├── text1</span><br><span class="line">└── text2</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br></pre></td></tr></table></figure><p><code>mkdir</code> 用于创建目录（文件夹）</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>-p</code> 一般用于递归式创建目录，普通创建就需要进入该级目录才能创建下一级目录，所以 <code>-p</code> 就方便了很多</li><li><code>tree</code> 指令用于展示树形结构的目录文件的层级关系，使用 <code>yum install -y tree</code> 指令下载即可使用</li></ul><h2 id="rmdir指令-rm指令"><a href="#rmdir指令-rm指令" class="headerlink" title="rmdir指令 &amp;&amp; rm指令"></a>rmdir指令 &amp;&amp; rm指令</h2><p><code>rmdir</code> 只能用来删除空目录</p><ul><li><code>-p</code> 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ tree</span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   └── dir2</span><br><span class="line">│       └── dir3</span><br><span class="line">├── text1</span><br><span class="line">└── text2</span><br><span class="line"></span><br><span class="line">3 directories, 2 files</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">rm</span> -rfi dir1</span><br><span class="line"><span class="built_in">rm</span>: descend into directory ‘dir1’? y</span><br><span class="line"><span class="built_in">rm</span>: descend into directory ‘dir1/dir2’? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory ‘dir1/dir2/dir3’? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory ‘dir1/dir2’? y</span><br><span class="line"><span class="built_in">rm</span>: remove directory ‘dir1’? y</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ tree</span><br><span class="line">.</span><br><span class="line">├── text1</span><br><span class="line">└── text2</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br></pre></td></tr></table></figure><p><code>rmdir</code> 还是太鸡肋了，所以更多使用 <code>rm</code>，能够删除文件或目录</p><ul><li><code>-f</code> 即使文件属性为只读(即写保护)，亦直接强制删除</li><li><code>-i</code> 删除前逐一询问确认</li><li><code>-r</code> 删除目录及其下所有文件(递归删除)</li></ul><h2 id="man指令"><a href="#man指令" class="headerlink" title="man指令"></a>man指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ man man</span><br></pre></td></tr></table></figure><p><code>man</code> 指令用于查看指令手册，毕竟不可能记住所有的指令，<code>man man</code> 是查询 <code>man</code> 这条指令的意思</p><ul><li><code>-k</code>：根据关键字搜索联机帮助</li><li><code>num</code>：<code>man num printf</code> 只在第 <code>num</code> 章节找，比如 <code>printf</code> 在第一章是一个命令，但是在第三章是一个函数，有可能你的系统没有安装相应手册文件，可执行 <code>yum install man-pages</code>，就能查找函数了</li><li><code>-a</code>：将所有章节的都显示出来，比如 <code>man printf</code> 它缺省从第一章开始搜索，知道就停止，用 <code>a</code> 选项，当按下 <code>q</code> 退出，他会继续往后面搜索，直到所有章节都搜索完毕</li></ul><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4ea470ff8b044fb1a4ac9382fdc3e025.png" alt="在这里插入图片描述"></p><h2 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">ls</span></span><br><span class="line">text1  text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">cp</span> text1 new_test</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">ls</span></span><br><span class="line">new_test  text1  text2</span><br></pre></td></tr></table></figure><p><code>cp</code> 指令的作用是将已存在的文件或目录，复制到新文件（若文件不存在会自行创建）或目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 源文件1 源文件2 源文件3... 目标目录/</span><br></pre></td></tr></table></figure><p>同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到此目录中。若同时指定多个文件或目录，而最后的目的地并非一个已存在的目录，则会出现错误信息</p><ul><li><code>-f</code> 或 <code>--force</code> 强行复制文件或目录， 不论目的文件或目录是否已经存在</li><li><code>-i</code> 或 <code>--interactive</code> 覆盖文件之前先询问用户</li><li><code>-r</code> 递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理</li><li><code>-R</code> 或 <code>--recursive</code> 递归处理，将指定目录下的文件及子目录一并处理</li></ul><p>🔥<strong>值得注意的是：</strong> 同一目录下，不能出现同名文件</p><h2 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">mv</span> a1 ../</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">mv</span> a1 text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">mv</span> a1 dir1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">mv</span> a1 ../text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 dir1]$ <span class="built_in">mv</span> a1 ../dir1</span><br></pre></td></tr></table></figure><p><code>mv</code> 命令是 <code>move</code> 的缩写，可以用来 <code>移动文件</code> 或者 <code>将文件改名</code></p><p><strong>第一行：</strong> 表示将文件 <code>a1</code> 剪切到上级目录下<br><strong>第二行：</strong> 表示将文件 <code>a1</code> 剪切到当前路径的文件 <code>text1</code>，即重命名<br><strong>第三行：</strong> 表示将文件 <code>a1</code> 剪切到当前路径的目录 <code>dir1</code><br><strong>第四行：</strong> 表示将文件 <code>a1</code> 剪切到上级路径的文件 <code>text1</code>，即重命名<br><strong>第五行：</strong> 表示将文件 <code>a1</code> 剪切到上级路径的目录 <code>dir1</code></p><ul><li><code>-f</code>：<code>force</code> 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</li><li><code>-i</code>：若目标文件已经存在时，就会询问是否覆盖</li></ul><h2 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ tree</span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir2</span><br><span class="line">│   │   └── dir3</span><br><span class="line">│   └── new_test</span><br><span class="line">├── my_dir</span><br><span class="line">│   ├── a1</span><br><span class="line">│   └── dir2</span><br><span class="line">│       └── dir3</span><br><span class="line">├── text1</span><br><span class="line">└── text2</span><br><span class="line"></span><br><span class="line">6 directories, 4 files</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">cat</span> dir1/new_test</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>cat</code> 的作用是查看文件内容</p><ul><li><code>-b</code> 对非空行输出行编号</li><li><code>-n</code> 对输出的所有行编号</li><li><code>-s</code> 不输出多行空行，即将多行空行压缩成一行空行输出</li></ul><h2 id="echo指令（重定向）"><a href="#echo指令（重定向）" class="headerlink" title="echo指令（重定向）"></a>echo指令（重定向）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ ll</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test 4096 Jun 26 00:12 dir1</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test 4096 Jun 22 15:21 my_dir</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test   44 Jun 29 20:41 text1</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test    0 Jun 18 22:06 text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">echo</span> <span class="string">&quot;Hello Linux&quot;</span> &gt; text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">cat</span> text2</span><br><span class="line">Hello Linux</span><br></pre></td></tr></table></figure><p>在 <code>Linux</code> 中，一切的指令本质皆是可执行文件，指令也是在系统特定路径下存在的，本来正常情况下 <code>echo</code> 是向显示器打印出来给我们看的，但是加了 <code>&gt;</code> 表示 <code>输出重定向</code>，即将本来打印到显示器的文本重定向到具体文件中（若文件不存在会自动创建）</p><p>默认情况下，<code>echo</code> 会在输出末尾自动加换行符；若要取消，在 <code>Linux</code> 中可用 <code>echo -n &quot;文本&quot;</code>，例如 <code>echo -n &quot;Hi&quot;</code> 输出后不会换行</p><p>但是 <code>&gt;</code> 在写入的时候是覆盖式写入，即先清空文件再写入，如果想要追加可以使用 <code>&gt;&gt;</code>，同样的，像 <code>cat &gt; text1</code> 这样的，叫做 <code>输入重定向</code>，其实作用和 <code>cat text1</code> 没啥区别，他的区别在深入学习后会讲</p><p>通常能够打印信息到显示器的指令都能使用输出重定向，输入重定向同理</p><h2 id="more指令"><a href="#more指令" class="headerlink" title="more指令"></a>more指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ more Text</span><br><span class="line">hello Linux 1</span><br><span class="line">hello Linux 2</span><br><span class="line">hello Linux 3</span><br><span class="line">hello Linux 4</span><br><span class="line">hello Linux 5</span><br><span class="line">hello Linux 6</span><br><span class="line">hello Linux 7</span><br><span class="line">hello Linux 8</span><br><span class="line">hello Linux 9</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>当遇上大文本时，<code>cat</code> 的查看就不适合了，因为需要自行翻找内容特别麻烦，因此 <code>cat</code> 只适合查看小文本，这个时候就要使用 <code>more</code> 指令，查看的时候可以按 <code>ENTER</code> 键向下滚动翻找</p><ul><li><code>/字符串</code>：查找特定内容</li><li><code>q</code>：退出 <code>more</code></li></ul><h2 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a>less指令</h2><p><code>less</code> 与 <code>more</code> 类似，但使用 <code>less</code> 可以使用⬆️⬇️随意浏览文件，而 <code>more</code> 仅能向前移动，却不能向后移动，而且 <code>less</code> 在查看之前不会加载整个文件，只会加载你需要看的部分，加快了文件打开速度</p><ul><li><code>-i</code>：忽略搜索时的大小写</li><li><code>-N</code>：查看的时候，输入再按 <code>ENTER</code> 会显示每行的行号</li><li><code>-n</code>：隐藏输出的所有行编号</li><li><code>/字符串</code>：向下搜索“字符串”的功能</li><li><code>?字符串</code>：向上搜索“字符串”的功能</li><li><code>q</code>：退出 <code>less</code></li><li><code>n</code>：重复前一个搜索（与 <code>/</code> 或 <code>?</code> 有关）</li><li><code>N</code>：反向重复前一个搜索（与 <code>/</code> 或 <code>?</code> 有关）</li></ul><p>用 <code>/hello</code> 搜关键词 <code>hello</code> ，找到第 <code>3</code> 行的 <code>hello</code><br>按 <code>n</code> → 继续往下（正向）找下一个 <code>hello</code><br>按 <code>N</code> → 往回（反向）找之前的 <code>hello</code> </p><h2 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a>head指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">head</span> -5 Text</span><br><span class="line">hello Linux 1</span><br><span class="line">hello Linux 2</span><br><span class="line">hello Linux 3</span><br><span class="line">hello Linux 4</span><br><span class="line">hello Linux 5</span><br></pre></td></tr></table></figure><p><code>head</code> 用于捕捉大文本的前面的内容，若没有指定行数，<code>head</code> 默认查看前十行</p><ul><li><code>-n</code>：显示的行数</li></ul><h2 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a>tail指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">tail</span> -5 Text</span><br><span class="line">hello Linux 996</span><br><span class="line">hello Linux 997</span><br><span class="line">hello Linux 998</span><br><span class="line">hello Linux 999</span><br><span class="line">hello Linux 1000</span><br></pre></td></tr></table></figure><p><code>tail</code> 用于捕捉大文本的结尾的内容，若没有指定行数，<code>tail</code> 默认查看后十行</p><ul><li><code>-f</code>：循环读取，执行后不会退出，而是持续监听文件变化，一旦文件有新内容添加（比如日志文件被写入新记录），会立即显示在屏幕上，直到手动按 <code>Ctrl + C</code> 终止</li><li><code>-n</code>：显示行数</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>有一个文件共有 <code>1000</code> 行内容，请取出第 <code>500-510</code> 行内容</p><ul><li>方法一</li></ul><ol><li><code>head -510 Text</code> 生成 <code>1</code> 到 <code>510</code> 的序列装入临时文件 <code>tmp</code></li><li><code>tail -11 tmp</code> 取出结尾 <code>500-510</code> 行的内容</li></ol><ul><li>方法二</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">head</span> -510 Text | <span class="built_in">tail</span> -11</span><br><span class="line">hello Linux 500</span><br><span class="line">hello Linux 501</span><br><span class="line">hello Linux 502</span><br><span class="line">hello Linux 503</span><br><span class="line">hello Linux 504</span><br><span class="line">hello Linux 505</span><br><span class="line">hello Linux 506</span><br><span class="line">hello Linux 507</span><br><span class="line">hello Linux 508</span><br><span class="line">hello Linux 509</span><br><span class="line">hello Linux 510</span><br></pre></td></tr></table></figure><p>利用管道文件的方法，像流水线一样快速处理多个指令，<code>|</code> 作用是将前一个命令 <code>head</code> 的输出作为后一个命令 <code>tail</code> 的输入</p><h2 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">date</span> +%Y-%m-%d_%H:%M:%S</span><br><span class="line">2025-07-04_16:40:39</span><br></pre></td></tr></table></figure><p><code>data</code> 用于显示时间</p><ol><li>在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中常用的标记列表如下</li></ol><ul><li><code>%H</code>：小时(<code>00..23</code>) </li><li><code>%M</code>：分钟(<code>00..59</code>) </li><li><code>%S</code>：秒(<code>00..61</code>) </li><li><code>%X</code>：相当于 <code>%H:%M:%S</code> </li><li><code>%d</code>：日 (<code>01..31</code>) </li><li><code>%m</code>：月份 (<code>01..12</code>) </li><li><code>%Y</code>：完整年份 (<code>0000..9999</code>) </li><li><code>%F</code>：相当于 <code>%Y-%m-%d</code></li></ul><ol start="2"><li>在设定时间方面</li></ol><ul><li><code>date -s</code> &#x2F;&#x2F;设置当前时间，只有 <code>root</code> 权限才能设置，其他只能查看。</li><li><code>date -s 20080523</code> &#x2F;&#x2F;设置成 <code>20080523</code>，这样会把具体时间设置成空 <code>00:00:00</code></li><li><code>date -s 01:01:01</code> &#x2F;&#x2F;设置具体时间，不会对日期做更改</li><li><code>date -s “01:01:01 2008-05-23″</code> &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s “01:01:01 20080523″</code> &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s “2008-05-23 01:01:01″</code> &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s “20080523 01:01:01″</code> &#x2F;&#x2F;这样可以设置全部时间</li></ul><ol start="3"><li>时间戳</li></ol><blockquote><p><strong>时间戳：</strong> 从 <code>1970</code> 年 <code>1</code> 月 <code>1</code> 日开始算的秒数，比如 <code>2025</code> 年 <code>7</code> 月 <code>4</code> 日对应的秒数是 <code>1751500800</code></p></blockquote><ul><li>时间-&gt;时间戳：<code>date +%s</code></li><li>时间戳-&gt;时间：<code>date -d@1508749502</code></li><li><code>Unix</code> 时间戳（英文为<code>Unix epoch</code>, <code>Unix time</code>, <code>POSIX time</code> 或 <code>Unix timestamp</code>）是从 <code>1970</code> 年<code>1</code> 月 <code>1</code> 日（<code>UTC</code> &#x2F; <code>GMT</code>的午夜）开始所经过的秒数，不考虑闰秒</li></ul><h2 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a>cal指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ cal</span><br><span class="line">      July 2025     </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure><p><code>cal</code> 命令可以用来显示公历（阳历）日历</p><ul><li><code>-3</code>：显示系统前一个月，当前月，下一个月的月历</li><li><code>-j</code>：显示在当年中的第几天（一年日期按天算，从 <code>1</code> 月 <code>1</code> 号算起，默认显示当前月在一年中的天数）</li><li><code>-y</code>：显示当前年份的日历，<code>cal –y 2018</code></li></ul><h2 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a>find指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ tree</span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir2</span><br><span class="line">│   │   └── dir3</span><br><span class="line">│   └── new_test</span><br><span class="line">├── my_dir</span><br><span class="line">│   ├── a1</span><br><span class="line">│   └── dir2</span><br><span class="line">│       └── dir3</span><br><span class="line">├── Text</span><br><span class="line">├── text1</span><br><span class="line">└── text2</span><br><span class="line"></span><br><span class="line">6 directories, 5 files</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ find dir1</span><br><span class="line">dir1</span><br><span class="line">dir1/new_test</span><br><span class="line">dir1/dir2</span><br><span class="line">dir1/dir2/dir3</span><br></pre></td></tr></table></figure><p><code>find</code> 可以在磁盘中进行指定文件的搜索，在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指 <code>30G</code> 字节以上的文件系统)</p><p>🔥<strong>值得注意的是：</strong> 还有一些和find功能类似的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">/usr/bin/ls</span><br></pre></td></tr></table></figure><p><code>which</code>通常用于搜索指令的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ whereis <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span>: /usr/bin/ls /usr/share/man/man1p/ls.1p.gz /usr/share/man/man1/ls.1.gz</span><br></pre></td></tr></table></figure><p><code>whereis</code> 用于查找命令、源文件和手册页的位置</p><ul><li><code>which</code> 仅查找 <code>$PATH</code> 中的可执行文件；<code>whereis</code> 搜索范围更广，包括系统默认的多个目录，且能找到手册页、源码等</li><li><code>which</code> 更侧重 “命令在哪里可以执行”，<code>whereis</code> 更侧重 “与目标相关的所有系统文件在哪里”</li></ul><h2 id="grep指令"><a href="#grep指令" class="headerlink" title="grep指令"></a>grep指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ grep 99 Text</span><br><span class="line">hello Linux 99</span><br><span class="line">hello Linux 199</span><br><span class="line">hello Linux 299</span><br><span class="line">hello Linux 399</span><br><span class="line">hello Linux 499</span><br><span class="line">hello Linux 599</span><br><span class="line">hello Linux 699</span><br><span class="line">hello Linux 799</span><br><span class="line">hello Linux 899</span><br><span class="line">hello Linux 990</span><br><span class="line">hello Linux 991</span><br><span class="line">hello Linux 992</span><br><span class="line">hello Linux 993</span><br><span class="line">hello Linux 994</span><br><span class="line">hello Linux 995</span><br><span class="line">hello Linux 996</span><br><span class="line">hello Linux 997</span><br><span class="line">hello Linux 998</span><br><span class="line">hello Linux 999</span><br></pre></td></tr></table></figure><p><code>grep</code> 指令是个行文本过滤工具，查找文件包含特定文本行的内容，并显示出来</p><ul><li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li><li><code>-n</code>：顺便输出行号</li><li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行</li></ul><h2 id="zip-unzip指令"><a href="#zip-unzip指令" class="headerlink" title="zip&#x2F;unzip指令"></a>zip&#x2F;unzip指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# zip Text.zip Text</span><br><span class="line">  adding: Text (deflated 86%)</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# tree</span><br><span class="line">.</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir2</span><br><span class="line">│   │   └── dir3</span><br><span class="line">│   └── new_test</span><br><span class="line">├── my_dir</span><br><span class="line">│   ├── a1</span><br><span class="line">│   └── dir2</span><br><span class="line">│       └── dir3</span><br><span class="line">├── Text</span><br><span class="line">├── text1</span><br><span class="line">├── text2</span><br><span class="line">└── Text.zip</span><br></pre></td></tr></table></figure><p><code>zip</code> 命令用于压缩文件，若想要解压文件，可以输入 <code>unzip Text.zip</code>。由于服务器之间的差异，可能没有这两个指令，可以使用 <code>yum install -y zip unzip</code> 进行下载</p><ul><li><code>-r</code> 递归处理，将指定目录下的所有文件和子目录一并处理</li></ul><h2 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# tar -czf code.tgz text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# ll</span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root     root       137 Jul  5 16:53 code.tgz</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jul  5 16:43 dir1</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jun 22 15:21 my_dir</span><br><span class="line">-rw-rw-r-- 1 root     root     15893 Jun 29 22:16 Text</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test    44 Jun 29 20:41 text1</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test     7 Jul  4 18:07 text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# <span class="built_in">rm</span> -rf text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# ll</span><br><span class="line">total 32</span><br><span class="line">-rw-r--r-- 1 root     root       137 Jul  5 16:53 code.tgz</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jul  5 16:43 dir1</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jun 22 15:21 my_dir</span><br><span class="line">-rw-rw-r-- 1 root     root     15893 Jun 29 22:16 Text</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test    44 Jun 29 20:41 text1</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# tar -tzf code.tgz</span><br><span class="line">text2</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# tar -xzf code.tgz</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]# ll</span><br><span class="line">total 36</span><br><span class="line">-rw-r--r-- 1 root     root       137 Jul  5 16:53 code.tgz</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jul  5 16:43 dir1</span><br><span class="line">drwxrwxr-x 3 zzh_test zzh_test  4096 Jun 22 15:21 my_dir</span><br><span class="line">-rw-rw-r-- 1 root     root     15893 Jun 29 22:16 Text</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test    44 Jun 29 20:41 text1</span><br><span class="line">-rw-rw-r-- 1 zzh_test zzh_test     7 Jul  4 18:07 text2</span><br></pre></td></tr></table></figure><p><code>tar</code> 是 <code>Linux</code> 环境里常用的压缩指令，比 <code>zip</code> 更实用，通常压缩为 <code>tar.gz</code> 格式（简写为 <code>tgz</code> ），<code>tar</code> 不能压缩为 <code>zip</code>，常用选项为 <code>-czf</code>（<code>creat zip file</code> 创建压缩文件），<code>-tzf</code>（查看压缩文件），<code>-xzf</code>（解压压缩文件）</p><ul><li><code>-c</code>：建立一个压缩文件的参数指令</li><li><code>-x</code>：解开一个压缩文件的参数指令</li><li><code>-t</code>：查看 <code>tarfile</code> 里面的文件</li><li><code>-z</code>：是否同时具有 <code>gzip</code> 的属性？亦即是否需要用 <code>gzip</code> 压缩？</li><li><code>-j</code>：是否同时具有 <code>bzip2</code> 的属性？亦即是否需要用 <code>bzip2</code> 压缩？</li><li><code>-v</code>：压缩的过程中显示文件！这个常用，但不建议用在背景执行过程！</li><li><code>-f</code>：使用档名，请留意，在 <code>f</code> 之后要立即接档名喔！不要再加参数！</li><li><code>-C</code>： 解压到指定目录</li></ul><h2 id="bc指令"><a href="#bc指令" class="headerlink" title="bc指令"></a>bc指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ bc</span><br><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details <span class="built_in">type</span> `warranty<span class="string">&#x27;. </span></span><br><span class="line"><span class="string">5 + 3 * 2</span></span><br><span class="line"><span class="string">11</span></span><br><span class="line"><span class="string">scale=3    # 设置小数位数为3</span></span><br><span class="line"><span class="string">10 / 3 </span></span><br><span class="line"><span class="string">3.333</span></span><br><span class="line"><span class="string">quit       # 退出交互模式</span></span><br></pre></td></tr></table></figure><p>直接使用bc指令进入交互模式进行计算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sqrt(25)&quot;</span> | bc -l  <span class="comment"># 计算平方根，输出 5.0000000000</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sin(3.14159/2)&quot;</span> | bc -l  <span class="comment"># 计算正弦值（弧度），约等于 1.000000</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>echo</code> 传递表达式给 <code>bc</code> 在非交互模式下进行计算，<code>-l</code> 表示调用数学库进行计算</p><h2 id="uname指令"><a href="#uname指令" class="headerlink" title="uname指令"></a>uname指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">uname</span> -r</span><br><span class="line">3.10.0-1160.119.1.el7.x86_64</span><br><span class="line">[zzh_test@hcss-ecs-6aa4 ~]$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux hcss-ecs-6aa4 3.10.0-1160.119.1.el7.x86_64 <span class="comment">#1 SMP Tue Jun 4 14:43:51 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p><code>uname -r</code> 用来获取电脑和操作系统的相关信息，<code>-a</code> 或 <code>–all</code> 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称</p><h2 id="shutdown指令"><a href="#shutdown指令" class="headerlink" title="shutdown指令"></a>shutdown指令</h2><p>关机指令</p><ul><li><code>-h</code>：将系统的服务停掉后，立即关机</li><li><code>-r</code>：在将系统的服务停掉之后就重新启动</li><li><code>-t sec</code>：<code>-t</code> 后面加秒数，即过几秒后关机的意思</li></ul><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ul><li><code>[Tab]</code> 按键：具有命令补全和档案补齐的功能</li><li><code>[Ctrl]-c</code> 按键：让当前的程序停掉</li><li><code>[Ctrl]-d</code> 按键：通常代表着键盘输入结束(<code>End Of File</code>, <code>EOF</code> 戒 <code>End OfInput</code>)的意思；另外，他也可以用来取代 <code>exit</code></li><li><code>[Ctrl]-r</code> 按键：搜索历史命令，也可以用 <code>history</code> 指令查看，通常只保存最新的 <code>1000</code> 条指令</li></ul><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3447c05d10e3425bb81264c8708dd174.jpg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【前端基础】层叠宇宙的代码旅人：css（下）</title>
      <link href="/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇是 <code>css</code> 最后的布局优化</p><h1 id="元素的显示模式"><a href="#元素的显示模式" class="headerlink" title="元素的显示模式"></a>元素的显示模式</h1><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h1 - h6</span><br><span class="line">p</span><br><span class="line">div</span><br><span class="line">ul</span><br><span class="line">ol</span><br><span class="line">li</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>特点:</strong></p><ul><li>独占一行</li><li>高度宽度，内外边距，行高都可以控制. </li><li>宽度默认是父级元素宽度的 100% (和父元素一样宽)</li><li>是一个容器(盒子)，里面可以放行内和块级元素</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>文字类的元素内不能使用块级元素，<code>p</code> 标签主要用于存放文字，内部不能放块级元素，尤其是 <code>div</code></p><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">strong</span><br><span class="line">b</span><br><span class="line">em</span><br><span class="line">i</span><br><span class="line">del</span><br><span class="line">s</span><br><span class="line">ins</span><br><span class="line">u</span><br><span class="line">span</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>特点:</strong></p><ul><li>不独占一行，一行可以显示多个</li><li>设置高度，宽度，行高无效</li><li>左右外边距有效(上下无效)，内边距有效</li><li>默认宽度就是本身的内容</li><li>行内元素只能容纳文本和其他行内元素，不能放块级元素</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p><code>a</code> 标签中不能再放 <code>a</code> 标签 (虽然 <code>chrome</code> 不报错，但是最好不要这么做)，<code>a</code> 标签里可以放块级元素，但是更建议先把 <code>a</code> 转换成块级元素</p><h2 id="行内元素和块级元素的区别"><a href="#行内元素和块级元素的区别" class="headerlink" title="行内元素和块级元素的区别"></a>行内元素和块级元素的区别</h2><ul><li>块级元素独占一行，行内元素不独占一行</li><li>块级元素可以设置宽高，行内元素不能设置宽高</li><li>块级元素四个方向都能设置内外边距，行内元素垂直方向不能设置</li></ul><h2 id="改变显示模式"><a href="#改变显示模式" class="headerlink" title="改变显示模式"></a>改变显示模式</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>这是个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>display</code> 属性可以改变元素显示模式，可以把 <code>div</code> 等变成行内元素，也可以把 <code>a</code>、<code>span</code> 等变成块级元素</p><ul><li><code>display: block</code> 改成块级元素 [常用]</li><li><code>display: inline</code> 改成行内元素 [很少用]</li><li><code>display: inline-block</code> 改成行内块元素</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6bc0982ac6694b0dbea65a179168b61a.png" alt="在这里插入图片描述"></p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d1ae9b871d844a58ba6f13f5ba86ffb7.png" alt="在这里插入图片描述"><br>每个元素都相当于一个盒子，由四个部分组成</p><ul><li>边框 <code>border</code></li><li>内容 <code>content</code></li><li>内边距 <code>padding</code></li><li>外边距 <code>margin</code></li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>数字表示长度，单位是 <code>px</code>，<code>-</code> 表示长度为 <code>0</code></p><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>粗细：<code>border-width</code></li><li>样式：<code>border-style</code>，默认没边框，<code>solid</code> 实线边框 <code>dashed</code> 虚线边框 <code>dotted</code> 点线边框</li><li>颜色：<code>border-color</code></li></ul><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d1ae9b871d844a58ba6f13f5ba86ffb7.png" alt="在这里插入图片描述"></p><p>按照正常来说应该是 <code>200*100</code> 的，但是边框撑大了盒子变成 <code>220*120</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">//* 为通配符选择器</span><br></pre></td></tr></table></figure><p>可以用 <code>box-sizing</code> 来改变浏览器默认模式，使边框不再撑大盒子，下面的内外边距同理</p><p>🔥<strong>值得注意的是：</strong> </p><p>支持简写，没有顺序要求</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border: 1px solid red;</span><br></pre></td></tr></table></figure><p>可以改四个方向的任意边框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border-top/bottom/left/right</span><br></pre></td></tr></table></figure><h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">10px</span> green solid;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>内边距<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认内容是顶着边框来放置的，用 <code>padding</code> 来控制这个距离</p><p>可以给四个方向都加上边距，也可以用简写：</p><ul><li><code>padding-top</code></li><li><code>padding-bottom</code></li><li><code>padding-left</code></li><li><code>padding-right</code></li></ul><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>padding</code>：<code>5px;</code> 表示四个方向都是 <code>5px</code></li><li><code>padding</code>：<code>5px 10px;</code> 表示上下内边距 <code>5px</code>，左右内边距为 <code>10px</code></li><li><code>padding</code>：<code>5px 10px 20px;</code> 表示上边距 <code>5px</code>，左右内边距为 <code>10px</code>，下内边距为 <code>20px</code></li><li><code>padding</code>：<code>5px 10px 20px 30px;</code> 表示上 <code>5px</code>，右 <code>10px</code>，下 <code>20px</code>，左 <code>30px</code> (顺时针)</li></ul><p>下面的外边框同理</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/872db8cce9ad4719ae2d249a85f3c670.png" alt="在这里插入图片描述"></p><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">10px</span> green solid;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>盒子1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>盒子2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制盒子和盒子之间的距离，可以给四个方向都加上边距：</p><ul><li><code>margin-top</code></li><li><code>margin-bottom</code></li><li><code>margin-left</code></li><li><code>margin-right</code></li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/423ff887c3cc4ad483c6df450b5a4aa4.png" alt="在这里插入图片描述"></p><h1 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h1><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* padding: 10px 10px 10px 10px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            margin: 10px 10px 10px 10px; */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">10px</span> green solid;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>盒子1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>盒子2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>margin: auto</code> 表示块元素自适应，会自动居中，<code>text-align: center</code> 是让文本居中</p><p>这三种写法均可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margin-left: auto; margin-right: auto;</span><br><span class="line">margin: auto;</span><br><span class="line">margin: 0 auto;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><p>对于垂直居中，不能使用 “上下 <code>margin</code> 为 <code>auto</code> “ 的方式</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d7160914d0374ac498f8525b9b19e705.png" alt="在这里插入图片描述"></p><h1 id="去除浏览器默认样式"><a href="#去除浏览器默认样式" class="headerlink" title="去除浏览器默认样式"></a>去除浏览器默认样式</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    marign: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器会给元素加上一些默认的样式，尤其是内外边距，不同浏览器的默认样式存在差别，为了保证代码在不同的浏览器上都能按照统一的样式显示，往往我们会去除浏览器默认样式</p><h1 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h1><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>:flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面的图片是没加 <code>display:flex</code> 的，后面的是加了的，这段代码的作用是让块元素里的成员能够按照代码弹性布置，而不是自适应文本的大小<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da7340b5fb04478c86368c47c4904418.png" alt="在这里插入图片描述"></p><p>当父元素设置为 <code>display: flex</code> 之后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 都会失效</p><h2 id="主轴（横轴）"><a href="#主轴（横轴）" class="headerlink" title="主轴（横轴）"></a>主轴（横轴）</h2><p><code>justify-content</code> 用于设置主轴上的子元素排列方式</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>:flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-around;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>flex-start</code>：默认值，项目位于容器的开头</li><li><code>flex-end</code>：项目位于容器的结尾</li><li><code>center</code>：项目位于容器中央</li><li><code>space-between</code>：项目在行与行之间留有间隔</li><li><code>space-around</code>：项目在行之前、行之间和行之后留有空间</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4513401b67a54d87a24ddf72abfb97cd.png" alt="在这里插入图片描述"></p><h2 id="侧轴（纵轴）"><a href="#侧轴（纵轴）" class="headerlink" title="侧轴（纵轴）"></a>侧轴（纵轴）</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>:flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: space-around;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>盒子3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>stretch</code>：默认值，行拉伸以占据剩余空间</li><li><code>center</code>：朝着弹性容器的中央对行打包</li><li><code>flex-start</code>：朝着弹性容器的开头对行打包</li><li><code>flex-end</code>：朝着弹性容器的结尾对行打包</li><li><code>space-between</code>：行均匀分布在弹性容器中</li><li><code>space-around</code>：行均匀分布在弹性容器中，两端各占一半</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p><code>align-items</code> 只能针对单行元素来实现，如果有多行元素，就需要使用 <code>item-contents</code></p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cc00a6173a2845c9876eec60945ea03d.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cf16f9662ebd46f4ada66116cf4ea9cd.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【前端基础】层叠宇宙的代码旅人：css（中）</title>
      <link href="/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接上篇css的初步学习，本篇将针对具体内容进行美化，内容不难，主要是记忆理解</p><h1 id="常用元素属性"><a href="#常用元素属性" class="headerlink" title="常用元素属性"></a>常用元素属性</h1><p>CSS 属性有很多, 可以参考文档</p><blockquote><p>传送门： <a href="https://www.w3school.com.cn/cssref/index.asp">常见元素属性参考文档</a></p></blockquote><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><h3 id="设置字体"><a href="#设置字体" class="headerlink" title="设置字体"></a>设置字体</h3><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.song</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&#x27;宋体&#x27;</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;song&quot;</span>&gt;</span>这是宋体<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这不是宋体<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li><p>字体名称可以用中文, 但是不建议</p></li><li><p>多个字体之间使用逗号分隔 (从左到右查找字体，如果都找不到，会使用默认字体)</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 先尝试使用 &quot;Times New Roman&quot; 字体，如果没有则尝试 Times，若都没有则使用 serif 默认字体 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&quot;Times New Roman&quot;</span>, Times, serif;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果字体名有空格, 使用引号包裹</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 包含空格的字体名 &quot;Palatino Linotype&quot; 使用引号包裹 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&quot;Palatino Linotype&quot;</span>, <span class="string">&quot;Book Antiqua&quot;</span>, Palatino, serif;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>建议使用常见字体, 否则兼容性不好</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aea2308230ca43428a403c73cfd79baa.png" alt="在这里插入图片描述"></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.big</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;big&quot;</span>&gt;</span>大大大<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>小小小<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li>不同的浏览器默认字号不一样，最好给一个明确值 (<code>chrome</code> 默认是 <code>16px</code>)</li><li>可以给 <code>body</code> 标签使用 <code>font-size</code></li><li>要注意单位 <code>px</code> 不要忘记 </li><li>标题标签需要单独指定大小</li></ul><p><strong>注意:</strong> 实际上它设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/60aa9d4d466742d7ad70e2722666dff1.png" alt="在这里插入图片描述"></p><h3 id="粗细"><a href="#粗细" class="headerlink" title="粗细"></a>粗细</h3><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cu</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;cu&quot;</span>&gt;</span>粗粗粗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>细细细<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li>可以使用数字表示粗细</li><li><code>700</code> &#x3D;&#x3D; <code>bold</code>, <code>400</code> 是不变粗，&#x3D;&#x3D; <code>normal</code>，变细可以用 <code>lighter</code></li><li>取值范围是 <code>100</code> -&gt; <code>900</code></li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ccec38cf267a479d9daa7d8023f2122b.png" alt="在这里插入图片描述"></p><h3 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h3><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-style</span>: italic;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>倾斜<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>不倾斜<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><p>在 <code>HTML</code> 里，<code>&lt;em&gt;</code> 和 <code>&lt;i&gt;</code> 标签默认的渲染效果是文字倾斜，它们分别用于表示强调文本和以不同语态表达的文本。不过在实际开发中，可能确实经常需要将这两个标签里的文字样式设置为不倾斜( <code>font-style: normal</code> )</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9668460c66654e27ad08a5c93dc96d30.png" alt="在这里插入图片描述"></p><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><p>使用 <code>R (red)</code>，<code>G (green)</code>，<code>B (blue)</code> 的方式表示颜色(色光三原色)三种颜色按照不同的比例搭配，就能混合出各种五彩斑斓的效果</p><p>计算机中针对 <code>R</code>，<code>G</code>，<code>B</code> 三个分量, 分别使用一个字节表示( <code>8</code> 个比特位, 表示的范围是 <code>0-255</code>，十六进制表示为 <code>00-FF</code>)</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* color: #ff0000;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            color: rgb(255, 0, 0); */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li>数值越大，表示该分量的颜色就越浓，<code>255</code>，<code>255</code>，<code>255</code> 就表示白色； <code>0</code>，<code>0</code>，<code>0</code> 就表示黑色</li><li>鼠标停在颜色图标上是可以调节颜色的，所以不需要自己查询颜色</li></ul><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/25df5fa76e4e476ba95620c6dac45aba.png" alt="在这里插入图片描述"></p><ul><li><code>color</code> 属性值的写法：预定义的颜色值(直接是单词)、[最常用] 十六进制形式、<code>RGB</code> 方式</li><li><code>#ff0000</code>，第一二位表示红色，第三四位表示绿色，第五六位表示蓝色。当有连续两位相同时可以缩写，<code>#ff00ff</code> &#x3D;&gt; <code>#f0f</code></li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1b7bfa8f039448a290d5c09c14224c61.png" alt="在这里插入图片描述"></p><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><p><code>文本对齐</code>指的是<code>文本在水平方向上相对于容器的排列方式</code>。它决定了文本的左、右边缘或者中心如何与容器的边界对齐</p><blockquote><p><code>text-align: [值];</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left-align</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right-align</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: right;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center-align</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;left-align&quot;</span>&gt;</span>这是左对齐的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;right-align&quot;</span>&gt;</span>这是右对齐的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center-align&quot;</span>&gt;</span>这是居中对齐的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><p>不光能控制文本对齐, 也能控制图片等元素居中或者靠右</p><ul><li><code>center</code>：居中对齐</li><li><code>left</code>：左对齐</li><li><code>right</code>：右对齐</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2eeae5a671774799b0504cc6c2e156c2.png" alt="在这里插入图片描述"></p><h3 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h3><blockquote><p><code>text-decoration: [值];</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: underline;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.three</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: overline;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.four</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: line-through;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">       </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>啥都没有<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>下划线<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;four&quot;</span>&gt;</span>删除线<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span>上划线<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>underline</code> 下划线，[常用]</li><li><code>none</code> 啥都没有，可以给 <code>a</code> 标签去掉下划线. </li><li><code>overline</code> 上划线，[不常用]</li><li><code>line-through</code> 删除线，[不常用]</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3e1a31886d254c84bb7509fb73d60a39.png" alt="在这里插入图片描述"></p><h3 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h3><p>控制段落的 <code>首行</code> 缩进 (其他行不影响)，注意和<code>文本对齐</code>做区分</p><blockquote><p><code>text-indent: [值];</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-indent</span>: -<span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">       </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>正常缩进<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span>反向缩进<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li>单位可以使用 <code>px</code> 或者 <code>em</code> </li><li>使用 <code>em</code> 作为单位更好，<code>1</code> 个 <code>em</code> 就是当前元素的文字大小</li><li>缩进可以是负的，表示往左缩进 (会导致文字就冒出去了)</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0b6d5e3bdbf948d789a064dcbbe8f0ac.png" alt="在这里插入图片描述"></p><h3 id="1-2-5-行高"><a href="#1-2-5-行高" class="headerlink" title="1.2.5 行高"></a>1.2.5 行高</h3><p>行高指的是上下文本行之间的基线距离</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e4ba11727ba941cb84261f3e296e1bf3.png" alt="在这里插入图片描述"></p><ol><li><strong>从上到下分别为：</strong></li></ol><ul><li>顶线</li><li>中线</li><li>基线 (相当于英语四线格的倒数第二条线)</li><li>底线</li></ul><ol start="2"><li><strong>内容区：</strong> 底线和顶线包裹的区域，即下图深灰色背景区域</li><li>其实<strong>基线</strong>之间的距离 &#x3D; <strong>顶线</strong>间距离 &#x3D; <strong>底线</strong>间距离 &#x3D; <strong>中线</strong>间距离</li></ol><blockquote><p><code>line-height: [值];</code></p></blockquote><p>🚩<strong>行高 &#x3D; 上边距 + 下边距 + 字体大小</strong></p><p>上下边距是相等的, 此处字体大小是 16px, 行高 40px, 上下边距就分别是 12px</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.line-height</span> <span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line-height&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       上一行</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">       中间行</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       下一行</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/acbf3a3b347b4660b6523edc3f4a3c9a.png" alt="在这里插入图片描述"></p><p>🚩<strong>行高也可以取 normal 等值</strong></p><p>这个取决于浏览器的实现，<code>chrome</code> 上 <code>normal</code> 为 <code>21 px</code></p><p>🚩<strong>行高等于元素高度, 就可以实现文字居中对齐</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.line-height</span> <span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line-height&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">       文本垂直居中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/069b152b3915400bbc3ba05a6616ec82.png" alt="在这里插入图片描述"></p><p>🚩<strong>行高更多体现在调整行间距</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>。。。。。。。。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span>这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字这是一行文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/433455454b9b4a188c3199738a6e7415.png" alt="在这里插入图片描述"></p><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><blockquote><p><code>background-color: [指定颜色]</code></p></blockquote><p>默认是 <code>transparent</code> (透明) 的，可以通过设置颜色的方式修改</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">226</span>, <span class="number">43</span>, <span class="number">202</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        这是沙盒背景</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f1774fc4ee044482a8405e8ae10d2528.png" alt="在这里插入图片描述"></p><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><blockquote><p><code>background-image: url(...);</code></p></blockquote><p>比 <code>image</code> 更方便控制位置(图片在盒子中的位置)</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">226</span>, <span class="number">43</span>, <span class="number">202</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">1200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">1500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">微信图片_20250214002940.jpg</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        这是沙盒背景</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里设置的是沙盒大小，所以图片会根据沙盒大小自动填充</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>url</code> 不要遗漏</li><li><code>url</code> 可以是绝对路径，也可以是相对路径</li><li><code>url</code> 上可以加引号，也可以不加</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/475b473ffd1448f99243fa0e16128497.png" alt="在这里插入图片描述"></p><h3 id="背景平铺"><a href="#背景平铺" class="headerlink" title="背景平铺"></a>背景平铺</h3><blockquote><p><code>background-repeat: [平铺方式]</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">226</span>, <span class="number">43</span>, <span class="number">202</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">700px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">preview.gif</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-repeat</span>: repeat;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* background-repeat: no-repeat; */</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/* background-repeat: repeat-x; */</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/* background-repeat: repeat-y; */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        这是沙盒背景</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><p>默认是 <code>repeat</code>，背景颜色和背景图片可以同时存在，背景图片在背景颜色的上方</p><ul><li><code>repeat</code>：平铺</li><li><code>no-repeat</code>：不平铺</li><li><code>repeat-x</code>：水平平铺</li><li><code>repeat-y</code>：垂直平铺</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4b266fef9a6344de95195f1bd8b3ec86.png" alt="在这里插入图片描述"></p><h3 id="背景位置"><a href="#背景位置" class="headerlink" title="背景位置"></a>背景位置</h3><blockquote><p><code>background-position: x y;</code></p></blockquote><p>修改图片的位置</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">226</span>, <span class="number">43</span>, <span class="number">202</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">700px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">preview.gif</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-position</span>: <span class="number">200px</span> <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        这是沙盒背景</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意范围，这里的位置表示向右移动 <code>200</code> 像素点，向下移动 <code>200</code> 像素点</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1190fc708fb44ccfa74cdb4b0e07b78c.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><p>参数有三种风格：</p><ol><li>方位名词：(<code>top</code>，<code>left</code>，<code>right</code>，<code>bottom</code>)</li><li>精确单位：坐标或者百分比(以左上角为原点)</li><li>混合单位：同时包含方位名词和精确单位</li></ol><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/92096cd27c464064bfe0ed21c9ebf794.png" alt="在这里插入图片描述"></p><h3 id="背景尺寸"><a href="#背景尺寸" class="headerlink" title="背景尺寸"></a>背景尺寸</h3><blockquote><p><code>background-size: length|percentage|cover|contain;</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: antiquewhite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">226</span>, <span class="number">43</span>, <span class="number">202</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">700px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">preview.gif</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-size</span>: <span class="number">700px</span> <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        这是沙盒背景</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ul><li>可以填具体的数值: 如 <code>40px</code> <code>60px</code> 表示宽度为 <code>40px</code>，高度为 <code>60px</code></li><li>也可以填百分比：按照父元素的尺寸设置</li><li><code>cover</code> 和 <code>contain</code> 的区别？</li></ul><p><code>cover</code> 会将背景图像等比例缩放，使图像的宽度或高度<code>至少覆盖元素的整个内容区域</code>，图像可能会部分超出元素的边界，但不会有空白区域。这意味着图像会填满整个元素，可能会<code>裁剪掉部分图像内容</code></p><p><code>contain</code> 会将背景图像等比例缩放，使图像的宽度和高度都能<code>完全包含在元素的内容区域内</code>，同时<code>保证图像的完整性</code>。也就是说，图像会尽可能大地显示在元素内，但不会超出元素的边界，可能会在元素的一侧或两侧留下空白区域</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8163b3c83bee4a0b839336923ad66c43.png" alt="在这里插入图片描述"></p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a38e2eff0b274a5dbf542d29578bb19b.png" alt="在这里插入图片描述"></p><h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><blockquote><p><code>border-radius: length;</code></p></blockquote><p><code>length</code> 是内切圆的半径，数值越大，弧线越强烈</p><p>🚩<strong>基本使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d352aa6ee30c4c26b472f3f42ca20a09.png" alt="在这里插入图片描述"></p><p>🚩<strong>生成圆形</strong></p><p>让 <code>border-radius</code> 的值为正方形宽度的一半即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0fb747073ed34ff98e5745f5ac7184c6.png" alt="在这里插入图片描述"></p><p>🚩<strong>展开写法</strong></p><p>从左上角开始，按照顺时针排列，对四个角进行弧度设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e3955caa62e7497aa8ec732cac41d15d.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f837a94d10994e26a910dbaf1521c2ca.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【前端基础】层叠宇宙的代码旅人：css（上）</title>
      <link href="/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/06/23/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/css%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在学完 <code>html</code> 的相关框架后，需要进一步学习 <code>css</code> 对网页的相关优化</p><h1 id="什么是css？"><a href="#什么是css？" class="headerlink" title="什么是css？"></a>什么是css？</h1><blockquote><p><code>css</code> 又叫做<code>层叠样式表 (Cascading Style Sheets)</code><br><code>css</code> 能够对网页中元素位置的排版进行像素级精确控制，实现美化页面的效果，能够做到页面的样式和结构分离</p></blockquote><p>💻比如：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b39a13300214441f82f76b6dc4cf7f3d.png" alt="在这里插入图片描述"></p><p>这样一个百度搜索栏，图标的大小，按键的颜色，字体的样式，都属于 <code>css</code> 的范围</p><p><strong>简单来说：</strong></p><ul><li><code>html</code> 决定页面结构</li><li><code>css</code> 控制页面的展示效果</li></ul><h1 id="基本语法规范"><a href="#基本语法规范" class="headerlink" title="基本语法规范"></a>基本语法规范</h1><blockquote><p><code>选择器 + &#123;一条/N条声明&#125;</code></p></blockquote><p>🔥<strong>值得注意的是：</strong> </p><ul><li><p>选择器决定针<code>对谁修改</code> (找谁)</p></li><li><p>声明决定<code>修改啥</code> (干啥)</p></li><li><p>声明的属性是键值对，使用 <code>;</code> 区分<code>键值对</code>，使用 <code>:</code> 区分<code>键和值</code></p></li></ul><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通常我们把 <code>css</code> 的内容写在 <code>style</code> 标签里</li><li><code>style</code> 标签可以放到页面任意位置. 一般放到 <code>head</code> 标签内</li><li><code>color</code> 表示标签的颜色，<code>font-size</code> 表示标签的像素大小</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0fa3e1f023734a27b56ec48e504d299f.png" alt="在这里插入图片描述"></p><h1 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h1><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>前面写的代码例子就是一种内部样式表，把 <code>css</code> 和 <code>html</code> 写在同一页面，会对<code>同种标签都进行操作</code></p><p>比如上面写的例子就会对所有的 <code>p</code> 标签进行修饰</p><p>但是这种方式<code>不能够对单独的标签进行操作</code>，分离的还不够彻底，尤其是 <code>css</code> 内容多的时候</p><h2 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h2><p>行内样式表通过 <code>style</code> 属性, 来<code>指定某个标签的样式</code>，只适合于写简单样式，只针对某个标签生效</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: green;&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: blue; font-size: 80px;&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到在 <code>p</code> 标签内部进行修饰能够指定特定标签的属性</p><p>而且在<code>内部样式表</code>和<code>行内样式表</code>同时对同一标签进行修饰时，<code>行内样式表的优先级更高</code></p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/35fda6449a974ca8a50a89efd31b15e3.png" alt="在这里插入图片描述"></p><h2 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h2><p>这是实际开发中最常见的方式，类似于 C++ 的声明定义分离</p><p>✏️<strong>举个例子：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/68baa063fe0a4c3f8edb6923d47df501.png" alt="在这里插入图片描述"></p><ol><li>创建一个 <code>css</code> 文件 <code>demo02.css</code></li><li>使用 <code>link</code> 标签在 <code>demo0.html</code> 文件引入 <code>css</code></li></ol><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>rel</code> 表示链接文件间的关系，<code>stylesheet</code> 表示被链接的是个样式表</li><li><code>href</code> 表示被链接文件的地址</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d7bf8f56c72142f68a7f5815cad75ddd.png" alt="在这里插入图片描述"></p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>这里我们只介绍常用的选择器，以下内容只是 <code>CSS2</code> 标准中支持的选择器，在 <code>CSS3</code> 中还做出了一些补充</p><blockquote><p>传送门：<a href="https://www.w3school.com.cn/cssref/css_selectors.asp">选择器参考文档</a></p></blockquote><h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><ul><li><p>能快速为同一类型的标签都选择出来</p></li><li><p>但是不能差异化选择</p></li></ul><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3aac8ae7d78e4b24a2ec187ba18869eb.png" alt="在这里插入图片描述"></p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><ul><li><p>差异化表示不同的标签</p></li><li><p>可以让多个标签的都使用同一个标签</p></li></ul><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./demo03.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;eat&quot;</span>&gt;</span>吃饭<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;sleep&quot;</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;play game&quot;</span>&gt;</span>玩游戏<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/454d85b0deba4fafad82834a692269dc.png" alt="在这里插入图片描述"></p><p>在 <code>p</code> 标签中加 <code>class</code> 属性进行标签标记，然后在 <code>css</code> 文件里以 <code>.</code> 开头的类名进行修饰</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>play</code> 和 <code>game</code> 都是对同一标签进行修饰，一个类可以被多个标签使用，一个标签也能使用多个类(<code>多个类名要使用空格分割，这种做法可以让代码更好复用</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.green</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">   &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果是长的类名，可以使用 <code>-</code> 分割</li><li>不要使用纯数字，或者中文，以及标签名来命名类名</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cc69a89d30f34f1a9d8e89057d3b5ebd.png" alt="在这里插入图片描述"></p><h3 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h3><p><code>id</code> 是唯一的，不能被多个标签使用 (是和<code>类选择器</code>最大的区别)，而且 <code>id</code> 选择器的优先级大于绝大部分选择器</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./demo04.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;nn&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;zz&quot;</span>&gt;</span>再见<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f447d84d7fc04abe82e9f471ddb2d614.png" alt="在这里插入图片描述"><br>在 <code>p</code> 标签中加 <code>id</code> 属性进行标签标记，然后在 <code>css</code> 文件里以 <code>#</code> 开头的 <code>id</code> 名进行修饰</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><code>id</code> 选择器的值和 <code>html</code> 中某个元素的 <code>id</code> 值相同</li><li><code>html</code> 的元素 <code>id</code> 不必带 <code>#</code></li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/38cb195a11964a99ac61ae879c7b50d7.png" alt="在这里插入图片描述"></p><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./demo04.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;nn&quot;</span>&gt;</span>前端开发<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;zz&quot;</span>&gt;</span>后端开发<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45b86812584a429a8ba4f447ab703744.png" alt="在这里插入图片描述"></p><p>使用 <code>*</code> 的定义，选取所有的标签，页面的背景会被改成绿黄色，每个标签都会带有这条选择器</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3fb8bd3274624200af09821b434d55a8.png" alt="在这里插入图片描述"></p><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><p>复合选择器是对基础选择器的综合运用</p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>后代选择器又叫<code>包含选择器</code>，选择某个父元素中的某个子元素</p><blockquote><p><code>元素1 元素2 &#123;样式声明&#125;</code></p></blockquote><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./demo05.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/68e8b4fc99c54e0da25de94636145569.png" alt="在这里插入图片描述"></p><p>如果我们单纯想对有序列表进行修改，或许可以给每个 <code>li</code> 加类名实现，但是数据万一很多就麻烦了，因此这里使用包含选择器</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>元素 <code>1</code> 和 元素 <code>2</code> 要使用空格分割</li><li>元素 <code>1</code> 是父级, 元素 <code>2</code> 是子级，只选元素 <code>2</code> ，不影响元素 <code>1</code></li><li>元素 <code>2</code> 不一定非是 儿子，也可以是孙子</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/10c982fe858741e0a993cfb297e2608e.png" alt="在这里插入图片描述"></p><ul><li>可以是任意基础选择器的组合 (包括类选择器，<code>id</code> 选择器)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>eee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>fff<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/46ac83b01ede4f5d8feec023a91ae903.png" alt="在这里插入图片描述"></p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/369f152192964010b97818ceba462eba.png" alt="在这里插入图片描述"></p><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>和后代选择器类似，但是只能选择子标签</p><blockquote><p><code>元素1&gt;元素2 &#123; 样式声明 &#125;</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>后代选择器</code>的写法, 会把链接 <code>1</code> 和 <code>2</code> 都选中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bf016c14f60c45f0a9bb3b87a8846dc4.png" alt="在这里插入图片描述"></p><p><code>子选择器</code>的写法, 只选链接 <code>1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e4721a25aeef42f18f726b5cf35e6fe8.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><p>使用大于号分割</p></li><li><p>只选亲儿子，不选孙子元素</p></li></ul><h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>用于选择多组标签 (集体声明)</p><blockquote><p><code>元素1, 元素2 &#123; 样式声明 &#125;</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>鸭梨<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>橙子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所有水果颜色改成红色</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/be49e5e929594e58b194b99f399884e6.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>通过 <code>,</code> 分割等多个元素，表示同时选中元素 1 和 元素 2</li><li>任何基础选择器都可以使用并集选择器</li><li>并集选择器建议竖着写，每个选择器占一行 (最后一个选择器不能加逗号)</li></ul><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="链接伪类选择器"><a href="#链接伪类选择器" class="headerlink" title="链接伪类选择器"></a>链接伪类选择器</h4><blockquote><p><code>a</code> 选择链接<br><code>a:link</code> 选择未被访问过的链接<br><code>a:visited</code> 选择已经被访问过的链接<br><code>a:hover</code> 选择鼠标指针悬停上的链接<br><code>a:active</code> 选择活动链接(鼠标按下了但是未弹起)</p></blockquote><p>🔥<strong>值得注意的是：</strong> </p><ul><li>如何让一个已经被访问过的链接恢复成未访问的状态?</li></ul><p>清空浏览器历史记录即可 <code>ctrl</code> + <code>shift</code> + <code>delete</code></p><ul><li>需要按照 <code>LVHA</code> 的顺序书写，例如把 <code>active</code> 拿到前面去，就会导致 <code>active</code> 失效，记忆规则 “绿化”</li></ul><p>在 <code>CSS</code> 中，<code>LVHA</code> 顺序指的是 :<code>link</code>（未访问的链接）、<code>:visited</code>（已访问的链接）、<code>:hover</code>（鼠标悬停在链接上）、<code>:active</code>（激活的链接，即鼠标按下但未松开时）这几种伪类的顺序。按照这个顺序书写样式，才能保证在不同状态下样式正确显示</p><ul><li>实际开发主要给链接做一个样式，然后给 <code>hover</code> 做一个样式即可，<code>link</code>，<code>visited</code>，<code>active</code> 用的不多</li></ul><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>不跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f93644a2cf6c45a9a9e5bd940d48be7a.png" alt="在这里插入图片描述"></p><h4 id="force-伪类选择器"><a href="#force-伪类选择器" class="headerlink" title=":force 伪类选择器"></a>:force 伪类选择器</h4><p><code>:force</code> 伪类选择器也是同理，但是还有一种 <code>focus</code> 样式比较常用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b425c9fc187d49109b722af59dfad6ac.png" alt="在这里插入图片描述"></p><p>此时被选中的表单的字体就会变成红色</p><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span><span class="selector-pseudo">:active</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/63fb60bd442344f98ff9e98475dd3fea.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0cf9e5349aa5437d94c0d0bff48fb253.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【前端基础】摩天之建的艺术：html（下）</title>
      <link href="/2025/06/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/06/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接上一篇，继续学习剩下的 <code>html</code> 知识点</p><h1 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;20&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>table</code> 标签：表示整个表格</li><li><code>tr</code>：表示表格的一行</li><li><code>td</code>：表示一个单元格</li><li><code>th</code>：表示表头单元格. 会居中加粗</li><li><code>thead</code>：表格的头部区域(注意和 <code>th</code> 区分，范围是比 <code>th</code> 要大的)</li><li><code>tbody</code>：表格得到主体区域</li></ul><p><code>table</code> 包含 <code>tr</code>，<code>tr</code> 包含 <code>td</code> 或者 <code>th</code></p><p>表格标签有一些属性，可以用于设置大小边框等，但是一般使用 <code>css</code> 方式来设置<br>这些属性都要放到 <code>table</code> 标签中</p><ul><li><code>align</code> 是表格相对于周围元素的对齐方式，<code>align=&quot;center&quot;</code> (不是内部元素的对齐方式)</li><li><code>border</code> 表示边框，<code>1</code> 表示有边框(数字越大，边框越粗)，<code>&quot; &quot;</code> 表示没边框</li><li><code>cellpadding</code>：内容距离边框的距离，默认 <code>1</code> 像素</li><li><code>cellspacing</code>：单元格之间的距离，默认为 <code>2</code> 像素</li><li><code>width / height</code>：设置尺寸</li></ul><p>注意，这几个属性，<code>vscode</code> 都提示不出来</p><p>🔥<strong>值得注意的是：</strong> </p><p><code>SHIFT + ALT + ↓</code> 可以快速复制某一行</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ffcf1c3716b04609b1c323b22cca7686.png" alt="在这里插入图片描述"></p><h2 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;20&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;男&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>王五 / 女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;女&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>23<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>跨行合并：</strong> <code>rowspan=&quot;n&quot;</code></li><li><strong>跨列合并：</strong> <code>colspan=&quot;n&quot;</code></li></ul><p>跨行是向下合并，跨列是向左合并，注意注释掉别的单元格，避免排版错误</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f9beed7906ed49ce81abeb0eb380b0d7.png" alt="在这里插入图片描述"></p><h1 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">type</span>=<span class="string">&quot;disc&quot;</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">type</span>=<span class="string">&quot;square&quot;</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>ul</code> 表示无序列表（<code>unorder_list</code>），<code>li</code> 表示每一行列表</p><p><strong>每行列表前的样式可以自行选择：</strong></p><ul><li><code>disc</code> 表示实心圆（默认）</li><li><code>square</code> 表示实心正方形</li><li><code>circle</code> 表示空心圆</li></ul><p>🔥<strong>值得注意的是：</strong> </p><p>对于所有列表都可以使用比如：<code>ul&gt;li*3</code> 的方式快速生成列表</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/806ff5516658458d8848d00a6d040b06.png" alt="在这里插入图片描述"></p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;A&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;I&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小猫<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小兔<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>小狗<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>ol</code> 表示有序列表（<code>order_list</code>），<code>li</code> 表示每一行列表</p><p><strong>每行列表前的样式可以自行选择：</strong></p><ul><li><code>1</code> 表示数字编号（默认）</li><li><code>A</code> 表示大写英文字母编号</li><li><code>a</code> 表示小写英文字母编号</li><li><code>i</code> 表示小写罗马数字编号</li><li><code>I</code> 表示大写罗马数字编号</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/df655c069938466ab383b1ba4871c292.png" alt="在这里插入图片描述"></p><h2 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span> 这是标题</span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dl</code> 表示自定义列表，<code>dt</code> 表示列表的标题，<code>dd</code> 表示列表内容</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>元素之间是并列关系</li><li><code>ul/ol</code> 中只能放 <code>li</code> 不能放其他标签，<code>dl</code> 中只能放 <code>dt</code> 和 <code>dd</code></li><li><code>li</code> 中可以放其他标签</li><li>列表带有自己的样式，可以使用 <code>css</code> 来修改(例如前面的小圆点都会去掉)</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9f0dffbc646548779274cb7d7a845cf1.png" alt="在这里插入图片描述"></p><h1 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h1><p>比如在输入账号密码的框框部分，就是一种表单标签，会与后端进行数据交互</p><p><strong>分成两个部分:</strong></p><ul><li>表单域：包含表单元素的区域，重点是 <code>form</code> 标签</li><li>表单控件：输入框，提交按钮等，重点是 <code>input</code> 标签</li></ul><h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;test.html&quot;</span>&gt;</span></span><br><span class="line">   ... [form 的内容]</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>描述了要把数据按照什么方式，提交到哪个页面中，一系列实现都是在这个标签域里，<code>action</code> 后面接的是后端服务器的接收地址</p><h2 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h2><ol><li>文本框</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>密码框</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>单选框</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性别: </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure><p>单选框之间必须具备相同的 <code>name</code> 属性，才能实现多选一效果，<code>checked</code> 表示默认选择</p><ol start="4"><li>复选框</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">爱好:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>吃饭 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>睡觉 </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>打游戏</span><br></pre></td></tr></table></figure><ol start="5"><li>普通按钮</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是个按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello&#x27;)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>onclick=&quot;alert(&#39;hello&#39;)&quot;</code> 属于 <code>js</code> 的范畴，后面会学习的</p><ol start="6"><li>提交按钮</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;test.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>提交按钮必须放到 <code>form</code> 标签内，点击后就会尝试给服务器发送</p><ol start="7"><li>清空按钮</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;test.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="8"><li>选择文件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击选择文件，会弹出对话框，选择文件</p><h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搭配 <code>input</code> 使用，点击文字也能选中对应的单选&#x2F;复选框，能够提升用户体验</p><p><code>for</code> 属性指定当前 <code>label</code> 和哪个相同 <code>id</code> 的 <code>input</code> 标签对应(此时点击才是有用的)</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a67b99ee80942bdb63b1cab5cd20bc7.png" alt="在这里插入图片描述"></p><h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>select</code> 表示下拉菜单，<code>option</code> 表示选项</p><p><code>option</code> 中定义 <code>selected=&quot;selected&quot;</code> 表示默认选中</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c4930b801dc544728d77be935c63fa01.png" alt="在这里插入图片描述"></p><h2 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>textarea</code> 标签表示一个文本域</p><ul><li><code>rows=&quot;10&quot;</code>：设置文本区域的可见行数为 <code>10</code> 行</li><li><code>cols=&quot;50&quot;</code>：设置文本区域的可见字符宽度为 <code>50</code> 个字符</li></ul><p>🔥<strong>值得注意的是：</strong></p><p><code>rows</code> 和 <code>cols</code> 一般不会直接使用，都是用 <code>css</code> 来改的</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/78c7681ef4b8415e816be0c9f39c6672.png" alt="在这里插入图片描述"></p><h1 id="无语义标签"><a href="#无语义标签" class="headerlink" title="无语义标签"></a>无语义标签</h1><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>咬人猫<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>咬人猫<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>咬人猫<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>兔总裁<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>兔总裁<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>兔总裁<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿叶君<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿叶君<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>阿叶君<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就是两个盒子，方便用于网页布局</p><ul><li><code>div</code> 是独占一行的，是一个大盒子 </li><li><code>span</code> 不独占一行，是一个小盒子</li></ul><p>✏️<strong>展示效果：</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1d7eb2bb754544e295d5dfb464fc4efe.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/11ac743eb2764723b2488981f7cf63fc.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【前端基础】摩天之建的艺术：html（上）</title>
      <link href="/2025/06/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/06/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>从本篇开始学习前端基础之 <code>html</code> 的搭建路程，实现一个基本的静态网站框架，一般使用的软件是 <code>VSCODE</code>，可以自行上网查询下载配置教程</p><h1 id="什么是html？"><a href="#什么是html？" class="headerlink" title="什么是html？"></a>什么是html？</h1><blockquote><p><code>html</code> 即超文本标记语言（<code>HyperText Markup Language</code>）<br>它是用于创建网页的标准标记语言，<code>html</code> 借助各类标签来对网页的结构和内容加以描述</p></blockquote><p><code>html</code> 代码是由标签构成的</p><p>💻比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>标签名 (<code>body</code>) 放到 <code>&lt; &gt;</code> 中</li><li>大部分标签成对出现，<code>&lt;body&gt;</code> 为开始标签，<code>&lt;/body&gt;</code> 为结束标签</li><li>少数标签只有开始标签，称为 “单标签” </li><li>开始标签和结束标签之间，写的是标签的内容(<code>hello</code>)</li><li>开始标签中可能会带有 “属性”，<code>id</code> 属性相当于给这个标签设置了一个唯一的标识符(身份证号码)</li></ul><h1 id="html文件基本结构"><a href="#html文件基本结构" class="headerlink" title="html文件基本结构"></a>html文件基本结构</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">       hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>html</code> 标签是整个 <code>html</code> 文件的根标签(最顶层标签)，所有代码都是写在这里面的</li><li><code>head</code> 标签中写页面的属性</li><li><code>body</code> 标签中写的是页面上显示的内容</li><li><code>title</code> 标签中写的是页面的标题</li></ul><p><code>head</code> 和 <code>body</code> 是 <code>html</code> 的子标签(<code>html</code> 就是 <code>head</code> 和 <code>body</code> 的父标签)，<code>title</code> 是 <code>head</code> 的子标签，<code>head</code> 是 <code>title</code> 的父标签，<code>head</code> 和 <code>body</code> 之间是兄弟关系</p><p>标签之间的结构关系, 构成了一个 <code>DOM</code> 树：<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6122c3efdcd044458ff28683b017493f.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按住 <code>SHIFT + !</code>，按 <code>ENTER</code> 键，此时能自动生成代码的主体框架</p><ul><li><code>&lt;!DOCTYPE html&gt;</code> 称为 <code>DTD</code> (文档类型定义)，描述当前的文件是一个 <code>HTML5</code> 的文件</li><li><code>&lt;html lang=&quot;en&quot;&gt;</code> 其中 <code>lang</code> 属性表示当前页面是一个 “英语页面”，这里暂时不用管(有些浏览器会根据此处的声明提示是否进行自动翻译)</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> 描述页面的字符编码方式，没有这一行可能会导致中文乱码</li><li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>。<code>name=&quot;viewport&quot;</code> 其中 <code>viewport</code> 指的是设备的屏幕上能用来显示我们的网页的那一块区域。<code>content=&quot;width=device-width, initial-scale=1.0&quot;</code> 在设置可视区和设备宽度等宽，并设置初始缩放为不缩放(这个属性对于移动端开发更重要一些)</li><li>记得每次修改代码需要 <code>CTRL + S</code> 保存代码才会在网页上生效</li></ul><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a79089bf7b36433bad0eda8bc93e44da.png" alt="在这里插入图片描述"></p><p>可以在浏览器界面按 <code>F12</code> 打开开发者工具查看页面结构，每个标签相当于一个对象，程序员可以通过这些代码对网页进行增删查改</p><h1 id="htm常见标签"><a href="#htm常见标签" class="headerlink" title="htm常见标签"></a>htm常见标签</h1><h2 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是注释 --&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>CTRL + /</code> 快捷键快速进行注释&#x2F;取消注释</p><p>🔥<strong>值得注意的是：</strong> 可以 <code>F12</code> 查看注释</p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一级标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是二级标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是三级标签<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是四级标签<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是五级标签<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是六级标签<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从 <code>h1-h6</code>，数字越大，则字体越小</p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a05b2a5202ca4cd3bb111e0135372dcd.png" alt="在这里插入图片描述"></p><h2 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>最终还是败给资本了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我几乎每个星期四都在转发，但是就是没人V我50，不知道是不是有人在背后做局阴我<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>可能是我动了谁的汉堡 香辣鸡腿堡 劲脆鸡腿堡 新奥尔良烤鸡腿堡 老北京鸡肉卷 墨西哥鸡肉卷 深海鳕鱼堡 田园脆鸡堡 川辣嫩牛五方 薯条（小/中/大） 土豆泥 香甜粟米棒 四季鲜蔬 玉米色拉 胡萝卜餐包 深海鳕鱼条 上校鸡块 鸡米花 奥尔良烤翅 吮指原味鸡 香辣鸡翅 葡式蛋挞 草莓蛋挞 脆皮甜筒 草莓圣代 巧克力圣代 咖啡 果汁 冰爽茶 纯牛奶 红茶 蜂蜜茶 奶茶 百事可乐 七喜 美年达<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>资本你赢了！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用 <code>p</code> 标签表示一个段落，因为代码里的换行在网页里只会显示为一个空格</p><ul><li><code>p</code> 标签之间存在一个空隙</li><li>当前的 <code>p</code> 标签描述的段落，前面还没有缩进(未来 <code>css</code> 会学)</li><li>自动根据浏览器宽度来决定排版</li><li><code>html</code> 内容首尾处的换行，空格均无效</li><li>在 <code>html</code> 中文字之间输入的多个空格只相当于一个空格</li></ul><p>✏️<strong>展示效果：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/80e0897eb13843d18be9947dd3acd70f.png" alt="在这里插入图片描述"></p><h2 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>最终还是败给资本了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我几乎每个星期四都在转发,但是就是没人V我50,<span class="tag">&lt;<span class="name">br</span>/&gt;</span>不知道是不是有人在背后做局阴我<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>可能是我动了谁的汉堡 香辣鸡腿堡 劲脆鸡腿堡 新奥尔良烤鸡腿堡 老北京鸡肉卷 墨西哥鸡肉卷 深海鳕鱼堡 田园脆鸡堡 川辣嫩牛五方 薯条（小/中/大） 土豆泥 香甜粟米棒 四季鲜蔬 玉米色拉 胡萝卜餐包 深海鳕鱼条 上校鸡块 鸡米花 奥尔良烤翅 吮指原味鸡 香辣鸡翅 葡式蛋挞 草莓蛋挞 脆皮甜筒 草莓圣代 巧克力圣代 咖啡 果汁 冰爽茶 纯牛奶 红茶 蜂蜜茶 奶茶 百事可乐 七喜 美年达<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>资本你赢了！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>br</code> 是 <code>break</code> 的缩写，表示换行</p><ul><li><code>br</code> 是一个单标签(不需要结束标签)</li><li><code>br</code> 标签比 <code>p</code> 标签的间隔空隙小</li><li><code>&lt;br/&gt;</code> 是规范写法，不建议写成 <code>&lt;br&gt;</code></li></ul><p>✏️<strong>展示效果：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/329e056d11f6433f901123a03f3f99ff.png" alt="在这里插入图片描述"></p><h2 id="格式化标签"><a href="#格式化标签" class="headerlink" title="格式化标签"></a>格式化标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>strong 加粗<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>b 加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>em 倾斜<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>i 倾斜<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>del 删除线<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">s</span>&gt;</span>s 删除线<span class="tag">&lt;/<span class="name">s</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>ins 下划线<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">u</span>&gt;</span>u 下划线<span class="tag">&lt;/<span class="name">u</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>css</code> 也可以完成类似的效果，但是 <code>html</code> 里也有相关的实现，实际开发中以 <code>css</code> 方式为主</p><ul><li><strong>加粗：</strong> <code>strong</code> 标签 和 <code>b</code> 标签</li><li><strong>倾斜：</strong> <code>em</code> 标签 和 <code>i</code> 标签</li><li><strong>删除线：</strong> <code>del</code> 标签 和 <code>s</code> 标签</li><li><strong>下划线：</strong> <code>ins</code> 标签 和 <code>u</code> 标签</li></ul><p>🔥<strong>值得注意的是：</strong> <code>strong</code> 和 <code>b</code> 的区别在于强调的程度不同，比如在爬取网站的重要内容时，会优先爬取 <code>strong</code> 的文本，其他标签也是同理</p><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>img</code> 标签必须带有 <code>src</code> 属性，表示图片的路径</p><p>这里图片路径分为两种 </p><ul><li><p><strong>绝对路径：</strong><br>磁盘路径 <code>C:\Users\ZHANGZHANHUA\Desktop\微信图片_20250603234406.png</code><br>网络路径 <code>https://blog.csdn.net/Zero_VPN?spm=1011.2415.3001.5343</code></p></li><li><p><strong>相对路径：</strong><br>同级路径 直接写文件名即可 (或者 <code>./</code>)<br>下一级路径 <code>image/1.jpg</code><br>上一级路径 <code>../image/1.jpg</code></p></li></ul><p><strong>图片标签的其他属性：</strong></p><ul><li><code>alt</code>：替换文本，当文本不能正确显示的时候，会显示一个替换的文字</li><li><code>title</code>：提示文本，鼠标放到图片上，就会有提示</li><li><code>width/height</code>：控制宽度高度. 高度和宽度一般改一个就行，另外一个会等比例缩放，否则就会图片失衡</li><li><code>border</code>：边框，参数是宽度的像素，但是一般使用 <code>css</code> 来设定</li></ul><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\ZHANGZHANHUA\Desktop\壁纸\微信图片_20250603234406.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;不能显示&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是磁盘图片链接&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1200px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;800px&quot;</span> <span class="attr">border</span>=<span class="string">&quot;4px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>✏️<strong>展示效果：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc2dfb44f7b2412ba1171b8860adcfa5.png" alt="在这里插入图片描述"></p><h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><p>✏️<strong>举个例子：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/Zero_VPN?spm=1011.2415.3001.5343&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>我的博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>空链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.csdn.net/Zero_VPN?spm=1011.2415.3001.5343&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\ZHANGZHANHUA\Desktop\壁纸\微信图片_20250603234406.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;不能显示&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是磁盘图片链接&quot;</span> <span class="attr">width</span>=<span class="string">&quot;120px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;80px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.zip&quot;</span>&gt;</span>下载文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>href</code>：必须具备，表示点击后会跳转到哪个页面</li><li><code>target</code>：打开方式，默认是 <code>_self</code>，在当前页面跳转，如果是 <code>_blank</code> 则用新的标签页打开</li></ul><p>🔥<strong>值得注意的是：</strong> 使用 <code>#</code> 在 <code>href</code> 中占位表示空连接，禁止 <code>a</code> 标签跳转: <code>&lt;a href=&quot;javascript:void(0);&quot;&gt;</code> 或者 <code>&lt;a href=&quot;javascript:;&quot;&gt;</code></p><p>✏️<strong>展示效果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fb136fd6f8d448989afd994e4ae2a268.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/addab3410d1b41d6a8117e90bedfa13e.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据的输入输出秘境：IO流</title>
      <link href="/2025/06/14/CPP%E8%BF%9B%E9%98%B6/IO%E6%B5%81/"/>
      <url>/2025/06/14/CPP%E8%BF%9B%E9%98%B6/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p><code>C++</code> 的输入输出都依靠 <code>IO</code> 流实现，本章为 <code>C++</code> 最后一章，后续如有遗漏将会继续补充</p><h1 id="C语言IO流"><a href="#C语言IO流" class="headerlink" title="C语言IO流"></a>C语言IO流</h1><p><code>C</code> 语言中我们用到的最频繁的输入输出方式就是 <code>scanf ()</code> 与 <code>printf()</code>，<code>scanf()</code>：从标准输入设备(键盘)读取数据，并将值存放在变量中。<code>printf()</code>：将指定的文字&#x2F;字符串输出到标准输出设备(屏幕)</p><p>注意宽度输出和精度输出控制。<code>C</code> 语言借助了相应的缓冲区来进行输入与输出。如下图所示：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c21cc906086e4cbf9b602fdadfc611f1.png" alt="在这里插入图片描述"></p><p><strong>对输入输出缓冲区的理解：</strong></p><ol><li>可以屏蔽掉低级 <code>I</code> &#x2F; <code>O</code>的实现，低级 <code>I</code> &#x2F; <code>O</code> 的实现依赖操作系统本身内核的实现，所以如果能够屏蔽这部分的差异，可以很容易写出可移植的程序</li><li>可以使用这部分的内容实现“行”读取的行为，对于计算机而言是没有“行”这个概念，有了这部分，就可以定义“行”的概念，然后解析缓冲区的内容，返回一个“行”</li></ol><h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><blockquote><p>“流”即是流动的意思，是物质从一处向另一处流动的过程，是对一种有序连续且具有方向性的数据（其单位可以是 <code>bit</code>、<code>byte</code>、<code>packet</code>）的抽象描述<br><code>C++</code> 流是指信息从外部输入设备（如键盘）向计算机内部（如内存）输入和从内存向外部输出设备（显示器）输出的过程。这种输入输出的过程被形象的比喻为“流”</p></blockquote><p><strong>它的特性是：</strong> 有序连续、具有方向性</p><p>为了实现这种流动，<code>C++</code> 定义了 <code>I</code> &#x2F; <code>O</code> 标准类库，这些每个类都称为流&#x2F;流类，用以完成某方面的功能</p><h1 id="C-IO流"><a href="#C-IO流" class="headerlink" title="C++IO流"></a>C++IO流</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6c34c1e5fa6c4e598784643652f987b6.png" alt="在这里插入图片描述"></p><p><code>C++</code> 系统实现了一个庞大的类库，其中 <code>ios</code> 为基类，其他类都是直接或间接派生自 <code>ios</code> 类</p><h2 id="C-标准IO流"><a href="#C-标准IO流" class="headerlink" title="C++标准IO流"></a>C++标准IO流</h2><p><code>C++</code> 标准库提供了 <code>4</code> 个全局流对象 <code>cin</code>、<code>cout</code>、<code>cerr</code>、<code>clog</code>，使用 <code>cout</code> 进行标准输出，即数据从内存流向控制台(显示器)。使用 <code>cin</code> 进行标准输入即数据通过键盘输入到程序中，同时 <code>C++</code> 标准库还提供了 <code>cerr</code> 用来进行标准错误的输出，以及 <code>clog</code> 进行日志的输出，从上图可以看出，<code>cout</code>、<code>cerr</code>、<code>clog</code> 是 <code>ostream</code> 类的三个不同的对象，因此这三个对象现在基本没有区别，只是应用场景不同</p><p>在使用时候必须要包含文件并引入 <code>std</code> 标准命名空间</p><p><strong>注意：</strong></p><ol><li><code>cin</code> 为缓冲流。键盘输入的数据保存在缓冲区中，当要提取时，是从缓冲区中拿。如果一次输入过多，会留在那儿慢慢用，如果输入错了，必须在回车之前修改，如果回车键按下就无法挽回了。只有把输入缓冲区中的数据取完后，才要求输入新的数据</li><li>输入的数据类型必须与要提取的数据类型一致，否则出错。出错只是在流的状态字 <code>state</code> 中对应位置位（置1），程序继续</li><li>空格和回车都可以作为数据之间的分格符，所以多个数据可以在一行输入，也可以分行输入。但如果是字符型和字符串，则空格（ <code>ASCII</code> 码为 <code>32</code> ）无法用 <code>cin</code> 输入，字符串中也不能有空格。回车符也无法读入</li></ol><table><thead><tr><th>操作</th><th>是否跳过空白符</th><th>读取内容</th><th>典型场景</th></tr></thead><tbody><tr><td><code>cin &gt;&gt; ch;</code></td><td>是</td><td>下一个非空白字符</td><td>读取用户输入的非空白字符（如姓名首字母）</td></tr><tr><td><code>cin.get(ch);</code></td><td>否</td><td>下一个字符（包括空白符）</td><td>读取文件中的原始字符（如换行符）</td></tr><tr><td><code>cin.getline(buf, size);</code></td><td>否</td><td>读取一整行（直到换行符）</td><td>读取包含空格的句子</td></tr></tbody></table><ol start="4"><li><code>cin</code> 和 <code>cout</code> 可以直接输入和输出内置类型数据，原因：标准库已经将所有内置类型的输入和输出全部重载了</li><li>对于自定义类型，如果要支持 <code>cin</code> 和 <code>cout</code> 的标准输入输出，需要对 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 进行重载</li><li>在线 <code>OJ</code> 中的输入和输出：</li></ol><ul><li>对于 <code>IO</code> 类型的算法，一般都需要循环输入：</li><li>输出：严格按照题目的要求进行，多一个少一个空格都不行</li><li>连续输入时，<code>vs</code> 系列编译器下在输入 <code>ctrl + Z</code> 时结束</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个元素循环输入</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个元素循环输入</span></span><br><span class="line"><span class="keyword">while</span> (c &gt;&gt; a &gt;&gt; b &gt;&gt; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 整行接收</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>istream</code> 类型对象转换为逻辑条件判断值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt; (<span class="type">int</span>&amp; val);</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>实际上我们看到使用 <code>while(cin&gt;&gt;i)</code> 去流中提取对象数据时，调用的是 <code>operator&gt;&gt;</code>，返回值是 <code>istream</code> 类型的对象，那么这里可以做逻辑条件值，源自于 <code>istream</code> 的对象又调用了<code>operator bool</code>，<code>operator bool</code> 调用时如果接收流失败，或者有结束标志，则返回 <code>false</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="type">const</span> Date&amp; d);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">, _month(month)</span><br><span class="line">, _day(day)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 这里是随意写的，假设输入_year为0，则结束</span></span><br><span class="line"><span class="keyword">if</span> (_year == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; d._year &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d._month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d._day;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++ IO流，使用面向对象+运算符重载的方式</span></span><br><span class="line"><span class="comment">// 能更好的兼容自定义类型，流插入和流提取</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 自动识别类型的本质--函数重载</span></span><br><span class="line"><span class="comment">// 内置类型可以直接使用--因为库里面ostream类型已经实现了</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> j = <span class="number">2.2</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 自定义类型则需要我们自己重载&lt;&lt; 和 &gt;&gt;</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2022</span>, <span class="number">4</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; d;</span><br><span class="line"><span class="keyword">while</span> (d)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">cout &lt;&lt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-文件IO流"><a href="#C-文件IO流" class="headerlink" title="C++文件IO流"></a>C++文件IO流</h2><p><code>C++</code> 的文件输入 &#x2F; 输出（<code>File I/O</code>）通过标准库中的流类实现，主要涉及以下三个类：</p><ul><li><code>ifstream</code>（<code>Input File Stream</code>）：用于从文件读取数据（输入）</li><li><code>ofstream</code>（<code>Output File Stream</code>）：用于向文件写入数据（输出）</li><li><code>fstream</code>（<code>File Stream</code>）：支持读写操作，兼具 <code>ifstream</code> 和 <code>ofstream</code> 的功能</li></ul><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><ol><li>包含头文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// 文件流操作</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// 字符串操作（可选）</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>打开文件<br>使用构造函数或 <code>open()</code> 方法打开文件，需指定文件名和打开模式</li></ol><p><strong>打开模式（可选组合）：</strong></p><ul><li><p><code>ios::in</code>：读模式（默认用于 <code>ifstream</code>）</p></li><li><p><code>ios::out</code>：写模式（默认用于 <code>ofstream</code>，会清空文件）</p></li><li><p><code>ios::app</code>：追加模式（不清空文件，在末尾写入，<code>ios::out | ios::app</code>：追加写入文件）</p></li><li><p><code>ios::binary</code>：二进制模式（用于非文本文件，<code>ios::in | ios::binary</code>：以二进制模式读取文件）</p></li><li><p><code>ios::trunc</code>：截断模式（打开时清空文件，默认与 <code>ios::out</code> 一起使用，<code>ios::out | ios::trunc</code>）</p></li></ul><p>🔥<strong>值得注意的是：</strong> <code>ios::</code> 是 <code>std</code> 的内部类，必须加上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：使用构造函数</span></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;         <span class="comment">// 读文件（默认模式为 ios::in）</span></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;       <span class="comment">// 写文件（默认模式为 ios::out）</span></span><br><span class="line"><span class="function">ofstream <span class="title">fapp</span><span class="params">(<span class="string">&quot;append.txt&quot;</span>, ios::out | ios::app)</span></span>;  <span class="comment">// 追加模式</span></span><br><span class="line"><span class="comment">//创建文件的时候默认调用ios::out | ios::trunc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：使用 open() 方法（可先创建对象，后打开文件）</span></span><br><span class="line">fstream file;</span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;data.txt&quot;</span>, ios::in | ios::out);  <span class="comment">// 读写模式</span></span><br></pre></td></tr></table></figure><ol start="3"><li>检查文件是否成功打开</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fin.<span class="built_in">is_open</span>()) &#123;  <span class="comment">// 或直接用 if (!fin)</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>读写文件</li></ol><p>写入文件：使用 <code>&lt;&lt;</code> 运算符（类似 <code>cout</code>）<br>读取文件：使用 <code>&gt;&gt;</code> 运算符（类似 <code>cin</code>）或 <code>getline()</code> 逐行读取</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">fout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;  <span class="comment">// 写入字符串和换行符</span></span><br><span class="line">fout &lt;&lt; <span class="number">42</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">3.14</span> &lt;&lt; endl;  <span class="comment">// 写入数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件（按空格分隔）</span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line">fin &gt;&gt; num &gt;&gt; d;  <span class="comment">// 从文件读取整数和浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐行读取文件</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(fin, line)) &#123;  <span class="comment">// 每次读取一行，直到文件结束</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;读取的行：&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>关闭文件</li></ol><p>文件操作结束后，使用 <code>close()</code> 方法关闭文件</p><p><strong>注意：</strong> 对象析构时会自动关闭文件，但显式调用 <code>close()</code> 是良好习惯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fin.<span class="built_in">close</span>();   <span class="comment">// 关闭输入文件</span></span><br><span class="line">fout.<span class="built_in">close</span>();  <span class="comment">// 关闭输出文件</span></span><br></pre></td></tr></table></figure><h3 id="文件操作示例"><a href="#文件操作示例" class="headerlink" title="文件操作示例"></a>文件操作示例</h3><ol><li>写入文件（覆盖模式）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;  <span class="comment">// 打开文件（默认覆盖模式）</span></span><br><span class="line">    <span class="keyword">if</span> (!fout) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;年龄：20&quot;</span> &lt;&lt; endl;</span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;成绩：95.5&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    fout.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>读取文件（逐行读取）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;  <span class="comment">// 打开文件用于读取</span></span><br><span class="line">    <span class="keyword">if</span> (!fin) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(fin, line)) &#123;  <span class="comment">// 逐行读取</span></span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fin.<span class="built_in">close</span>();  <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>追加写入文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以追加模式打开文件（ios::app）</span></span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, ios:: | ios::app)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fout) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;无法打开文件！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; <span class="string">&quot;附加信息：优秀学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>二进制文件读写</li></ol><p>使用 <code>write()</code> 和 <code>read()</code> 方法操作二进制数据，需指定数据地址和长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写入二进制文件</span></span><br><span class="line">    Student s = &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">21</span>, <span class="number">89.5</span>&#125;;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;student.bin&quot;</span>, ios::binary)</span></span>;</span><br><span class="line">    fout.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;s), <span class="built_in">sizeof</span>(Student));</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取二进制文件</span></span><br><span class="line">    Student readStudent;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;student.bin&quot;</span>, ios::binary)</span></span>;</span><br><span class="line">    fin.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;readStudent), <span class="built_in">sizeof</span>(Student));</span><br><span class="line">    fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h1><p>在 <code>C</code> 语言中，如果想要将一个整形变量的数据转化为字符串格式，如何去做？</p><ol><li>使用 <code>itoa()</code> 函数</li><li>使用 <code>sprintf()</code> 函数</li></ol><p>但是两个函数在转化时，都得需要先给出保存结果的空间，那空间要给多大呢，就不太好界定，而且转化格式不匹配时，可能还会得到错误的结果甚至程序崩溃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">32</span>];</span><br><span class="line">_itoa(n, s1, <span class="number">10</span>);</span><br><span class="line"><span class="type">char</span> s2[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s2, <span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line"><span class="type">char</span> s3[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s3, <span class="string">&quot;%f&quot;</span>, n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>C++</code> 中，可以使用 <code>stringstream</code> 类对象来避开此问题</p><p>在程序中如果想要使用 <code>stringstream</code>，必须要包含头文件。在该头文件下，标准库三个类：<br><code>istringstream</code>、<code>ostringstream</code> 和 <code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作，本文主要介绍 <code>stringstream</code></p><p><code>stringstream</code> 主要可以用来：</p><ol><li>将数值类型数据格式化为字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">string sa;</span><br><span class="line"><span class="comment">// 将一个整形变量转化为字符串，存储到string类对象中</span></span><br><span class="line">stringstream s;</span><br><span class="line">s &lt;&lt; a;</span><br><span class="line">s &gt;&gt; sa;</span><br><span class="line"><span class="comment">// clear()</span></span><br><span class="line"><span class="comment">// 注意多次转换时，必须使用clear将上次转换状态清空掉</span></span><br><span class="line"><span class="comment">// stringstreams在转换结尾时(即最后一个转换后),会将其内部状态设置为badbit</span></span><br><span class="line"><span class="comment">// 因此下一次转换是必须调用clear()将状态重置为goodbit才可以转换</span></span><br><span class="line"><span class="comment">// 但是clear()不会将stringstreams底层字符串清空掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// s.str(&quot;&quot;);</span></span><br><span class="line"> <span class="comment">// 将stringstream底层管理string对象设置成&quot;&quot;, </span></span><br><span class="line"> <span class="comment">// 否则多次转换时，会将结果全部累积在底层string对象中</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">s.<span class="built_in">clear</span>();   <span class="comment">// 清空s, 不清空会转化失败</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line">s &lt;&lt; d;</span><br><span class="line">s &gt;&gt; sa;</span><br><span class="line">string sValue;</span><br><span class="line">sValue = s.<span class="built_in">str</span>();   <span class="comment">// str()方法：返回stringsteam中管理的string类型</span></span><br><span class="line">cout &lt;&lt; sValue &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串拼接</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stringstream sstream;</span><br><span class="line"><span class="comment">// 将多个字符串放入 sstream 中</span></span><br><span class="line">sstream &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;string,&quot;</span>;</span><br><span class="line">sstream &lt;&lt; <span class="string">&quot; second string&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 清空 sstream</span></span><br><span class="line">sstream.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">sstream &lt;&lt; <span class="string">&quot;third string&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After clear, strResult is: &quot;</span> &lt;&lt; sstream.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>序列化和反序列化结构数据</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ChatInfo</span></span><br><span class="line">&#123;</span><br><span class="line">string _name; <span class="comment">// 名字</span></span><br><span class="line"><span class="type">int</span> _id;      <span class="comment">// id</span></span><br><span class="line">Date _date;   <span class="comment">// 时间</span></span><br><span class="line">string _msg;  <span class="comment">// 聊天信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 结构信息序列化为字符串</span></span><br><span class="line">ChatInfo winfo = &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">135246</span>, &#123; <span class="number">2022</span>, <span class="number">4</span>, <span class="number">10</span> &#125;, <span class="string">&quot;晚上一起看电影吧&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">ostringstream oss;</span><br><span class="line">oss &lt;&lt; winfo._name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; winfo._id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; winfo._date &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">&lt;&lt; winfo._msg;</span><br><span class="line">string str = oss.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 我们通过网络这个字符串发送给对象，实际开发中，信息相对更复杂，</span></span><br><span class="line">   <span class="comment">// 一般会选用Json、xml等方式进行更好的支持</span></span><br><span class="line"><span class="comment">// 字符串解析成结构信息</span></span><br><span class="line">ChatInfo rInfo;</span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">iss &gt;&gt; rInfo._name &gt;&gt; rInfo._id &gt;&gt; rInfo._date &gt;&gt; rInfo._msg;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------------------------------------------&quot;</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; rInfo._name &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; rInfo._id &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">cout &lt;&lt; rInfo._date &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; rInfo._name &lt;&lt; <span class="string">&quot;:&gt;&quot;</span> &lt;&lt; rInfo._msg &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------------------------------------------------&quot;</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>4. <code>stringstream</code> 实际是在其底层维护了一个 <code>string</code> 类型的对象用来保存结果<br>5. 多次数据类型转化时，一定要用 <code>clear()</code> 来清空，才能正确转化，但 <code>clear()</code> 不会将 <code>stringstream</code> 底层的 <code>string</code> 对象清空<br>6. 可以使用 <code>s. str(&quot;&quot;)</code> 方法将底层 <code>string</code> 对象设置为””空字符串<br>7. 可以使用 <code>s.str()</code> 将让 <code>stringstream</code> 返回其底层的 <code>string</code> 对象<br>8. <code>stringstream</code> 使用 <code>string</code> 类对象代替字符数组，可以避免缓冲区溢出的危险，而且其会对参数类型进行推演，不需要格式化控制，也不会出现格式化失败的风险，因此使用更方便，更安全</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ad6d410476284551bdb712fbbc2de9f8.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++显性契约与隐性规则：类型转换</title>
      <link href="/2025/06/11/CPP%E8%BF%9B%E9%98%B6/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2025/06/11/CPP%E8%BF%9B%E9%98%B6/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>关于类型转换，通常是隐式转换或者强制转换，<code>C++</code> 提供了一些能够显式表示转换的运算符，能够更好的规避一些风险和错误</p><h1 id="传统的类型转换"><a href="#传统的类型转换" class="headerlink" title="传统的类型转换"></a>传统的类型转换</h1><p>在 <code>C</code> 语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line"><span class="type">double</span> d = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %.2f\n&quot;</span>, i, d);</span><br><span class="line"><span class="type">int</span>* p = &amp;i;</span><br><span class="line"><span class="comment">// 显示的强制类型转换</span></span><br><span class="line"><span class="type">int</span> address = (<span class="type">int</span>)p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x, %d\n&quot;</span>, p, address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转换分为显式和隐式：</strong></p><ol><li>隐式类型转化：编译器在编译阶段自动进行，能转就转，不能转就编译失败</li><li>显式类型转化：需要用户自己处理</li></ol><p><strong>然而这两种转换的前提是逻辑相近：</strong></p><ul><li>基本类型间的转换（如 <code>int</code> ↔ <code>double</code>）</li><li>继承层级中的转换（如子类→父类、父类→子类）</li><li>用户定义的转换（如 <code>operator T()</code> 或带参数的构造函数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; = (vector&lt;<span class="type">int</span>&gt;) s;</span><br></pre></td></tr></table></figure><p>这种转换就会失败，因为逻辑不相近</p><p>对于强制转换还有一种特殊易错的场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*) &amp;n;</span><br><span class="line">(*p)++;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; = (vector&lt;<span class="type">int</span>&gt;) s;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是有点 <code>C</code> 语言基础的人，甚至是学完 <code>C++</code> 的初学者，都很容易认为这里的输出结果是：<code>n</code> 为 <code>11</code>，<code>*p</code> 为 <code>11</code>。但是结果并非所愿，输出结果：<code>n</code> 为 <code>10</code>，<code>*p</code> 为 <code>11</code></p><p>实际上这里涉及到存储规则的问题，因为 <code>n</code> 是 <code>const</code> 变量，那么会被识别为一个常变量，可能会是一个经常被使用的值，就把 <code>n</code> 存入寄存器，把频繁使用的变量的值暂存到寄存器中，这样在后续对该变量的读取操作中，就不需要每次都去内存中读取，直接从寄存器中获取即可，因为寄存器的读写速度比内存快很多</p><p>通常 <code>cout</code> 输出的值都是在内存里读取的，相比寄存器，内存读写速度较慢，但内存容量相对寄存器大很多，大多的代码都是存在这里的</p><p>因此这里输出的 <code>n</code> 是取自内存器，<code>*p</code> 取自内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>volatile</code> 关键字表示该变量的值可能会在程序未明确指定的情况下被改变，编译器不会对其进行优化，即不会被存入寄存器，这样取到的 <code>n</code> 就是内存中及时更新的值</p><p><code>C</code> 风格的转换格式很简单，但是有不少缺点的： </p><ol><li>隐式类型转化有些情况下可能会出问题：比如数据精度丢失</li><li>显式类型转换将所有情况混合在一起，代码不够清晰</li></ol><p>因此 <code>C++</code> 提出了自己的类型转化风格，注意因为 <code>C++</code> 要兼容 <code>C</code> 语言，所以 <code>C++</code> 中还可以使用 <code>C</code> 语言的转化风格</p><h1 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C++强制类型转换"></a>C++强制类型转换</h1><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static_cast</code> 需要逻辑上的相近性</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 这里使用static_cast会报错，应该使用reinterpret_cast</span></span><br><span class="line"><span class="comment">//int *p = static_cast&lt;int*&gt;(a);</span></span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reinterpret_cast</code> 几乎无类型限制，不要求类型相近，可强制转换任意指针或整数类型，但极其危险，可能导致：</p><ul><li>违反别名规则（如通过 <code>char*</code> 修改 <code>int</code>）</li><li>函数指针转换后调用，引发崩溃</li><li>平台依赖（如不同架构的指针大小不同）</li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅改变类型的 <code>const</code> &#x2F; <code>volatile</code> 属性，这里用 <code>reinterpret_cast</code> 也不行的，因为 <code>const</code> 的转换是有风险的</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回</span></span><br><span class="line">B* pb1 = <span class="built_in">static_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">B* pb2 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pb1:&quot;</span> &lt;&lt; pb1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pb2:&quot;</span> &lt;&lt; pb2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">fun</span>(&amp;a);</span><br><span class="line"><span class="built_in">fun</span>(&amp;b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dynamic_cast</code> 用于将一个父类对象的指针&#x2F;引用转换为子类对象的指针或引用(动态转换)</p><ul><li><strong>向上转型：</strong> 子类对象指针&#x2F;引用-&gt;父类指针&#x2F;引用(不需要转换，赋值兼容规则)</li><li><strong>向下转型：</strong> 父类对象指针&#x2F;引用-&gt;子类指针&#x2F;引用(用 <code>dynamic_cast</code> 转型是安全的)</li></ul><p><code>pa</code> 是指向子类对象 <code>B</code> 的，转换可以成功，正常返回地址；<code>pa</code> 是指向父类对象 <code>A</code> 的，转换失败，返回空指针</p><p>🔥<strong>值得注意的是：</strong> 必须是继承关系中的类，基类必须包含虚函数</p><h1 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h1><p><strong>RTTI：</strong> <code>Run-time Type identification</code> 的简称，即：运行时类型识别</p><p><code>C++</code> 通过以下方式来支持 <code>RTTI</code>：</p><ol><li><code>typeid</code> 运算符</li><li><code>dynamic_cast</code> 运算符</li><li><code>decltype</code></li></ol><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e77f079cbe58423893f8e5b008dad937.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++设计的禁忌与救赎：特殊类设计</title>
      <link href="/2025/06/09/CPP%E8%BF%9B%E9%98%B6/%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/06/09/CPP%E8%BF%9B%E9%98%B6/%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>业务处理时常常会出现一些特定的要求，需要设计出特殊的功能，下面介绍几个常见的特殊类设计</p><h1 id="请设计一个类，不能被拷贝"><a href="#请设计一个类，不能被拷贝" class="headerlink" title="请设计一个类，不能被拷贝"></a>请设计一个类，不能被拷贝</h1><p>涉及拷贝的只有<code>拷贝构造</code>和<code>赋值重载</code>，把这些禁用了就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp;);</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp;);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <code>C++98</code>，直接设置为私有即可，这样类外就无法访问了，只声明不定义：不定义是因为该函数根本不会调用，定义了其实也没有什么意义，不写反而还简单，而且如果定义了就不会防止成员函数内部拷贝了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CopyBan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">CopyBan</span>(<span class="type">const</span> CopyBan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">CopyBan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CopyBan&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 <code>C++11</code>，直接在默认成员函数后跟上 <code>= delete</code>，表示让编译器删除掉该默认成员函数</p><h1 id="请设计一个类，只能在堆上创建对象"><a href="#请设计一个类，只能在堆上创建对象" class="headerlink" title="请设计一个类，只能在堆上创建对象"></a>请设计一个类，只能在堆上创建对象</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">CreateObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="comment">// 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要</span></span><br><span class="line">    <span class="comment">// 2.声明成私有</span></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11    </span></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建对象需要构造函数，所以首先把构造函数给禁用了，还注意应该禁止拷贝构造，防止再创建，因为类内能调用构造函数，所以创建一个 <code>public</code> 函数提供接口</p><p>在构造函数被私有化的情况下，静态方法是唯一能够访问私有构造函数并创建对象的途径，静态方法属于类本身，而非类的某个实例，因此无需创建对象即可调用，例如： <code>HeapOnly::CreateObject()</code> 可直接通过类名调用</p><h1 id="请设计一个类，只能在栈上创建对象"><a href="#请设计一个类，只能在栈上创建对象" class="headerlink" title="请设计一个类，只能在栈上创建对象"></a>请设计一个类，只能在栈上创建对象</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">CreateObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁掉operator new可以把下面用new 调用拷贝构造申请对象给禁掉</span></span><br><span class="line"> <span class="comment">// StackOnly obj = StackOnly::CreateObj();</span></span><br><span class="line"> <span class="comment">// StackOnly* ptr3 = new StackOnly(obj);</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>()</span><br><span class="line">:_a(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为堆上创建销毁需要通过 <code>new</code> 和 <code>delete</code>，之前又学过 <code>new -&gt; operator new + 构造函数</code>，<code>delete -&gt; operator delete + 析构函数</code>，所以直接将这些禁掉就好了</p><h1 id="请设计一个类，不能被继承"><a href="#请设计一个类，不能被继承" class="headerlink" title="请设计一个类，不能被继承"></a>请设计一个类，不能被继承</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonInherit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">NonInherit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">NonInherit</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>C++98</code> 中构造函数私有化，派生类中调不到基类的构造函数，则无法继承</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>final</code> 关键字，<code>final</code> 修饰类，表示该类不能被继承</p><h1 id="请设计一个类，只能创建一个对象-单例模式"><a href="#请设计一个类，只能创建一个对象-单例模式" class="headerlink" title="请设计一个类，只能创建一个对象(单例模式)"></a>请设计一个类，只能创建一个对象(单例模式)</h1><p><strong>单例模式：</strong></p><blockquote><p>一个类只能创建一个对象，即单例模式，该模式可以保证系统中该类只有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息，这种方式简化了在复杂环境下的配置管理</p></blockquote><p>以下是单例模式的两种实现模式：</p><p>🚩<strong>饿汉模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 构造函数私有</span></span><br><span class="line"><span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++98 防拷贝</span></span><br><span class="line"><span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="built_in">Singleton</span>(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(Singleton <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton Singleton::m_instance;  <span class="comment">// 在程序入口之前就完成单例对象的初始化</span></span><br></pre></td></tr></table></figure><p>静态变量属于类而非对象，程序运行期间仅存在一份实例，且在程序入口（<code>main()</code>）前初始化，<code>static Singleton m_instance;</code> 是声明，<code>Singleton Singleton::m_instance;</code> 是定义</p><p>饿汉模式在程序启动时（或类加载时）立即创建单例实例，若实例的初始化逻辑复杂（如：<br>读取大文件 &#x2F; 配置（如数据库连接、配置文件）<br>网络请求（初始化远程服务连接）<br>复杂计算（预加载数据字典、缓存构建）<br>这些操作会阻塞进程的启动流程，导致启动时间明显增加</p><p><strong>全局静态对象的初始化顺序问题：</strong></p><p>在 <code>C++</code> 中，多个全局静态对象的初始化顺序是未定义的（由编译器和链接器决定），若某个饿汉单例 <code>A</code> 依赖另一个全局对象 <code>B</code>，而 <code>B</code> 的初始化顺序在 <code>A</code> 之后，会导致 <code>A</code> 初始化时访问未初始化的 <code>B</code>，引发逻辑错误或崩溃</p><p>这类问题难以调试，且会间接增加启动阶段的异常处理开销</p><p>🚩<strong>懒汉模式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 2、提供获取单例对象的接口函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_psinst == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 第一次调用GetInstance的时候创建单例对象</span></span><br><span class="line">_psinst = <span class="keyword">new</span> Singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *_psinst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般单例不用释放。</span></span><br><span class="line"><span class="comment">// 特殊场景：1、中途需要显示释放  2、程序结束时，需要做一些特殊动作（如持久化）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DelInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_psinst)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _psinst;</span><br><span class="line">_psinst = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> pair&lt;string, string&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_dict[kv.first] = kv.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : _dict)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; e.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GC</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">GC</span>()</span><br><span class="line">&#123;</span><br><span class="line">lazy::Singleton::<span class="built_in">DelInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 1、构造函数私有</span></span><br><span class="line"><span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Singleton</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Singleton()&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map数据写到文件中</span></span><br><span class="line">FILE* fin = <span class="built_in">fopen</span>(<span class="string">&quot;map.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : _dict)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(e.first.<span class="built_in">c_str</span>(), fin);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;:&quot;</span>, fin);</span><br><span class="line"><span class="built_in">fputs</span>(e.second.<span class="built_in">c_str</span>(), fin);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, fin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、防拷贝</span></span><br><span class="line"><span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; s) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">map&lt;string, string&gt; _dict;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Singleton* _psinst;</span><br><span class="line"><span class="type">static</span> GC _gc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::_psinst = <span class="literal">nullptr</span>;</span><br><span class="line">Singleton::GC Singleton::_gc;</span><br></pre></td></tr></table></figure><p>在第一次使用时才初始化单例实例，而非程序启动时。这种方式避免了不必要的资源浪费，但需要处理多线程环境下的线程安全问题</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9d95e0abc2c146bbaf83d360210ebcbb.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 特殊类设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存列传之RAII宇宙：智能指针</title>
      <link href="/2025/06/04/CPP%E8%BF%9B%E9%98%B6/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2025/06/04/CPP%E8%BF%9B%E9%98%B6/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>智能指针是 <code>C++</code> 中用于自动管理动态内存的类模板，它通过 <code>RAII</code>（资源获取即初始化）技术避免手动 <code>new</code> &#x2F; <code>delete</code> 操作，从而显著减少内存泄漏和悬空指针的风险</p><h1 id="为什么需要智能指针？"><a href="#为什么需要智能指针？" class="headerlink" title="为什么需要智能指针？"></a>为什么需要智能指针？</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;除0错误&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">div</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>p1</code> 这里 <code>new</code> 抛异常会如何？</p><blockquote><p><code>p1</code> 未成功分配，值为 <code>nullptr</code><br>函数直接跳转到 <code>catch</code> 块，<code>p2</code> 未分配，无内存泄漏</p></blockquote><p>如果 <code>p2</code> 这里 <code>new</code> 抛异常会如何？</p><blockquote><p><code>p1</code> 已分配但未释放，导致内存泄漏<br>函数跳转到 <code>catch</code> 块，<code>p2</code> 未分配，<code>delete p1</code> 和 <code>delete p2</code> 均未执行</p></blockquote><p>如果 <code>div</code> 调用这里又会抛异常会如何？</p><blockquote><p><code>p1</code> 和 <code>p2</code> 均已分配但未释放，导致双重内存泄漏<br>函数跳转到 <code>catch</code> 块，打印错误信息（如 “除 <code>0</code> 错误”）</p></blockquote><p><code>C++</code> 不像 <code>java</code> 具有垃圾回收机制，能够自动回收开辟的空间，需要自行手动管理，但是自己管理有时又太麻烦了，况且这里只是两个指针就产生了这么多问题，因此在 <code>C++11</code> 就推出了智能指针用于自动管理内存</p><h1 id="智能指针原理"><a href="#智能指针原理" class="headerlink" title="智能指针原理"></a>智能指针原理</h1><h2 id="RAll"><a href="#RAll" class="headerlink" title="RAll"></a>RAll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SmartPtr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">: _ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SmartPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">SmartPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;string&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;xxx&quot;</span>))</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RAII</code>（<code>Resource Acquisition Is Initialization</code>）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术</p><p>简单来说，就是把创建的对象给到 <code>SmartPtr</code> 类来管理，当对象的生命周期结束的时候，刚好类也会自动调用析构函数进行内存释放</p><p><strong>这种做法有两大好处：</strong></p><ul><li>不需要显式地释放资源</li><li>采用这种方式，对象所需的资源在其生命期内始终保持有效</li></ul><h2 id="像指针一样使用"><a href="#像指针一样使用" class="headerlink" title="像指针一样使用"></a>像指针一样使用</h2><p>都叫做智能指针了，那肯定是可以当作指针一样使用了，指针可以解引用，也可<br>以通过 <code>-&gt;</code> 去访问所指空间中的内容，因此类中还得需要将 <code>*</code> 、<code>-&gt;</code> 重载下，才可让其像指针一样去使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SmartPtr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SmartPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>*</code> 重载返回对象，<code>-&gt;</code> 重载返回地址，这部分的知识点在迭代器底层分析已经讲过很多遍了，就不过多叙述了，可自行翻阅前文</p><h1 id="C-11的智能指针"><a href="#C-11的智能指针" class="headerlink" title="C++11的智能指针"></a>C++11的智能指针</h1><p>智能指针一般放在 <code>&lt;memery&gt;</code> 文件里，<code>C++11</code> 也参考了第三方库 <code>boost</code></p><ol><li><code>C++ 98</code> 中产生了第一个智能指针 <code>auto_ptr</code></li><li><code>C++ boost</code> 给出了更实用的 <code>scoped_ptr</code> 和 <code>shared_ptr</code> 和 <code>weak_ptr</code></li><li><code>C++ TR1</code>，引入了 <code>shared_ptr</code> 等。不过注意的是 <code>TR1</code> 并不是标准版</li><li><code>C++ 11</code>，引入了 <code>unique_ptr</code> 和 <code>shared_ptr</code> 和 <code>weak_ptr</code>。需要注意的是 <code>unique_ptr</code>对应 <code>boost</code> 的 <code>scoped_ptr</code>。并且这些智能指针的实现原理是参考 <code>boost</code> 中的实现的</li></ol><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// RAII</span></span><br><span class="line"><span class="comment">// 像指针一样</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">auto_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ap3(ap1)</span></span><br><span class="line"><span class="comment">// 管理权转移</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; ap)</span><br><span class="line">:_ptr(ap._ptr)</span><br><span class="line">&#123;</span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(auto_ptr&lt;T&gt;&amp; ap) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap) </span><br><span class="line">&#123;</span><br><span class="line">_ptr = ap._ptr;       <span class="comment">// 转移所有权</span></span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>;    <span class="comment">// 原指针置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>auto_ptr</code> 在 <code>C++98</code> 就已经被引入，实现了智能指针如上面所讲的最基础的功能，同时他还额外对拷贝构造、<code>=</code> 重载进行了显式调用，但是这种拷贝虽然能解决新对象的初始化，但是对于被拷贝的对象，造成了指针资源所有权被转移走，跟移动构造有些类似</p><p>因此，<code>auto_ptr</code> 会导致管理权转移，拷贝对象被悬空，<code>auto_ptr</code> 是一个失败设计，很多公司明确要求不能使用 <code>auto_ptr</code></p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// RAII</span></span><br><span class="line"><span class="comment">// 像指针一样</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ap3(ap1)</span></span><br><span class="line"><span class="comment">// 管理权转移</span></span><br><span class="line"><span class="comment">// 防拷贝</span></span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;T&gt;&amp; ap) = <span class="keyword">delete</span>;</span><br><span class="line">unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(unique_ptr&lt;T&gt;&amp; ap) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>unique_ptr</code> 很简单粗暴，直接禁止了拷贝机制</p><p>因此，建议在不需要拷贝的场景使用该智能指针</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// RAII</span></span><br><span class="line"><span class="comment">// 像指针一样</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">,_pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> &lt;&lt; _ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sp3(sp1)</span></span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">,_pcount(sp._pcount)</span><br><span class="line">&#123;</span><br><span class="line">++(*_pcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr == sp._ptr)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pcount = sp._pcount;</span><br><span class="line">++(*_pcount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *_pcount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">int</span>* _pcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>C++11</code> 中的智能指针就属 <code>shared_ptr</code> 使用的最多，因为它解决了赋值造成的资源被转移可能会被错误访问的问题</p><p>类中增加一个新的指针 <code>_pcount</code> 用于计数，即计数有多少个 <code>_ptr</code> 指向同一片空间，多个 <code>shared_ptr</code> 可以同时指向同一个对象，每次创建新的 <code>shared_ptr</code> 指向该对象，引用计数加  <code>1</code>；每次 <code>shared_ptr</code> 析构或者被赋值为指向其他对象，引用计数减  <code>1</code>。当最后一个指向该对象的 <code>shared_ptr</code> 析构时，对象会被自动删除，从而避免内存泄漏</p><p>🔥<strong>值得注意的是：</strong> <code>shared_ptr</code> 同时也支持了无法自己给自己赋值，这里还涉及一些关于线程安全的知识点，待 <code>Linux</code> 学习过后再来补充</p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>看似完美的 <code>shared_ptr</code> 其实也会有疏漏，比如：引用循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _data;</span><br><span class="line">shared_ptr&lt;ListNode&gt; _next;</span><br><span class="line">shared_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node1</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;ListNode&gt; <span class="title">node2</span><span class="params">(<span class="keyword">new</span> ListNode)</span></span>;</span><br><span class="line">cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">node1-&gt;_next = node2;</span><br><span class="line">node2-&gt;_prev = node1;</span><br><span class="line">cout &lt;&lt; node<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; node<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 <code>node1-&gt;next = node2</code> 和 <code>node2-&gt;prev = node1</code> 时，<code>node1</code> 内部的 <code>_next</code> 指针指向 <code>node2</code> ，<code>node2</code> 内部的 <code>_prev</code> 指针指向 <code>node1</code> 。这就导致两个节点之间形成了循环引用关系。此时，由于互相引用，每个节点的引用计数都变为 <code>2</code> ，因为除了外部的智能指针引用，还多了来自另一个节点内部指针的引用</p><p>当 <code>node1</code> 和 <code>node2</code> 智能指针对象离开作用域开始析构时，它们首先会将所指向节点的引用计数减 <code>1</code> 。此时，每个节点的引用计数变为 <code>1</code> ，而不是预期的 <code>0</code> 。这是因为 <code>node1</code> 的 <code>_next</code> 还指向 <code>node2</code> ，<code>node2</code> 的 <code>_prev</code> 还指向 <code>node1</code> ，使得它们的引用计数无法归零</p><p>对于 <code>shared_ptr</code> 来说，只有当引用计数变为 <code>0</code> 时才会释放所管理的资源。由于这种循环引用的存在，<code>node1</code> 等待 <code>node2</code> 先释放（因为 <code>node2</code> 的 <code>_prev</code> 引用着 <code>node1</code> ），而 <code>node2</code> 又等待 <code>node1</code> 先释放（因为 <code>node1</code> 的 <code>_next</code> 引用着 <code>node2</code> ），最终导致这两个节点所占用的资源都无法被释放，造成内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;ListNode&gt; _next; </span><br><span class="line">    weak_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了解决 <code>shared_ptr</code> 的循环引用问题，通常可以使用 <code>weak_ptr</code> 。<code>weak_ptr</code> 是一种弱引用智能指针，它不会增加所指向对象的引用计数。将循环引用中的某一个引用（比如 <code>ListNode</code> 类中的 <code>_prev</code> 或 <code>_next</code> 其中之一）改为 <code>weak_ptr</code> 类型，就可以打破循环引用</p><p>因此，<code>weak_ptr</code> 是一种专门解决循环引用问题的指针</p><h1 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数删除器：用于释放malloc分配的内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FreeFunc</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;FreeFunc: free memory at &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数删除器：用于释放数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArrayFunc</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DeleteArrayFunc: delete[] memory at &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用FreeFunc删除器的shared_ptr</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">((<span class="type">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>)), FreeFunc&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">    *sp1 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 离开作用域时调用FreeFunc删除器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用DeleteArrayFunc删除器的shared_ptr</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>], DeleteArrayFunc&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        sp<span class="number">2.</span><span class="built_in">get</span>()[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2 array:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">get</span>()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 离开作用域时调用DeleteArrayFunc删除器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda删除器管理A对象数组</span></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sp4</span><span class="params">(<span class="keyword">new</span> A[<span class="number">3</span>], [](A* p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;Lambda: deleting array at &quot;</span> &lt;&lt; p &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span>[] p;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp4 array of A objects created&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 离开作用域时调用lambda删除器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用lambda删除器管理文件句柄</span></span><br><span class="line">    <span class="function">shared_ptr&lt;FILE&gt; <span class="title">sp5</span><span class="params">(fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (p) </span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;Lambda: closing file&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        fclose(p);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sp5) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(sp<span class="number">5.</span><span class="built_in">get</span>(), <span class="string">&quot;Hello, shared_ptr with deleter!\n&quot;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;File written&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离开作用域时调用lambda删除器关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于所有的指针不一定是 <code>new</code> 出来的对象，因此利用仿函数设置了删除器，这样就可以调用对应的删除</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/80cd50ee8e924dec8fb61c93b1b809a6.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++日新月异的未来代码：C++11（下）</title>
      <link href="/2025/06/02/CPP%E8%BF%9B%E9%98%B6/C++11%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/06/02/CPP%E8%BF%9B%E9%98%B6/C++11%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接上篇，继续学习C++11的常用新特性</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><code>lambda</code> 表达式是一种匿名函数对象，允许在代码中直接定义和使用小型的函数，无需额外定义函数或函数对象类，这么讲，感觉还是太理论了，下面将通过特定场景介绍其使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Goods</span></span><br><span class="line">&#123;</span><br><span class="line">string _name;  <span class="comment">// 名字</span></span><br><span class="line"><span class="type">double</span> _price; <span class="comment">// 价格</span></span><br><span class="line"><span class="type">int</span> _evaluate; <span class="comment">// 评价</span></span><br><span class="line"><span class="built_in">Goods</span>(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">double</span> price, <span class="type">int</span> evaluate)</span><br><span class="line">:_name(str)</span><br><span class="line">, _price(price)</span><br><span class="line">, _evaluate(evaluate)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ComparePriceLess</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Goods&amp; gl, <span class="type">const</span> Goods&amp; gr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> gl._price &lt; gr._price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ComparePriceGreater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Goods&amp; gl, <span class="type">const</span> Goods&amp; gr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> gl._price &gt; gr._price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Goods&gt; v = &#123; &#123; <span class="string">&quot;苹果&quot;</span>, <span class="number">2.1</span>, <span class="number">5</span> &#125;, &#123; <span class="string">&quot;香蕉&quot;</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="string">&quot;橙子&quot;</span>, <span class="number">2.2</span>,</span><br><span class="line">   <span class="number">3</span> &#125;, &#123; <span class="string">&quot;菠萝&quot;</span>, <span class="number">1.5</span>, <span class="number">4</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ComparePriceLess</span>());</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ComparePriceGreater</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常生活中，一件商品包含多个特性，若想针对某个特性进行排序，那么就需要使用算法库里的 <code>sort</code>，设置自定义类型的比较方式，那么仿函数就是个很好的方式</p><p>随着 <code>C++</code> 语法的发展，人们开始觉得上面的写法太复杂了，每次为了实现一个 <code>algorithm</code> 算法，都要重新去写一个类，如果每次比较的逻辑不一样，还要去实现多个类，特别是相同类的命名，这些都给编程者带来了极大的不便。因此，在 <code>C++11</code> 语法中出现了 <code>lambda</code> 表达式</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong>lambda表达式书写格式：</strong></p><blockquote><p><code>[capture-list] (parameters) mutable -&gt; return-type &#123; statement &#125;</code></p></blockquote><p><strong>lambda表达式各部分说明：</strong></p><ul><li><p><code>[capture-list]</code> : 捕捉列表，该列表总是出现在 <code>lambda</code> 函数的开始位置，编译器根据 <code>[]</code> 来判断接下来的代码是否为 <code>lambda</code> 函数，捕捉列表能够捕捉上下文中的变量供 <code>lambda</code> 函数使用</p></li><li><p><code>(parameters)</code>：参数列表，与普通函数的参数列表一致，如果不需要参数传递，则可以连同 <code>()</code> 一起省略</p></li><li><p><code>mutable</code>：默认情况下，<code>lambda</code> 函数总是一个 <code>const</code> 函数，<code>mutable</code> 可以取消其常量性。使用该修饰符时，参数列表不可省略(即使参数为空)</p></li><li><p><code>-&gt;returntype</code>：返回值类型，用追踪返回类型形式声明函数的返回值类型，没有返回值时此部分可省略。返回值类型明确情况下，也可省略，由编译器对返回类型进行推导</p></li><li><p><code>&#123;statement&#125;</code>：函数体，在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量</p></li></ul><p>🔥<strong>值得注意的是：</strong> 在 <code>lambda</code> 函数定义中，<code>参数列表</code>和<code>返回值类型</code>都是<code>可选忽略</code>部分，而<code>捕捉列表</code>和<code>函数体</code>可以为<code>空</code>。因此 <code>C++11</code> 中最简单的 <code>lambda</code> 函数为：<code>[]&#123;&#125;;</code> 该<code>lambda</code> 函数不能做任何事情</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Goods&gt; v = &#123; &#123; <span class="string">&quot;苹果&quot;</span>, <span class="number">2.1</span>, <span class="number">5</span> &#125;, &#123; <span class="string">&quot;香蕉&quot;</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="string">&quot;橙子&quot;</span>, <span class="number">2.2</span>,</span><br><span class="line">   <span class="number">3</span> &#125;, &#123; <span class="string">&quot;菠萝&quot;</span>, <span class="number">1.5</span>, <span class="number">4</span> &#125; &#125;;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> g<span class="number">1.</span>_price &lt; g<span class="number">2.</span>_price; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> g<span class="number">1.</span>_price &gt; g<span class="number">2.</span>_price; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> g<span class="number">1.</span>_evaluate &lt; g<span class="number">2.</span>_evaluate; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> Goods&amp; g1, <span class="type">const</span> Goods&amp; g2)-&gt;<span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> g<span class="number">1.</span>_evaluate &gt; g<span class="number">2.</span>_evaluate; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>lambda</code> 表达式可以这样套用在 <code>sort</code> 里，比仿函数确实方便且可观性更高了，可以看出 <code>lambda</code> 表达式实际是一个匿名函数（无名函数），该函数无法直接调用，如果想要直接调用，可借助 <code>auto</code> 将其赋值给一个变量</p><blockquote><p><code>auto ret</code> &#x3D; [ ](<code>const Goods&amp; g1</code>, <code>const Goods&amp; g2</code>) {<code>return g1._evaluate</code> &lt; <code>g2._evaluate</code>; }</p></blockquote><p>对于捕捉列表 <code>[]</code>，平常一般使用的不多，但是某些情况还是要使用的，需要了解其用法</p><p><strong>捕捉列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值还是传引用：</strong></p><ul><li><code>[x]</code>：表示<code>值传递</code>方式捕捉变量 <code>x</code></li><li><code>[=]</code>：表示<code>值传递</code>方式捕获所有父作用域中的变量(包括 <code>this</code> )</li><li><code>[&amp;x]</code>：表示<code>引用传递</code>捕捉变量 <code>x</code></li><li><code>[&amp;]</code>：表示<code>引用传递</code>捕捉所有父作用域中的变量(包括 <code>this</code> )</li><li><code>[this]</code>：表示<code>值传递</code>方式捕捉当前的 <code>this</code> 指针</li></ul><p>🔥<strong>值得注意的是：</strong> </p><ol><li>父作用域指包含 <code>lambda</code> 函数的语句块</li><li><code>lambda</code> 默认以值传递的方式进行，传值捕捉的变量是不可修改的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() <span class="keyword">mutable</span> &#123; x = <span class="number">20</span>; cout &lt;&lt; x &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>mutable</code> 关键字就可以修改了，但是这种修改只是对 <code>lambda</code> 内部的副本进行修改，不会影响到原始的变量。在 <code>main</code> 函数中再次输出 <code>x</code> 时，其值仍为 <code>10</code></p><ol start="3"><li>语法上捕捉列表可由多个捕捉项组成，并以逗号分割，比如：<code>[=, &amp;a, &amp;b]</code>，以引用传递的方式捕捉变量 <code>a</code> 和 <code>b</code>，值传递方式捕捉其他所有变量；<code>[&amp;，a, this]</code>，值传递方式捕捉变量 <code>a</code> 和 <code>this</code>，引用方式捕捉其他变量</li><li>捕捉列表不允许变量重复传递，否则就会导致编译错误</li><li>在块作用域以外的 <code>lambda</code> 函数捕捉列表必须为空，在全局作用域中，并没有局部变量可供 <code>lambda</code> 函数捕获</li><li>在块作用域中的 <code>lambda</code> 函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或者非局部变量都会导致编译报错</li><li><code>lambda</code> 表达式之间不能相互赋值，即使看起来类型相同，但是可以拷贝构造（每个 <code>lambda</code> 表达式都有其独特的、未命名的类型。即使两个 <code>lambda</code> 表达式的参数列表和返回类型相同，它们的类型也是不同的）</li></ol><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/886fa9b5c1ea475692b22ac59f8c060a.png" alt="在这里插入图片描述"></p><p>转到反汇编可以发现，其实 <code>lambda</code> 的本质就是被包装的仿函数，编译器会自动生成一个类，在该类中重载了 <code>operator()</code></p><h1 id="类的新增语法"><a href="#类的新增语法" class="headerlink" title="类的新增语法"></a>类的新增语法</h1><h2 id="移动构造、移动赋值运算符"><a href="#移动构造、移动赋值运算符" class="headerlink" title="移动构造、移动赋值运算符"></a>移动构造、移动赋值运算符</h2><p><code>C++11</code> 新增了两个：<code>移动构造</code>函数和<code>移动赋值运算符</code>重载，在上一篇有进行详细的说明</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/148193946?spm=1001.2014.3001.5502">C++日新月异的未来代码：C++11（上）</a></p></blockquote><ul><li><p>如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个。那么编译器会自动生成一个默认移动构造。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造，如果实现了就调用移动构造，没有实现就调用拷贝构造</p></li><li><p>如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造完全类似)</p></li><li><p>如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值</p></li></ul><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>)</span><br><span class="line">:_name(name)</span><br><span class="line">, _age(age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">:_name(p._name)</span><br><span class="line">, _age(p._age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(Person &amp;&amp; p) = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">bit::string _name;</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person s1;</span><br><span class="line">Person s2 = s1;</span><br><span class="line">Person s3 = std::<span class="built_in">move</span>(s1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>default</code> 是强制生成默认函数的关键字，我们提供了拷贝构造，就不会生成移动构造了，那么我们可以使用 <code>default</code> 关键字显示指定移动构造生成</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>)</span><br><span class="line">:_name(name)</span><br><span class="line">, _age(age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">bit::string _name;</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person s1;</span><br><span class="line">Person s2 = s1;</span><br><span class="line">Person s3 = std::<span class="built_in">move</span>(s1);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delete</code> 是禁止生成默认函数的关键字，当类显式删除了拷贝构造函数时，编译器不会自动生成移动构造函数（即使没有显式删除移动构造函数），代码中没有显式定义移动构造函数，且隐式移动构造函数被禁用，因此无法完成移动初始化</p><p>🔥<strong>值得注意的是：</strong> </p><p>移动构造函数的核心目的是高效转移资源所有权（如动态内存、文件句柄等），而拷贝构造函数的目的是创建资源的独立副本。如果一个类禁用了拷贝构造函数，通常意味着：</p><ul><li><strong>资源不可复制：</strong> 例如独占式资源，拷贝会导致资源管理混乱</li><li><strong>防止意外拷贝：</strong> 开发者希望禁止对象的复制操作，强制使用移动语义</li></ul><p>此时，如果编译器仍然自动生成移动构造函数，可能会破坏这种设计意图</p><h1 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0b22dbd02a1c4698a4aaf37584b63a41.png" alt="在这里插入图片描述"></p><p>其实可变模板参数早在C语言就已经有了，后面三个点点点就是可变模板参数，比如： <code>printf(&quot;%d,%d,%d&quot;, x, y, z)</code>，后面的参数个数是可以自己控制有多少个的，这就是一种可变模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShowList</span>();</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到实际定义，<code>Args</code> 是一个模板参数包，<code>args</code> 是一个函数形参参数包，声明一个参数包<code>Args... args</code>，这个参数包中可以包含 <code>0</code> 到任意个模板参数</p><h2 id="3-2-获取个数"><a href="#3-2-获取个数" class="headerlink" title="3.2 获取个数"></a>3.2 获取个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShowList</span>();</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个用法也是很奇葩。。。</p><h2 id="展开参数包"><a href="#展开参数包" class="headerlink" title="展开参数包"></a>展开参数包</h2><p>不知道当初设计怎么想的，这里想要 <code>for</code> 循环遍历展开是不可行的，编译器不支持，所以这里的展开方法做了解即可</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归终止函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(T value, Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">ShowList</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="built_in">string</span>(<span class="string">&quot;sort&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模式匹配：</strong> 展开函数 <code>ShowList(T value, Args... args)</code> 匹配 至少一个参数 的情况，每次取出第一个参数 <code>value</code>，剩余参数构成新的参数包 <code>args...</code> ，终止函数 <code>ShowList(const T&amp; t)</code> 匹配仅有一个参数 的情况，结束递归</p><p><strong>参数包展开：</strong> <code>args...</code> 在递归调用时会被解包，每次减少一个参数，直到参数包为空，<br>关键语句 <code>ShowList(args...)</code> 会触发模板的递归实例化，直到匹配终止函数</p><p><strong>输出顺序：</strong> 先打印当前参数 <code>value</code>，再递归处理剩余参数，确保参数按传入顺序输出</p><h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArg</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; (<span class="built_in">PrintArg</span>(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="built_in">string</span>(<span class="string">&quot;sort&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>(PrintArg(args), 0)...</code> 会将参数包 <code>args...</code> 展开为多个表达式，打印对应的值，然后返回 <code>0</code>（用于填充数组）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123; (<span class="built_in">PrintArg</span>(args), <span class="number">0</span>)... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开后等价于</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123; (<span class="built_in">PrintArg</span>(<span class="number">1</span>), <span class="number">0</span>), (<span class="built_in">PrintArg</span>(<span class="string">&#x27;A&#x27;</span>), <span class="number">0</span>), (<span class="built_in">PrintArg</span>(<span class="string">&quot;sort&quot;</span>), <span class="number">0</span>) &#125;;</span><br></pre></td></tr></table></figure><p><code>PrintArg</code> 的返回值是 <code>void</code>，无法初始化 <code>int</code> 数组，即使 <code>PrintArg</code> 返回参数类型（如  <code>T</code>），参数包可能包含不同类型（如 <code>int</code>, <code>char</code>），仍会导致类型不匹配</p><p>每个元素必须是 <code>int</code> 类型，因此需要用 <code>0</code> 作为统一的返回值，保证初始化的数组元素都为相同类型</p><h2 id="emplace系列的接口"><a href="#emplace系列的接口" class="headerlink" title="emplace系列的接口"></a>emplace系列的接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt; pair&lt;<span class="type">int</span>, <span class="type">char</span>&gt; &gt; mylist;</span><br><span class="line">mylist.<span class="built_in">emplace_back</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">mylist.<span class="built_in">emplace_back</span>(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">mylist.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line"></span><br><span class="line">mylist.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">40</span>, <span class="string">&#x27;d&#x27;</span>));</span><br><span class="line">mylist.<span class="built_in">push_back</span>(&#123; <span class="number">50</span>, <span class="string">&#x27;e&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : mylist)</span><br><span class="line">cout &lt;&lt; e.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; e.second &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emplace_back</code> 的作用和 <code>push_back</code> 相同，但是 <code>mylist.emplace_back(20, &#39;b&#39;)</code> 这种格式的写法更方便一些</p><p>其实我们会发现其实差别也不大，<code>emplace_back</code> 是直接构造了，<code>push_back</code> 是先构造，再移动构造，移动构造的消耗很小，其实没啥影响</p><h2 id="可变参数模板的实际应用"><a href="#可变参数模板的实际应用" class="headerlink" title="可变参数模板的实际应用"></a>可变参数模板的实际应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Date构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)</span><br><span class="line">:_year(d._year)</span><br><span class="line">, _month(d._month)</span><br><span class="line">, _day(d._day)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Date拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Args&gt;</span><br><span class="line"><span class="function">Date* <span class="title">Create</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date* ret = <span class="keyword">new</span> <span class="built_in">Date</span>(args...);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;Date&gt; lt;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2023</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="comment">// 只能传日期类对象</span></span><br><span class="line">lt.<span class="built_in">push_back</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 既能传日期类对象</span></span><br><span class="line"><span class="comment">// 又能传日期类对象的参数包</span></span><br><span class="line"><span class="comment">// 参数包，一路往下传，直接去构造或者拷贝构造节点中日期类对象</span></span><br><span class="line">lt.<span class="built_in">emplace_back</span>(d);</span><br><span class="line">lt.<span class="built_in">emplace_back</span>(<span class="number">2023</span>, <span class="number">9</span>, <span class="number">27</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push_back</code> 只能传日期类对象，<code>emplace_back</code> 既能传日期类对象，又能传日期类对象的参数包。参数包，一路往下传，直接去构造或者拷贝构造节点中日期类对象</p><h1 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h1><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">useF</span><span class="params">(F f, T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; ++count &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> d / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数名</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(f, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(<span class="built_in">Functor</span>(), <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// lamber表达式</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>([](<span class="type">double</span> d)-&gt;<span class="type">double</span> &#123; <span class="keyword">return</span> d / <span class="number">4</span>; &#125;, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道函数指针，仿函数，lambda表达式，这三种都是函数对象的创建方式，同时调用这三个方式实例化模板，useF函数模板实例化了三份，明明都是相同的内容，实在是没有必要，会导致模板的效率低下</p><p>那么这种时候就需要使用头文件 <code>&lt;functional&gt;</code> 中的 <code>function</code>，<code>function</code> 包装器也叫作适配器。C++中的 <code>function</code> 本质是一个类模板，也是一个包装器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类模板原型如下</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; function;     <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ret</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">function</span>&lt;<span class="built_in">Ret</span>(Args...)&gt;;</span><br></pre></td></tr></table></figure><p>模板参数说明：</p><ul><li><code>Ret</code> : 被调用函数的返回类型</li><li><code>Args…</code>：被调用函数的形参</li></ul><p>下面直接修改以上代码，来展示 <code>function</code> 的使用效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">useF</span><span class="params">(F f, T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; ++count &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> d / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数名</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; func1 = f;</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(func1, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; func2 = <span class="built_in">Functor</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(func2, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// lamber表达式</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; func3 = [](<span class="type">double</span> d)-&gt;<span class="type">double</span> &#123; <span class="keyword">return</span> d / <span class="number">4</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(func3, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种可调用对象被统一为同一类型：包装类，模板只实例化一次，静态变量共享（即这个 <code>count</code> 只有一份），</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code> 函数定义在头文件中，是一个函数模板，它就像一个函数包装器(适配器)，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p><code>bind</code> 可以理解为一个接收包装类的适配器，上面的例子都是直接将函数给到包装类，那么 <code>bind</code> 就是将特定的函数和参数绑定到包装类，通过例子解析会更容易理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//表示绑定函数plus 参数分别由调用 func1 的第一，二个参数指定</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func1 = std::<span class="built_in">bind</span>(Plus, placeholders::_1,</span><br><span class="line">placeholders::_2);</span><br><span class="line"><span class="comment">//auto func1 = std::bind(Plus, placeholders::_1, placeholders::_2);</span></span><br><span class="line"><span class="comment">//func2的类型为 function&lt;void(int, int, int)&gt; 与func1类型一样</span></span><br><span class="line"><span class="comment">//表示绑定函数 plus 的第一，二为： 1， 2</span></span><br><span class="line"><span class="keyword">auto</span>  func2 = std::<span class="built_in">bind</span>(Plus, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func1</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func2</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Sub s;</span><br><span class="line"><span class="comment">// 绑定成员函数</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func3 = std::<span class="built_in">bind</span>(&amp;Sub::sub, s,</span><br><span class="line">placeholders::_1, placeholders::_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数调换顺序</span></span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func4 = std::<span class="built_in">bind</span>(&amp;Sub::sub, s,</span><br><span class="line">placeholders::_2, placeholders::_1);</span><br><span class="line">cout &lt;&lt; <span class="built_in">func3</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func4</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bind</code> 的第一个参数传的是函数，后面的是一系列要传的参数，<code>_1</code> 为第一个参数，<code>_2</code> 为第二个参数，以此类推，参数既可以是待定的，也可以是具体的值，<code>placeholders</code> 属于 <code>std</code> 命名空间，若展开了就不用写</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ff94fae0a60d4d4f8a8e4dca270719cc.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><ul><li><p>若函数是非静态成员函数，必须在 <code>Sub::sub</code> 前加上 <code>&amp;</code>，因为非静态成员函数依赖对象，必须显式调用其地址，普通函数指针直接指向代码地址，而成员函数指针需要同时包含类的类型信息和函数地址，因此还需要将对象 <code>s</code> 传过去</p></li><li><p>若函数是静态成员函数，和普通函数一样都是全局函数，就不需要加 <code>&amp;</code> 和传对象</p></li></ul><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ce7eaa8815b24dea93c93ff7fa040250.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> lambda </tag>
            
            <tag> 包装类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++日新月异的未来代码：C++11（上）</title>
      <link href="/2025/05/28/CPP%E8%BF%9B%E9%98%B6/C++11%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/05/28/CPP%E8%BF%9B%E9%98%B6/C++11%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.cppreference.com/w/cpp/11">C++11</a> 能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习</p><h1 id="统一的列表初始化"><a href="#统一的列表初始化" class="headerlink" title="统一的列表初始化"></a>统一的列表初始化</h1><h2 id="普通-初始化"><a href="#普通-初始化" class="headerlink" title="普通{ }初始化"></a>普通{ }初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> array1[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> array2[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Point p = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>C++98</code> 中，标准允许使用花括号{}对数组或者结构体元素进行统一的列表初始值设定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _x;</span><br><span class="line"><span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x2&#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="type">int</span> array1[]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> array2[<span class="number">5</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">Point p&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// C++11中列表初始化也可以适用于new表达式中</span></span><br><span class="line"><span class="type">int</span>* pa = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>] &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>C++11</code> 扩大了用大括号括起的列表(初始化列表)的使用范围，使其可用于所有的内置类型和用户自定义的类型，使用初始化列表时，可添加等号 <code>=</code>，也可不添加</p><p>简单来说，<code>C++11</code> 一切皆可用 <code>&#123;&#125;</code> 初始化，并且可以不写 <code>=</code>，建议日常定义，不要去掉 <code>=</code>，但是我们要能看懂</p><p>🔥<strong>值得注意的是：</strong> 像 <code>Point p1 = &#123; 1, 1 &#125;</code> ，是一种多参数隐式转化，无论哪一种初始化方式都是要调用对应的构造函数的</p><h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><p><a href="https://legacy.cplusplus.com/reference/initializer_list/initializer_list/?kw=initializer_list">initializer_list</a> 是 <code>C++11</code> 引入的一个轻量级容器，用于支持统一的初始化语法和参数列表初始化。它允许函数或类接收任意数量的同类型参数，并提供简洁的初始化方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;; <span class="comment">// 调用 vector 的 initializer_list 构造函数</span></span><br></pre></td></tr></table></figure><p><code>stl</code> 中的容器基本都是支持 <code>initializer_list</code> 初始化的，这初始化的方式和上面的隐式类型不同，具体方式如下：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f7f5fada9a8d452384e4bddb14d52d65.png" alt="在这里插入图片描述"></p><p>首先要知道 <code>initializer_list</code> 主要有这三个成员</p><ol><li>创建一个临时数组（存储在栈上），包含元素 <code>&#123;1, 2, 3&#125;</code></li><li>生成一个 <code>initializer_list&lt;int&gt;</code> 对象，该对象引用临时数组（内部保存数组的起始地址和长度）</li><li><code>initializer_list</code> 引用临时数组（不拥有其内存），<code>vector</code> 会将临时数组的内容复制元素到自己的内存空间（堆上），与临时数组无关</li><li>临时数组被销毁</li></ol><p>🔥<strong>值得注意的是：</strong> <code>vector</code> 是复制引用数组的元素，而不是直接接收，是因为该临时数组销毁之后，如果 <code>vector</code> 还接收着的话会造成悬空引用</p><p>因此 <code>initializer_list</code> 的存在还是很有必要的：</p><p>在 <code>C++11</code> 之前，若想让函数接收一个类似 <code>&#123;1, 2, 3&#125;</code> 的初始化列表作为参数，需要通过数组或容器（如 <code>vector</code>）传递，不够直观。<code>initializer_list</code> 允许函数直接以初始化列表为参数，使代码更符合直觉</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><h2 id="auto、nullptr"><a href="#auto、nullptr" class="headerlink" title="auto、nullptr"></a>auto、nullptr</h2><p>该 <code>C++</code> 增加的特性在前面的文章进行过详细讲解，不过多叙述</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/144131104">C++命运石之门代码抉择：C++入门（下）</a></p></blockquote><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype的一些使用使用场景</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(T1 t1, T2 t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">decltype</span>(t1 * t2) ret;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(ret).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">2.2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x * y) ret; <span class="comment">// ret的类型是double</span></span><br><span class="line"><span class="keyword">decltype</span>(&amp;x) p;      <span class="comment">// p的类型是int*</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(ret).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">F</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeid().name()</code> 是一种读取类型的方式，但是无法使用，<code>decltype</code> 和 <code>auto</code> 类似，可以自动推导类型，<code>auto</code> 只能推导，<code>decltype</code> 可以推导并使用</p><h1 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>传统的 <code>C++</code> 语法中就有引用的语法，而 <code>C++11</code> 中新增了的右值引用语法特性，所以从现在开始我们之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名</p><p>🚩<strong>什么是左值？什么是左值引用？</strong></p><blockquote><p>左值是一个表示数据的表达式(如变量名或解引用的指针)，我们可以获取它的地址，一般可以对它赋值，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。定义时 <code>const</code> 修饰符后的左值，不能给他赋值，但是可以取它的地址。左值引用就是给左值的引用，给左值取别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 以下的p、b、c、*p都是左值，字符串也算一种左值</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 以下几个是对上面左值的左值引用</span></span><br><span class="line"><span class="type">int</span>*&amp; rp = p;</span><br><span class="line"><span class="type">int</span>&amp; rb = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rc = c;</span><br><span class="line"><span class="type">int</span>&amp; pvalue = *p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是能够<code>取地址</code>的就是<code>左值</code>，左值大多数能赋值（除 <code>const</code> 左值），为左值取别名的变量就是 <code>左值引用</code></p><p>🚩<strong>什么是右值？什么是右值引用？</strong></p><blockquote><p>右值也是一个表示数据的表达式，如：字面常量、表达式返回值，函数返回值(这个不能是左值引用返回)等等，右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，右值不能取地址。右值引用就是对右值的引用，给右值取别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> x = <span class="number">1.1</span>, y = <span class="number">2.2</span>;</span><br><span class="line"><span class="comment">// 以下几个都是常见的右值</span></span><br><span class="line"><span class="number">10</span>;</span><br><span class="line">x + y;</span><br><span class="line"><span class="built_in">fmin</span>(x, y);</span><br><span class="line"><span class="comment">// 以下几个都是对右值的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr2 = x + y;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr3 = <span class="built_in">fmin</span>(x, y);</span><br><span class="line"><span class="comment">// 这里编译会报错：error C2106: “=”: 左操作数必须为左值</span></span><br><span class="line"><span class="number">10</span> = <span class="number">1</span>;</span><br><span class="line">x + y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">fmin</span>(x, y) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，不能取地址的，就是右值，右值不能做左操作数，为右值取别名的变量就是 <code>右值引用</code></p><p>🔥<strong>值得注意的是：</strong> 右值引用之后，是可以对引用变量取地址修改的，不想修改的话加 <code>const</code> 即可</p><h2 id="左值引用与右值引用比较"><a href="#左值引用与右值引用比较" class="headerlink" title="左值引用与右值引用比较"></a>左值引用与右值引用比较</h2><p>🚩<strong>左值引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 左值引用只能引用左值，不能引用右值。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ra1 = a;   <span class="comment">// ra为a的别名</span></span><br><span class="line"><span class="comment">//int&amp; ra2 = 10;   // 编译失败，因为10是右值</span></span><br><span class="line"><span class="comment">// const左值引用既可引用左值，也可引用右值。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra4 = a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>左值引用只能引用左值，不能引用右值</li><li>但是 <code>const</code> 左值引用既可引用左值，也可引用右值</li></ol><p>因为两者的生命周期不同，会造成悬空。假设允许 <code>int&amp; ra2 = 10</code>，<code>10</code> 是右值，无固定内存地址，生命周期短暂。若 <code>ra2</code> 绑定到 <code>10</code>，当表达式结束后，<code>10</code> 被销毁，<code>ra2</code> 将悬空。而 <code>const int&amp;</code> 通过延长右值生命周期，创建一个临时对象存储右值，并将引用绑定到该临时对象，避免了此问题</p><p>🚩<strong>右值引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 右值引用只能右值，不能引用左值。</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error C2440: “初始化”: 无法从“int”转换为“int &amp;&amp;”</span></span><br><span class="line"><span class="comment">// message : 无法将左值绑定到右值引用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; r2 = a;</span><br><span class="line"><span class="comment">// 右值引用可以引用move以后的左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>右值引用只能右值，不能引用左值</li><li>但是右值引用可以 <code>move</code> 以后的左值</li></ol><p>右值引用是个临时存储的对象，如果引用左值的话，原本左值中正在使用的值会因为右值引用的销毁而受影响，但是可以使用 <code>move</code> 转成右值，下面会对 <code>move</code> 进行解析</p><h2 id="左值引用与右值引用的应用"><a href="#左值引用与右值引用的应用" class="headerlink" title="左值引用与右值引用的应用"></a>左值引用与右值引用的应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> string a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string ret = <span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们学习过引用返回，是一种左值引用，将变量的地址返回回去，但是这种方式的局限性巨大，大部分情况下返回的是一个局部变量，那么就不能用左值引用返回了，这里只能使用传值返回，传值返回会导致至少 <code>1</code> 次拷贝构造(如果是一些旧一点的编译器可能是两次拷贝构造)</p><p><strong>那么右值引用和移动语义解决上述问题：</strong></p><p>首先介绍一个概念</p><ul><li><strong>普通类型的右值：</strong> 纯右值</li><li><strong>自定义类型的右值：</strong> 将亡值</li></ul><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ada0bf6f9c474b14b7fe17dfe245b699.png" alt="在这里插入图片描述"></p><p>早期编译器还没有优化的时候返回的 <code>str</code> 先传递给临时变量，这个过程是拷贝构造，是一次深拷贝，由于此时的临时变量是右值，所以可以使用移动构造，下面将详细介绍移动构造的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s)</span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string(const string&amp; s) -- 深拷贝&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function">string <span class="title">tmp</span><span class="params">(s._str)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动构造</span></span><br><span class="line"><span class="built_in">string</span>(string&amp;&amp; s)</span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string(string&amp;&amp; s) -- 移动拷贝&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图为移动构造的大概框架</p><ol><li><p><strong>参数传递：</strong> 移动构造函数接收一个右值引用参数 <code>string&amp;&amp; s</code></p></li><li><p><strong>资源转移：</strong> 举个例子，省略号处可能执行 <code>data = s.data</code> 和 <code>size = s.size</code> 的操作，看起来好像是转移了资源，其实不是的，只是把原来对象的指针和属性转移给了新对象，并没有拷贝原来对象的主要数据，简单来说就是资源所有权的转移</p></li><li><p><strong>原对象资源清理：</strong> 将原对象的data指针置为 <code>nullptr</code>，<code>size</code> 置为 <code>0</code>，这样当原对象在析构时（即出了局部作用域时），由于资源所有权被转移给新对象，所以这部分资源不会给释放</p></li></ol><p>通过这样的方式，移动构造函数实现了资源的高效转移，避免了像拷贝构造函数那样对资源进行复制，提高了对象创建和资源管理的效率</p><hr><p>通过不断的编译器优化，如今已经可以只使用一次移动构造就能解决了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a621ddd5e0ad421488bc41f5f61755f5.png" alt="在这里插入图片描述"></p><p>两个步骤直接合二为一，编译器通过特殊处理，将本来是左值的 <code>str</code> 返回值，识别成将亡值，直接使用移动构造转移资源</p><p><strong>不仅仅有移动构造，还有移动赋值：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/186c3f5b799f48d281c81d7bf779f3fb.png" alt="在这里插入图片描述"></p><p><strong>移动构造：</strong> <code>func</code> 函数中创建了 <code>string</code> 对象 <code>str</code> ，当 <code>return str</code> 时，会调用移动构造函数。因为 <code>str</code> 是函数内局部对象，返回时将其资源以移动方式构造一个临时对象用于返回值。这避免了对字符串内容的深拷贝，直接转移资源所有权，提升效率 </p><p><strong>移动赋值：</strong> 在 <code>main</code> 函数中，先创建了 <code>string</code> 对象 <code>ret2</code> ，然后 <code>ret2 = func();</code> ，这里<code>func()</code> 返回一个临时对象，此操作会调用 <code>string</code> 类的移动赋值运算符。它将 <code>func</code> 函数返回的临时对象的资源（如内部存储字符串的指针等相关资源）转移给 <code>ret2</code> ，而不是进行字符串内容的复制，同样是为了提高效率</p><p>🔥<strong>值得注意的是：</strong> 移动构造函数是用于创建一个新对象，并从另一个对象（通常是临时对象）那里获取资源所有权；而移动赋值是用于将一个已存在对象的资源所有权转移给另一个已存在的对象。简单来说，移动构造函数是在对象创建时起作用，而移动赋值是在对象已经存在之后进行资源转移时起作用</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(move(s1))</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了右值引用相关的移动构造，那么 <code>move</code> 就好解释多了，<code>move</code> 简单理解就是把资源完全复制到一个右值新对象，对原来的对象并没有修改</p><p><code>s2</code> 这里 <code>s1</code> 是左值，调用的是拷贝构造，这里我们把 <code>s1</code> <code>move</code>处理以后，会被当成右值，调用移动构造，但是这里要注意，一般是不要这样用的，因为我们会发现 <code>s1</code> 的资源被转移给了 <code>s3</code>，<code>s1</code> 被置空了</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Fun</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// 右值</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">PerfectForward</span>(a);            <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// 右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">PerfectForward</span>(b);      <span class="comment">// const 左值</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const 右值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板中的 <code>&amp;&amp;</code> 不代表右值引用，而是万能引用，其既能接收左值又能接收右值，模板的万能引用只是提供了能够接收同时接收左值引用和右值引用的能力</p><p><strong>T&amp;&amp; 的推导规则：</strong></p><ul><li><p>当传入左值（如变量 <code>a</code>）时，<code>T</code> 被推导为左值引用类型（如 <code>int&amp;</code>），此时 <code>T&amp;&amp;</code> 折叠为 <code>int&amp;</code>（即左值引用），也叫引用折叠</p></li><li><p>当传入右值（如 <code>10</code> 或 <code>move(a)</code>）时，<code>T</code> 被推导为非引用类型（如 <code>int</code>），此时 <code>T&amp;&amp;</code> 成为 <code>int&amp;&amp;</code>（即右值引用）</p></li></ul><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/354dbc05782b45f186af3da8f299f538.png" alt="在这里插入图片描述"></p><p>但运行之后发现全都是左值，并没有按照传入实参的类型调用</p><p><strong>关键点：</strong> 变量名本身永远是左值，无论这个变量是左值引用还是右值引用类型</p><p><strong>为什么 t 是左值？</strong></p><blockquote><p><code>T&amp;&amp;</code> 无论被推导成什么，都是根据 <code>t</code> 这个实参的传入进行调整的，我们知道右值是不可以被修改的，所以这里理应是个左值，而且 <code>C++</code> 标准明确规定：变量名（无论其类型是左值引用还是右值引用）都是左值表达式</p></blockquote><p>因此，<code>Fun(t)</code> 中的 <code>t</code> 始终被视为左值，调用 <code>Fun(int&amp;)</code> 或 <code>Fun(const int&amp;)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="comment">// std::forward&lt;T&gt;(t)在传参的过程中保持了t的原生类型属性。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Fun</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// 右值</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">PerfectForward</span>(a);            <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// 右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">PerfectForward</span>(b);      <span class="comment">// const 左值</span></span><br><span class="line">![请添加图片描述](https:<span class="comment">//i-blog.csdnimg.cn/direct/5331a7028bb842c8987b625c5cc4c15e.png)</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const 右值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此保持参数的原始值类别（左值或右值）就要用到 <code>forward</code></p><ul><li>如果原始参数是左值，<code>T</code> 会被推导为左值引用（如 <code>int&amp;</code>），<code>forward&lt;int&amp;&gt;(t)</code> 返回左值引用</li><li>如果原始参数是右值，<code>T</code> 会被推导为非引用类型（如 <code>int</code>），<code>forward&lt;int&gt;(t)</code> 返回右值引用（<code>int&amp;&amp;</code>）</li></ul><p>这样，<code>t</code> 的原始值类别（左值 &#x2F; 右值）就被正确传递给 <code>Fun</code> 函数</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8e96cf65884a4c7bbccb35cc1dcf3f94.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++寻位映射的究极密码：哈希扩展</title>
      <link href="/2025/05/26/CPP%E8%BF%9B%E9%98%B6/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95/"/>
      <url>/2025/05/26/CPP%E8%BF%9B%E9%98%B6/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>位图和布隆过滤器是基于哈希的一种常见应用，通常用来处理大体量数据，提升查找数据的效率</p><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>给40亿个不重复的无符号整数，没排过序。给一个无符号整数，<strong>如何快速判断一个数是否在这40亿个数中?</strong></p><p>放在哈希表中去寻找？不，这并不现实，因为哈希表的存储也是需要空间消耗的，况且是 <code>40</code> 亿个数据，如此庞大的数据计算机一般是很难存储</p><p>因此就诞生了位图的概念，位图简单来说就是把每个数按照哈希函数的计算，存储到每个比特位上。数据是否在给定的整形数据中，结果是在或者不在，刚好是两种状态，那么可以使用一个二进制比特位来代表数据是否存在的信息，如果二进制比特位为 <code>1</code>，代表存在，为 <code>0</code> 代表不存在</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/395fec634dcb4edbacaec25f189589ad.png" alt="在这里插入图片描述"></p><h2 id="位图的结构"><a href="#位图的结构" class="headerlink" title="位图的结构"></a>位图的结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">bitset</span>()</span><br><span class="line">&#123;</span><br><span class="line">_a.<span class="built_in">resize</span>(N / <span class="number">32</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; _a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>开辟一个 <code>vector</code> 数组 <code>_a</code>，这里我们以 <code>int</code> 作为位图的基本单位，那么就是把每个数据存储到 <code>int</code> 的比特位上</p><p>🔥<strong>值得注意的是：</strong> <code>resize</code> 的时候无论如何都要加 <code>1</code>，比如 <code>100</code> 个数据，除以 <code>32</code>，等于 <code>3</code>，余 <code>4</code>，那么就需要多一个 <code>int</code> 空间来存储，不能说每次都卡好刚好 <code>32</code> 整除</p><h2 id="位图映射的比特位标记成1"><a href="#位图映射的比特位标记成1" class="headerlink" title="位图映射的比特位标记成1"></a>位图映射的比特位标记成1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x映射的那个标记成1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> i = x / <span class="number">32</span>;</span><br><span class="line"><span class="type">size_t</span> j = x % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">_a[i] |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i</code> 用于确定在第几个 <code>int</code> 里，<code>j</code> 用于确定在第几个 <code>int</code> 的第几位上</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a7f777c3c85746219bae89507ed646a1.png" alt="在这里插入图片描述"></p><p>二进制位从右到左是最低位到最高位，所以左移即可</p><h2 id="位图映射的比特位标记成0"><a href="#位图映射的比特位标记成0" class="headerlink" title="位图映射的比特位标记成0"></a>位图映射的比特位标记成0</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x映射的那个标记成0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> i = x / <span class="number">32</span>;</span><br><span class="line"><span class="type">size_t</span> j = x % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">_a[i] &amp;= (~(<span class="number">1</span> &lt;&lt; j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，因为按位与是有 <code>0</code> 就是 <code>0</code>，直接计算即可</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bb33ae75e3c947bfa16f553f61744dab.png" alt="在这里插入图片描述"></p><h2 id="位图映射判断为1-or-0"><a href="#位图映射判断为1-or-0" class="headerlink" title="位图映射判断为1 or 0"></a>位图映射判断为1 or 0</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> i = x / <span class="number">32</span>;</span><br><span class="line"><span class="type">size_t</span> j = x % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _a[i] &amp; (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里是 <code>&amp;</code>，而不是 <code>&amp;=</code>，因为只需要判断，而不是修改</p><p>位图通常不支持删除功能，因为没有必要删除</p><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/557968fe3960420491df57c4898dc315.png" alt="在这里插入图片描述"></p><p>我们在存储字符串数据时，是通过计算这个字符串的ASC||码值之和，然后通过哈希函数计算存入的，但是这可能会产生哈希冲突，但是数据量太大了，无法通过常规的方法解决</p><p>那么最简单的方法就是降低误判率，通过多个不同哈希函数计算，将一个值映射多个位置，这样不至于每次查找都会产生冲突</p><ol><li>用哈希表存储用户记录，缺点：浪费空间</li><li>用位图存储用户记录，缺点：位图一般只能处理整形，如果内容编号是字符串，就无法处理了</li><li>将哈希与位图结合，即布隆过滤器</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2560b1740d674aed8fa1155e8190641d.png" alt="在这里插入图片描述"></p><p><strong>再举个现实点的例子，就能理解布隆过滤器存在的必要：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83296ed5021e460ea6cd375b49354de8.png" alt="在这里插入图片描述"></p><p>比如我们在注册账号昵称时，会显示是否已经被取过，先在布隆过滤器中进行查找，<code>若不在</code>，那么成功注册；<code>如果在</code>，那么就到数据库中查询，这样能减少数据库查询次数，降低负载压力，提升整体查询效率</p><h2 id="布隆过滤器的结构"><a href="#布隆过滤器的结构" class="headerlink" title="布隆过滤器的结构"></a>布隆过滤器的结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">K</span> = string,</span><br><span class="line">    <span class="keyword">class</span> Hash1 = BKDRHash,</span><br><span class="line">    <span class="keyword">class</span> Hash2 = APHash,</span><br><span class="line">    <span class="keyword">class</span> Hash3 = DJBHash&gt;</span><br><span class="line"><span class="keyword">class</span> BloomFilter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    bitset&lt;N&gt; _bs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Hash1</code>、<code>Hash2</code>、<code>Hash3</code> 是用于计算 <code>string</code> 存储的哈希函数，<code>stl</code> 库里是有 <code>bitset</code> 使用的，直接开辟位图空间即可</p><blockquote><p>传送门：<a href="https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html">字符串Hash函数对比</a></p></blockquote><h2 id="布隆过滤器的哈希函数"><a href="#布隆过滤器的哈希函数" class="headerlink" title="布隆过滤器的哈希函数"></a>布隆过滤器的哈希函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BKDRHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            hash = hash * <span class="number">131</span> + ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt;&quot;BKDRHash:&quot; &lt;&lt; hash &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">APHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> ch = str[i];</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hash ^= ((hash &lt;&lt; <span class="number">7</span>) ^ ch ^ (hash &gt;&gt; <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hash ^= (~((hash &lt;&lt; <span class="number">11</span>) ^ ch ^ (hash &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;APHash:&quot; &lt;&lt; hash &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DJBHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> hash = <span class="number">5381</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            hash += (hash &lt;&lt; <span class="number">5</span>) + ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;DJBHash:&quot; &lt;&lt; hash &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>选取了三种计算冲突较小的哈希函数算法进行计算，因为需要多处使用，以仿函数的形式更加方便快捷</p><h2 id="布隆过滤器的插入"><a href="#布隆过滤器的插入" class="headerlink" title="布隆过滤器的插入"></a>布隆过滤器的插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(key) % N;</span><br><span class="line">    _bs.<span class="built_in">set</span>(hash1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(key) % N;</span><br><span class="line">    _bs.<span class="built_in">set</span>(hash2);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(key) % N;</span><br><span class="line">    _bs.<span class="built_in">set</span>(hash3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cout &lt;&lt; hash1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">     cout &lt;&lt; hash2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">     cout &lt;&lt; hash3 &lt;&lt; endl &lt;&lt; endl;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是以仿函数的方式进行，<code>Hash1()</code> 是匿名对象，有了对象才能以函数的形式调用参数</p><h2 id="布隆过滤器映射判断为true-or-false"><a href="#布隆过滤器映射判断为true-or-false" class="headerlink" title="布隆过滤器映射判断为true or false"></a>布隆过滤器映射判断为true or false</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Test</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> hash1 = <span class="built_in">Hash1</span>()(key) % N;</span><br><span class="line">    <span class="keyword">if</span> (_bs.<span class="built_in">test</span>(hash1) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> hash2 = <span class="built_in">Hash2</span>()(key) % N;</span><br><span class="line">    <span class="keyword">if</span> (_bs.<span class="built_in">test</span>(hash2) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> hash3 = <span class="built_in">Hash3</span>()(key) % N;</span><br><span class="line">    <span class="keyword">if</span> (_bs.<span class="built_in">test</span>(hash3) == <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><p>🚩<strong>优点：</strong></p><ol><li>增加和查询元素的时间复杂度为: <code>O(K)</code>, ( <code>K</code> 为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并行运算</li><li>布隆过滤器不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>在能够承受一定的误判时，布隆过滤器比其他数据结构有这很大的空间优势</li><li>数据量很大时，布隆过滤器可以表示全集，其他数据结构不能</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ol><p>🚩<strong>缺点：</strong></p><ol><li>有误判率，即存在假阳性(<code>False Position</code>)，即不能准确判断元素是否在集合中(补救方法：再建立一个白名单，存储可能会误判的数据)</li><li>不能获取元素本身</li><li>一般情况下不能从布隆过滤器中删除元素</li><li>如果采用计数方式删除，可能会存在计数回绕问题</li></ol><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="哈希切割"><a href="#哈希切割" class="headerlink" title="哈希切割"></a>哈希切割</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>给一个超过 <code>100G</code> 大小的 <code>log file</code>，<code>log</code> 中存着 <code>IP</code> 地址, 设计算法找到出现次数最多的 <code>IP</code> 地址？</p><p>🛜<strong>解决方法：</strong></p><p>对于超过 <code>100G</code> 的日志文件，直接加载到内存是不可行的，既然大的不行，就把文件分割为小文件一个个进行</p><p>使用哈希函数计算将 <code>IP</code> 映射到不同的小文件中，确保相同 <code>IP</code> 进入同一个文件，对每个小文件，使用哈希表统计 <code>IP</code> 频率，合并所有小文件的统计结果，就能找出出现次数最多的 <code>IP</code></p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>与上题条件相同，如何找到 <code>top K</code> 的 <code>IP</code> ？</p><p>🛜<strong>解决方法：</strong></p><p>既然相同 <code>IP</code> 一定进入同一个小文件，用 <code>map</code> 去统计每个文件中 <code>IP</code> 出现的次数即可</p><h2 id="位图应用"><a href="#位图应用" class="headerlink" title="位图应用"></a>位图应用</h2><h3 id="问题一-1"><a href="#问题一-1" class="headerlink" title="问题一"></a>问题一</h3><p>给定 <code>100</code> 亿个整数，设计算法找到只出现一次的整数？</p><p>🛜<strong>解决方法：</strong></p><p>对于 <code>100</code> 亿个整数（约 <code>40GB</code> 数据），直接加载到内存显然不可行。我们可以使用 <code>位图</code> 和 <code>哈希分治</code> 相结合的方法高效解决这个问题——<code>双位图法</code></p><p><img src="https://i-blog.csdnimg.cn/direct/46b9ccde77224e5e959fffd73ef7bb16.png" alt="在这里插入图片描述"><br>使用两个位图，每个整数对应两位：</p><ul><li><code>00</code>：整数未出现</li><li><code>01</code>：整数出现 <code>1</code> 次</li><li><code>10</code>：整数出现 <code>2</code> 次及以上</li></ul><p>假设计算出第一个数据映射第一个位置，且第一次出现，则上面的位图第一位设置为 <code>0</code>，下面位图的第一位设置为 <code>1</code>。其他情况依次类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">twobitset</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 00 -&gt; 01</span></span><br><span class="line"><span class="keyword">if</span> (!_bs<span class="number">1.</span><span class="built_in">test</span>(x) &amp;&amp; !_bs<span class="number">2.</span><span class="built_in">test</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">_bs<span class="number">2.</span><span class="built_in">set</span>(x);</span><br><span class="line">&#125; <span class="comment">// 01 -&gt; 10</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!_bs<span class="number">1.</span><span class="built_in">test</span>(x) &amp;&amp; _bs<span class="number">2.</span><span class="built_in">test</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">_bs<span class="number">1.</span><span class="built_in">set</span>(x);</span><br><span class="line">_bs<span class="number">2.</span><span class="built_in">reset</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本身10代表出现2次及以上，就不变了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_once</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !_bs<span class="number">1.</span><span class="built_in">test</span>(x) &amp;&amp; _bs<span class="number">2.</span><span class="built_in">test</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">bitset&lt;N&gt; _bs1;</span><br><span class="line">bitset&lt;N&gt; _bs2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后遍历位图对每一位进行 <code>is_once</code> 函数的判断，符合一次的存入哈希表即可</p><h3 id="问题二-1"><a href="#问题二-1" class="headerlink" title="问题二"></a>问题二</h3><p>给两个文件，分别有 <code>100</code> 亿个整数，我们只有 <code>1G</code> 内存，如何找到两个文件交集？</p><p>🛜<strong>解决方法：</strong> </p><p>还是利用两个位图的方式解决，一个文件映射一个位图，对应的位置 <code>&amp;</code> 按位与一下，两个位置都为 <code>1</code>，则这个位置是交集，注意存储的值应该放在 <code>set</code> 里去重</p><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p><code>1</code> 个文件有 <code>100</code> 亿个 <code>int</code>，<code>1G</code> 内存，设计算法找到出现次数不超过 <code>2</code> 次的所有整数</p><p>🛜<strong>解决方法：</strong> </p><p>和问题一的方法是一样的，只不过改一下表示方法而已</p><ul><li><code>00</code>：整数未出现</li><li><code>01</code>：整数出现 <code>1</code> 次</li><li><code>10</code>：整数出现 <code>2</code> 次</li><li><code>11</code>：整数出现 <code>3</code> 次及以上</li></ul><h2 id="布隆过滤器应用"><a href="#布隆过滤器应用" class="headerlink" title="布隆过滤器应用"></a>布隆过滤器应用</h2><h3 id="问题一-2"><a href="#问题一-2" class="headerlink" title="问题一"></a>问题一</h3><p>给两个文件，分别有 <code>100</code>亿个 <code>query</code>，我们只有 <code>1G</code> 内存，如何找到两个文件交集？分别给出精确算法和近似算法</p><p>🛜<strong>解决方法：</strong> </p><p><strong>近似算法：</strong></p><p>用文件 <code>A</code> 的所有 <code>query</code> 构建布隆过滤器，遍历文件 <code>B</code> 的每个 <code>query</code>，判断是否可能在 <code>A</code> 中，对布隆过滤器返回 “可能存在” 的 <code>query</code>，再在文件 <code>A</code> 中精确验证，但是这种方法并不百分百准确，可能存在误判</p><p><strong>精确算法：</strong></p><p><img src="https://i-blog.csdnimg.cn/direct/2eac9dea54dd4a7a8e29a375bebf6e2b.png" alt="在这里插入图片描述"></p><p>将 <code>A</code>、<code>B</code> 文件都分割为同样数量的小文件，都上好编号，因为经过相同哈希函数计算，所以 <code>A</code> 和 <code>B</code> 中相同的 <code>query</code> 必定分别进入 <code>Ai</code> 和 <code>Bi</code> 文件中，因此 <code>A0</code> 和 <code>B0</code> 比较，<code>A1</code> 和 <code>B1</code> 进行比较，以此类推即可</p><p><img src="https://i-blog.csdnimg.cn/direct/e658858eb2924a15a9cc47c65eaf490b.png" alt="在这里插入图片描述"></p><h3 id="问题二-2"><a href="#问题二-2" class="headerlink" title="问题二"></a>问题二</h3><p>如何扩展 <code>BloomFilter</code> 使得它支持删除元素的操作?</p><p>🛜<strong>解决方法：</strong> </p><p>将标准布隆过滤器的每个二进制位扩展为一个小计数器（通常 <code>4-8</code> 位），当插入元素时增加计数器，删除时减少计数器。只有当计数器为 <code>0</code> 时，才表示该位置未被占用</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8c697c8f7d52431b93f6f738ac7850f1.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> 位图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：unordered_map &amp;&amp; unordered_set底层剖析</title>
      <link href="/2025/05/22/CPP%E8%BF%9B%E9%98%B6/unordered_map%20&amp;&amp;%20unordered_set%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
      <url>/2025/05/22/CPP%E8%BF%9B%E9%98%B6/unordered_map%20&amp;&amp;%20unordered_set%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>看了前面的底层封装后，其实封装的过程及方法都大差不差，<code>unordered_map</code> &amp;&amp; <code>unordered_set</code> 也是如此，所以本篇就简单提及一些细节，具体最详细的一些部分可以去看前面的文章</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/146324257?spm=1011.2415.3001.5331">C++效率掌握之STL库：list底层剖析及迭代器万字详解</a></p></blockquote><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/147807037?spm=1011.2415.3001.5331">C++效率掌握之STL库：map &amp;&amp; set底层剖析及迭代器万字详解</a></p></blockquote><h1 id="unordered-map、unordered-set的基本结构"><a href="#unordered-map、unordered-set的基本结构" class="headerlink" title="unordered_map、unordered_set的基本结构"></a>unordered_map、unordered_set的基本结构</h1><p>🚩<strong>unordered_set：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> hash_bucket::HashTable&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> hash_bucket::HashTable&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;const_iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;<span class="keyword">typename</span> hash_bucket::HashTable&lt;K, K, SetKeyOfT&gt;::iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">Insert</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;const_iterator, <span class="type">bool</span>&gt;(ret.first, ret.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">hash_bucket::HashTable&lt;K, K, SetKeyOfT&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🚩<strong>unordered_map：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unordered_map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">const</span> K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> kv.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> hash_bucket::HashTable&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> hash_bucket::HashTable&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">Insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">hash_bucket::HashTable&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; _ht;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>unordered_set</code> 虽然事 <code>k-k</code> 类型，<code>unordered_map</code> 是 <code>k-v</code> 类型，但是实际上这两个类共用一个哈希表，准确来说是共用同一个模板类型，<code>unordered_set</code> 是 <code>&lt;K，K&gt;</code>，<code>unordered_map</code> 是 <code>&lt;K，pair&lt;K，V&gt;&gt;</code></p><h1 id="普通迭代器"><a href="#普通迭代器" class="headerlink" title="普通迭代器"></a>普通迭代器</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HTIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> HTIterator&lt;K, T, Ptr, Ref, KeyOfT, HashFunc&gt; Self;</span><br><span class="line"><span class="keyword">typedef</span> HTIterator&lt;K, T, T*, T&amp;, KeyOfT, HashFunc&gt; Iterator;</span><br><span class="line"></span><br><span class="line">Node* _node;</span><br><span class="line"><span class="type">const</span> HashTable&lt;K, T, KeyOfT, HashFunc&gt;* _pht;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTIterator(Node* node, HashTable&lt;K, T, KeyOfT, HashFunc&gt;* pht)</span></span><br><span class="line"><span class="comment">:_node(node)</span></span><br><span class="line"><span class="comment">,_pht(pht)</span></span><br><span class="line"><span class="comment">&#123;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HTIterator</span>(Node* node, <span class="type">const</span> HashTable&lt;K, T, KeyOfT, HashFunc&gt;* pht)</span><br><span class="line">:_node(node)</span><br><span class="line">, _pht(pht)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通迭代器时，他是拷贝构造</span></span><br><span class="line"><span class="comment">// const迭代器时，他是构造</span></span><br><span class="line"><span class="built_in">HTIterator</span>(<span class="type">const</span> Iterator&amp; it)</span><br><span class="line">:_node(it._node)</span><br><span class="line">, _pht(it._pht)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当前桶还没完</span></span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KeyOfT kot;</span><br><span class="line">HashFunc hf;</span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(<span class="built_in">kot</span>(_node-&gt;_data)) % _pht-&gt;_table.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 从下一个位置查找查找下一个不为空的桶</span></span><br><span class="line">++hashi;</span><br><span class="line"><span class="keyword">while</span> (hashi &lt; _pht-&gt;_table.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_pht-&gt;_table[hashi])</span><br><span class="line">&#123;</span><br><span class="line">_node = _pht-&gt;_table[hashi];</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">++hashi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == s._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>typedef HTIterator&lt;K, T, T*, T&amp;, KeyOfT, HashFunc&gt; Iterator</code> 和构造函数是为 <code>Insert</code> 操作准备的，因为涉及到普通迭代器创建 <code>const</code> 迭代器</p><p>🔥<strong>值得注意的是：</strong> 有人说不是可以通过权限转化吗？但是权限转化是只有涉及引用和指针的类型时才会生效，而这里是模板参数之间的转化</p><h1 id="const迭代器"><a href="#const迭代器" class="headerlink" title="const迭代器"></a>const迭代器</h1><p><code>unordered_set</code> 本身无论是 <code>const</code> 迭代器还是普通迭代器都会被 <code>typedef</code> 为 <code>const_iterator</code></p><p>对于 <code>unordered_map</code> 来说，<code>key</code> 是不允许改变的，<code>value</code> 是可以改变的，但是如果像 <code>set</code> 那样写的话 <code>key</code> 和 <code>value</code> 都不能修改了，所以直接在 <code>pair</code> 的 <code>key</code> 加 <code>const</code> ，控制 <code>value</code> 即可</p><h1 id="insert返回值-operator"><a href="#insert返回值-operator" class="headerlink" title="insert返回值  operator[]"></a>insert返回值  operator[]</h1><p>🚩<strong>unordered_set：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;const_iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//return _ht.Insert(key);</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> hash_bucket::HashTable&lt;K, K, SetKeyOfT&gt;::iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">Insert</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;const_iterator, <span class="type">bool</span>&gt;(ret.first, ret.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>unordered_map：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ht.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = _ht.<span class="built_in">Insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的转化尤为复杂，一定要看之前文章的详细解析</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/01d5976f19634eed8e3383ec1527ebad.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> 哈希 </tag>
            
            <tag> unordered_map </tag>
            
            <tag> unordered_set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++寻位映射的奇幻密码：哈希</title>
      <link href="/2025/05/19/CPP%E8%BF%9B%E9%98%B6/%E5%93%88%E5%B8%8C/"/>
      <url>/2025/05/19/CPP%E8%BF%9B%E9%98%B6/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<p>哈希，用于将任意大小的数据映射为固定长度的数值（哈希值），这个过程通过哈希函数实现，其核心目标是高效地存储、查找和验证数据</p><h1 id="什么是哈希？"><a href="#什么是哈希？" class="headerlink" title="什么是哈希？"></a>什么是哈希？</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6ead7402f98f478ebbdb1acbe5002e1a.png" alt="在这里插入图片描述"></p><p>在学哈希之前，我们对于数据的查找通常是建立于顺序表，树形结构的基础上进行的查找，但是随着数据量越来越庞大，数据的随机性和容量越发严峻</p><p><strong>理想的搜索方法：</strong> 可以不经过任何比较，一次直接从表中得到要搜索的元素<br>如果构造一种存储结构，通过某种函数( <code>hashFunc</code> )使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素</p><p>因此就在此基础上发展出了一种平均时间复杂度几乎为 <code>O(1)</code> 的数据查找方式，<code>哈希</code>，也称为散列</p><h1 id="哈希的常见实现方法"><a href="#哈希的常见实现方法" class="headerlink" title="哈希的常见实现方法"></a>哈希的常见实现方法</h1><h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/edc91f7a49ee4605993682699739b204.png" alt="在这里插入图片描述"></p><p>对于一段相对集中的数据段，就可以使用直接定址法，这里最大的数是 <code>30</code>，最小的数是<code>15</code>，创建一个大小为 <code>15</code> 的数组，将所有值映射到数组上</p><p><strong>优点：</strong> 简单、均匀<br><strong>缺点：</strong> 需要事先知道关键字的分布情况<br><strong>使用场景：</strong> 适合查找比较小且连续的情况，数据太分散就不适合了，开的数组会太大，造成空间浪费</p><h2 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3ef6fbde8da84669b53cb02e0884aa42.png" alt="在这里插入图片描述"></p><p>除留余数法是一种通过固定的哈希函数计算方式将数据放入哈希表的常用方法，设散列表中允许的地址数为 <code>m</code>，取一个不大于 <code>m</code>，但最接近或者等于 <code>m</code> 的质数 <code>p</code> 作为除数，按照哈希函数：<code>Hash(key) = key% p(p&lt;=m)</code>,将关键码转换成哈希地址</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><p>简单来说，通过除留余数法，将每个进来的值除以哈希表的大小得到的余数，必定是在所开哈希表的容器大小范围内的，但是有可能不同的 <code>key</code> 会除出相同的余数，造成同一位置的冲突，该种现象称为<code>哈希冲突</code>或<code>哈希碰撞</code></p><h1 id="哈希冲突的解决"><a href="#哈希冲突的解决" class="headerlink" title="哈希冲突的解决"></a>哈希冲突的解决</h1><h2 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h2><p>也叫<code>开放定址法</code>，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有<br>空位置，那么可以把 <code>key</code> 存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？</p><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>下面将通过对借助哈希表的实现解析线性探测相关的知识：</p><h4 id="哈希表的基本数据结构"><a href="#哈希表的基本数据结构" class="headerlink" title="哈希表的基本数据结构"></a>哈希表的基本数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">STATE</span></span><br><span class="line">&#123;</span><br><span class="line">EXIST,</span><br><span class="line">EMPTY,</span><br><span class="line">DELETE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashData</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line">STATE _state = EMPTY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span> = DefaultHashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line"><span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">_table.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;HashData&lt;K, V&gt;&gt; _table;</span><br><span class="line"><span class="type">size_t</span> _n = <span class="number">0</span>; <span class="comment">// 存储有效数据的个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置 <code>_kv</code> 存储实际的键值对数据，<code>_state</code> 跟踪该位置的状态</p><ul><li><code>EXIST</code> 表示位置已被占用（存在有效元素）</li><li><code>EMPTY</code> 表示位置为空（从未被使用）</li><li><code>DELETE</code> 表示位置已删除（曾被占用，现已删除）</li></ul><p><strong>为什么要用状态来表示呢？</strong></p><blockquote><p>因为用状态表示是最清晰直接的，有人说用零来表示已经删除的值不就好了，但是万一本身存储的值就是零呢？总而言之用状态表示是最方便的</p></blockquote><h4 id="哈希表的key转换"><a href="#哈希表的key转换" class="headerlink" title="哈希表的key转换"></a>哈希表的key转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DefaultHashFunc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">size_t</span>)key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DefaultHashFunc</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// BKDR</span></span><br><span class="line"><span class="type">size_t</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ch : str)</span><br><span class="line">&#123;</span><br><span class="line">hash *= <span class="number">131</span>;</span><br><span class="line">hash += ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除留余数法一般是对整数进行操作，但是我们并不能保证 <code>key</code> 一定是整数，有人说直接强转不就好了，但是你能保证强转的数据一定是对的吗？可能是 <code>double</code>，也有可能是<code>string</code>，因此最好的方法是利用我们之前常用的仿函数进行统一操作</p><p>整数小数等就走默认的 <code>DefaultHashFunc</code> 类，当 <code>key</code> 是 <code>string</code> 类型的时候，就走特化的版本 <code>DefaultHashFunc&lt;string&gt;</code>，这里特化是为了统一性，不然你再造一个仿函数就太麻烦了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span> = DefaultHashFunc&lt;K&gt;&gt;</span><br></pre></td></tr></table></figure><p>将仿函数设为默认类型，这样子在创建例如 <code>HashTable&lt;string, string&gt; dict</code> 的哈希表的时候就不用显式写仿函数的类型</p><p>🔥<strong>值得注意的是：</strong> 这里的 <code>string</code> 特化版本的仿函数，进行了一些 <code>BKDR</code> 数学上的处理，假设有 <code>&quot;abc&quot;</code>，<code>&quot;bca&quot;</code> 两个字符串，这两个字符串其实是不一样的数据，如果没有进行 <code>hash *= 131</code> 的数据处理，那么这两个字符串的加和就是一样的，那么使用除留余数法的时候就会发生哈希冲突</p><p>具体分析可以看博客园里的大佬的分析：</p><blockquote><p>传送门：<a href="https://www.cnblogs.com/-clq/archive/2012/05/31/2528153.html">字符串Hash函数对比</a></p></blockquote><h4 id="哈希表的插入"><a href="#哈希表的插入" class="headerlink" title="哈希表的插入"></a>哈希表的插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="comment">//if ((double)_n / (double)_table.size() &gt;= 0.7)</span></span><br><span class="line"><span class="keyword">if</span> (_n * <span class="number">10</span> / _table.<span class="built_in">size</span>() &gt;= <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newSize = _table.<span class="built_in">size</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 遍历旧表，重新映射到新表</span></span><br><span class="line">HashTable&lt;K, V, HashFunc&gt; newHT;</span><br><span class="line">newHT._table.<span class="built_in">resize</span>(newSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历旧表的数据插入到新表即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_table[i]._state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line">newHT.<span class="built_in">Insert</span>(_table[i]._kv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_table.<span class="built_in">swap</span>(newHT._table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性探测</span></span><br><span class="line">HashFunc hf;</span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(kv.first) % _table.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (_table[hashi]._state == EXIST)</span><br><span class="line">&#123;</span><br><span class="line">++hashi;</span><br><span class="line">hashi %= _table.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_table[hashi]._kv = kv;</span><br><span class="line">_table[hashi]._state = EXIST;</span><br><span class="line">++_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的插入，解决哈希冲突的方式利用的是<code>线性探测</code>的方式：</p><p>先对哈希函数计算值所带入的 <code>key</code> 进行处理，转换为合理的计算值，如果计算得出的位置为 <code>EXIST</code>，就依次往后探测，直到找到空位置为止，然后插入即可</p><p><strong>那么哈希表满了之后的扩容是怎么一回事呢？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/873d83400ee741bfa2d8438b654459ef.png" alt="在这里插入图片描述"></p><p>我们要知道判断一个哈希表是否应该开始扩容的标准是<code>负载因子</code>，通过 <code>size / capacity</code> 判断哈希表的填充程度，我们这里设置为 <code>0.7</code> 即扩容</p><p>既然扩容了，之前的数据就必须重新计算位置放入哈希表，不然关系就全乱了，或许会有人想为什么不直接新创建一个数组来放？而是创建一个新对象 <code>HashTable&lt;K, V, HashFunc&gt; newHT</code>，再来创建新哈希表，这是因为在对象里操作可以使用插入等便捷操作，使得新哈希表的创建更方便</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>计算位置时除 <code>size</code>，而不是 <code>capacity</code>，因为 <code>size</code> 直接反映了数组的有效长度， <code>capacity</code> 只是为创建更大的数组做准备的，<code>[0, table_size-1]</code> 是索引的合法范围</li><li><code>hashi %= _table.size()</code> 是为了避免超出数组有效索引范围，只要大于 <code>size</code> 就会被除余回到数组第一个位置</li><li>有人担心扩容会影响搜索效率，其实影响并不是很大，每次扩容都为之前的两倍，会比之前大很多，也就碰上扩容那一次效率不太高，整体来讲影响是不大的</li></ul><h4 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashData&lt;<span class="type">const</span> K, V&gt;* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 线性探测</span></span><br><span class="line">HashFunc hf;</span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(key) % _table.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (_table[hashi]._state != EMPTY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_table[hashi]._state == EXIST</span><br><span class="line">&amp;&amp; _table[hashi]._kv.first == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (HashData&lt;<span class="type">const</span> K, V&gt;*) &amp; _table[hashi];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">++hashi;</span><br><span class="line">hashi %= _table.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环条件为 <code>_table[hashi]._state != EMPTY</code> 是因为在插入的时候为空就必定插入，那么查找的过程中在找到新的空之前必定能找到想要的值（如果正确插入的话），if条件还必须加入 <code>_table[hashi]._state == EXIST</code> 是因为避免查找到的是已删除的值</p><p>🔥<strong>值得注意的是：</strong> 返回的是 <code>HashData&lt;const K, V&gt;*</code>，而不是 <code>HashData&lt; K, V&gt;*</code>，防止 <code>key</code> 被错误修改</p><h4 id="哈希表的删除"><a href="#哈希表的删除" class="headerlink" title="哈希表的删除"></a>哈希表的删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HashData&lt;<span class="type">const</span> K, V&gt;* ret = <span class="built_in">Find</span>(key);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">ret-&gt;_state = DELETE;</span><br><span class="line">--_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除可以说是我们学的那么多个结构里，比插入简单的了，直接删除修改状态即可</p><h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p>二次探测的位置计算基于平方序列探测的，下面将给出详细的计算步骤：</p><ol><li>核心计算公式</li></ol><p>给定初始哈希位置 <code>h₀</code> 和探测次数 <code>i</code>，下一个探测位置为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">h</span>(i) = (h₀ + i²) % table_size</span><br></pre></td></tr></table></figure><ul><li><code>h₀</code>：初始哈希值（例如 <code>hash(key) % table_size</code>）</li><li><code>i</code>：探测次数，从 <code>1</code> 开始递增</li><li><code>table_size</code>：哈希表的大小（必须为素数，否则可能无法覆盖所有槽位）</li></ul><ol start="2"><li>计算步骤示例</li></ol><p>假设哈希表大小 <code>table_size = 7</code>（素数），初始哈希位置 <code>h₀ = 3</code>，插入时发生冲突，则二次探测的位置序列为：</p><table><thead><tr><th>探测次数 i</th><th>计算公式</th><th>结果 h(i)</th></tr></thead><tbody><tr><td>1</td><td><code>(3 + 1²) % 7</code></td><td>4</td></tr><tr><td>2</td><td><code>(3 + 2²) % 7</code></td><td>0</td></tr><tr><td>3</td><td><code>(3 + 3²) % 7</code></td><td>5</td></tr><tr><td>4</td><td><code>(3 + 4²) % 7</code></td><td>2</td></tr><tr><td>5</td><td><code>(3 + 5²) % 7</code></td><td>6</td></tr><tr><td>6</td><td><code>(3 + 6²) % 7</code></td><td>1</td></tr></tbody></table><p><strong>序列：</strong> <code>3</code> → <code>4</code> → <code>0</code> → <code>5</code> → <code>2</code> → <code>6</code> → <code>1</code>，覆盖所有 <code>7</code> 个槽位</p><ol start="3"><li>为什么表大小必须是素数？<br>若 <code>table_size</code> 为合数，可能无法覆盖所有槽位。例如，当 <code>table_size = 4</code>（合数）时：</li></ol><table><thead><tr><th>探测次数 i</th><th>计算公式</th><th>结果 h(i)</th></tr></thead><tbody><tr><td>1</td><td><code>(h₀ + 1²) % 4</code></td><td>h₀ + 1</td></tr><tr><td>2</td><td><code>(h₀ + 2²) % 4</code></td><td>h₀</td></tr><tr><td>3</td><td><code>(h₀ + 3²) % 4</code></td><td>h₀ + 1</td></tr></tbody></table><p><strong>序列：</strong> <code>h₀</code> → <code>h₀+1</code> → <code>h₀</code> → <code>h₀+1</code>，只能访问 <code>2</code> 个槽位，导致死循环</p><ol start="4"><li>代码实现示例</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 扩容逻辑（略）</span></span><br><span class="line">    </span><br><span class="line">    HashFunc hf;</span><br><span class="line">    <span class="type">size_t</span> h0 = <span class="built_in">hf</span>(kv.first) % _table.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二次探测</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; _table.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">size_t</span> hashi = (h0 + i * i) % _table.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_table[hashi]._state != EXIST) &#123;</span><br><span class="line">            _table[hashi]._kv = kv;</span><br><span class="line">            _table[hashi]._state = EXIST;</span><br><span class="line">            ++_n;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 表满（实际不会触发，因提前扩容）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性探测和二次探测对比"><a href="#线性探测和二次探测对比" class="headerlink" title="线性探测和二次探测对比"></a>线性探测和二次探测对比</h3><table><thead><tr><th>特性</th><th>线性探测</th><th>二次探测</th></tr></thead><tbody><tr><td>探测序列</td><td><code>h₀, h₀+1, h₀+2, ...</code></td><td><code>h₀, h₀+1, h₀+4, h₀+9, ...</code></td></tr><tr><td>聚集问题</td><td>严重（主聚集）</td><td>较轻（二次聚集）</td></tr><tr><td>空间利用率</td><td>低（易导致连续槽位被占用）</td><td>高（更均匀分布）</td></tr><tr><td>表满检测</td><td>遍历全量槽位即可检测</td><td>需遍历约一半槽位</td></tr></tbody></table><h2 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h2><h3 id="哈希桶"><a href="#哈希桶" class="headerlink" title="哈希桶"></a>哈希桶</h3><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6c4dec18aceb4429a49bfcace906814e.png" alt="在这里插入图片描述"></p><p>从上图可以看出，开散列中每个桶中放的都是发生哈希冲突的元素</p><p>闭散列最大的缺陷就是空间利用率比较低，这也是哈希的缺陷，那么有没有办法不把数据只局限在数组里，有的兄弟有的，可以使用<code>拉链法</code>，也叫<code>哈希桶</code>，将数据以单链表的形式挂起来</p><h4 id="哈希表的基本数据结构-1"><a href="#哈希表的基本数据结构-1" class="headerlink" title="哈希表的基本数据结构"></a>哈希表的基本数据结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HashNode</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line">HashNode&lt;K, V&gt;* _next;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HashNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; _kv)</span><br><span class="line">:_kv(kv)</span><br><span class="line">, _next(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>, <span class="keyword">class</span> <span class="title class_">HashFunc</span> = DefaultHashFunc&lt;K&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> HashNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line">_table.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _table[i];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;Node*&gt; _table; <span class="comment">// 指针数组</span></span><br><span class="line"><span class="type">size_t</span> _n = <span class="number">0</span>; <span class="comment">// 存储了多少个有效数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vector&lt;Node*&gt;</code> 或者 <code>vector&lt;list&gt;</code> 都是可以的，节点都是指针需要释放，析构函数需要自己实现</p><h4 id="哈希表的插入-1"><a href="#哈希表的插入-1" class="headerlink" title="哈希表的插入"></a>哈希表的插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(kv.first))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashFunc hf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子到1就扩容</span></span><br><span class="line"><span class="keyword">if</span> (_n == _table.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newSize = _table.<span class="built_in">size</span>() * <span class="number">2</span>;</span><br><span class="line">vector&lt;Node*&gt; newTable;</span><br><span class="line">newTable.<span class="built_in">resize</span>(newSize, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历旧表，顺手牵羊，把节点牵下来挂到新表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _table[i];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插到新表</span></span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(cur-&gt;_kv.first) % newSize;</span><br><span class="line">cur-&gt;_next = newTable[hashi];</span><br><span class="line">newTable[hashi] = cur;</span><br><span class="line"></span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_table[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_table.<span class="built_in">swap</span>(newTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(kv.first) % _table.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 头插</span></span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">newnode-&gt;_next = _table[hashi];</span><br><span class="line">_table[hashi] = newnode;</span><br><span class="line">++_n;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个哈希桶可以挂多个数据以节省空间，负载因子可以扩大到 <code>1</code>，平均下来一个桶一个数据</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b560dacd058b44f6b897446809b76074.png" alt="在这里插入图片描述"></p><p>这里悬挂操作是以如图头插的方式进行的，在扩容时，把原先的桶挂到新表上的时候，由于是头插，原先的单链表会在新表上倒置，但是这不影响查找元素，每条桶的元素还是固定的，只是顺序不一样而已</p><h4 id="哈希表的查找-1"><a href="#哈希表的查找-1" class="headerlink" title="哈希表的查找"></a>哈希表的查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HashFunc hf;</span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(key) % _table.<span class="built_in">size</span>();</span><br><span class="line">Node* cur = _table[hashi];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当查找的节点为头节点时，prev为空，</p><h4 id="哈希表的删除-1"><a href="#哈希表的删除-1" class="headerlink" title="哈希表的删除"></a>哈希表的删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HashFunc hf;</span><br><span class="line"><span class="type">size_t</span> hashi = <span class="built_in">hf</span>(key) % _table.<span class="built_in">size</span>();</span><br><span class="line">Node* prev = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _table[hashi];</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (prev == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_table[hashi] = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prev-&gt;_next = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prev = cur;</span><br><span class="line">cur = cur-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当查找的节点为头节点时，<code>prev</code> 为空，直接让下一个节点成为头节点即可<br>当查找的节点为其他节点时，让前一个节点和下一个节点链接</p><p>记得释放删除的节点</p><h2 id="开散列与闭散列比较"><a href="#开散列与闭散列比较" class="headerlink" title="开散列与闭散列比较"></a>开散列与闭散列比较</h2><p>应用链地址法处理溢出，需要增设链接指针，似乎增加了存储开销</p><p><strong>事实上：</strong> 由于开放地址法必须保持大量的空闲空间以确保搜索效率，如二次探查法要求装载因子 <code>a &lt;= 0.7</code>，而表项所占空间又比指针大的多，所以使用链地址法反而比开地址法节省存储空间</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0361593a75dd4129a4204e3047871644.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：map &amp;&amp; set底层剖析及迭代器万字详解</title>
      <link href="/2025/05/14/CPP%E8%BF%9B%E9%98%B6/map%20&amp;&amp;%20set%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/05/14/CPP%E8%BF%9B%E9%98%B6/map%20&amp;&amp;%20set%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><code>map</code>、<code>set</code> 的封装可以说是很天才的底层结构了，本篇将对其结构进行详细的解析，虽然会很复杂且难以理解，但是学完成就感满满，而且对底层理解和面试很有帮助</p><h1 id="map、set的基本结构"><a href="#map、set的基本结构" class="headerlink" title="map、set的基本结构"></a>map、set的基本结构</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e68d1a6b6e0844da91d43af3063303e1.png" alt="在这里插入图片描述"></p><p>通过查看官方文档，截取部分关键代码，我们可以发现 <code>set</code> 虽然事 <code>k-k</code> 类型，<code>map</code> 是 <code>k-v</code> 类型，但是实际上这两个类共用一个红黑树，准确来说是共用同一个模板类型，<code>set</code> 是 <code>&lt;K，K&gt;</code>，<code>map</code> 是 <code>&lt;K，pair&lt;K，V&gt;&gt;</code>，下面会进行详细解析</p><ul><li><code>size_type node_count</code>：用于记录红黑树节点数量，跟踪树的大小</li><li><code>link_type header</code>：是指向红黑树头节点的指针</li><li><code>Value value_field</code>：存储节点的值</li></ul><p>那么下面我们将自己实现简单的 <code>set</code> 和 <code>map</code> 类：</p><h1 id="map、set模拟实现"><a href="#map、set模拟实现" class="headerlink" title="map、set模拟实现"></a>map、set模拟实现</h1><h2 id="初步定义"><a href="#初步定义" class="headerlink" title="初步定义"></a>初步定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, K&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>平常我们认为键值对指的就是 <code>K</code> 和 <code>V</code>，但是在库里不是这样的，库里的 <code>K</code> 表示键值对的类型，<code>V</code> 表示插入红黑树的键值对，只不过对于 <code>set</code> 来说，<code>K</code> 和 <code>V</code> 是一样的</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/78c5df437a1b43729930fe5554222438.png" alt="在这里插入图片描述"></p><p>在红黑树中，定义的模板参数 <code>T</code>，而不是原先的 <code>pair</code>，这里的 <code>T</code> 表示插入的数据 <code>_data</code> 的类型，这种定义方法能够共同使用同一参数模板，避免额外的代码编写</p><h2 id="仿函数实现"><a href="#仿函数实现" class="headerlink" title="仿函数实现"></a>仿函数实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, K, SetKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> kv.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道 <code>set</code> 和 <code>map</code> 是通过比较 <code>key</code>，在红黑树中来插入的，但是由于上述的定义，如果每次对于 <code>map</code> 都频繁取出 <code>first</code> 就太麻烦了，因此就定义了仿函数</p><p>🚩<strong>为什么使用仿函数而不是普通函数呢？</strong></p><blockquote><p>红黑树中只要涉及到数据 <code>_data</code> 的地方，就需要使用到仿函数提取 <code>key</code>，使用普通函数消耗太大，而仿函数带有 <code>inline</code> 的性质，降低消耗。同时官方文档中还对比较进行了实现，即 <code>Compare</code>，模板要求参数必须是一个类型，而普通函数无法作为类型传递</p></blockquote><p>🚩<strong>为什么要自己定义仿函数，pair自带的仿函数不行吗？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a91c9d67824a45aabf039c9eb00ec0de.png" alt="在这里插入图片描述"><br>虽然 <code>pair</code> 确实有自己的仿函数比较，但是他是比较完 <code>first</code> 后不行，会接着比较 <code>second</code>，这不符合我们的设计思路</p><hr><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4d593e6f7b2c47e99ece8998edee1aaf.png" alt="在这里插入图片描述"></p><p>截取了部分 <code>insert</code> 中的代码，利用仿函数确实是能够简单的实现键值 <code>first</code> 的提取，我们再对整体的调用思路进行整理</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/12e5584389b445a1afc3d3c4a07ce5a5.png" alt="在这里插入图片描述"></p><p>其实仿函数主要是为了 <code>map</code> 而设计的，为的就是提取 <code>first</code>，<code>set</code> 为了保持设计模式的一致，因而也设计了相同的仿函数，这样就不用关心是否需要调用这一点了，保持一致性</p><p>这里我们不对 <code>Compare</code> 进行实现，有兴趣的可以自己去看底层代码</p><p>🔥<strong>值得注意的是：</strong> 仿函数内不实现比较功能是因为，比较功能是一个外层调用功能，如果放在内部就不能操作者自行去调用了，况且 <code>Compare</code> 也是以仿函数的形式实现的，两个仿函数嵌套过于复杂，不好使用</p><h2 id="Find功能实现"><a href="#Find功能实现" class="headerlink" title="Find功能实现"></a>Find功能实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">KeyOfT kot;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器初步功能实现"><a href="#迭代器初步功能实现" class="headerlink" title="迭代器初步功能实现"></a>迭代器初步功能实现</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0f8fc160755b406a8782ad7bc94b69da.png" alt="在这里插入图片描述"></p><p>类似的迭代器分析我们在 <code>list</code> 部分有做过解析，确实大体上是相像的，但是结构并不一样，这里的树形结构需要以中序遍历：<code>左-根-右</code>的方式遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__TreeIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __TreeIterator&lt;T&gt; Self;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__TreeIterator(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>库里的迭代器模式并不能满足我们的设计需要，所以这里自己构建一个 <code>__TreeIterator</code> 类</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="++运算符重载"></a>++运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 右树的最左节点(最小节点)</span></span><br><span class="line">Node* subLeft = _node-&gt;_right;</span><br><span class="line"><span class="keyword">while</span> (subLeft-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">subLeft = subLeft-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = subLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="comment">// 找孩子是父亲左的那个祖先节点，就是下一个要访问的节点</span></span><br><span class="line"><span class="keyword">while</span> (parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历的方式是 <code>左-根-右</code>，因此可以总结为两种情况来遍历：</p><ul><li><strong>当前节点有右子树</strong></li></ul><p><strong>处理方式：</strong> 找到右子树的最左节点（即右子树中的最小值）</p><p><strong>原因：</strong> 在中序遍历中，当前节点的下一个节点是其右子树的最左节点</p><ul><li><strong>当前节点没有右子树</strong></li></ul><p><strong>处理方式：</strong> 向上回溯，直到找到某个祖先节点，使得当前节点位于该祖先的左子树中</p><p><strong>原因：</strong> 在中序遍历中，若无右子树，则下一个节点是第一个满足 “当前节点是其左子节点” 的祖先</p><p>🔥<strong>值得注意的是：</strong> 当前节点没有右子树的情况，是 <code>左-根-右</code> 的最后一步，无论是在根的左边还是右边，最终都会回到根节点，所以直接 <code>_node = parent</code> 即可</p><h3 id="–运算符重载"><a href="#–运算符重载" class="headerlink" title="–运算符重载"></a>–运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">Node* subRight = _node-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (subRight-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">subRight = subRight-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">_node = subRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 孩子是父亲的右的那个节点</span></span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator--</code>  的思路和 <code>operator++</code> 是一样的，反过来遍历就行了</p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="*运算符重载"></a>*运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载-2"><a href="#运算符重载-2" class="headerlink" title="-&gt;运算符重载"></a>-&gt;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再提醒一下重载 <code>-&gt;</code> 是因为用 <code>*</code> 的代码不够简洁，具体分析参考 <code>list</code> 部分的解析</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/146324257?spm=1001.2014.3001.5501">C++效率掌握之STL库：list底层剖析及迭代器万字详解</a></p></blockquote><h3 id="运算符重载-3"><a href="#运算符重载-3" class="headerlink" title="!&#x3D;运算符重载"></a>!&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_node</code>：当前迭代器指向的节点<br><code>s._node</code>：另一个迭代器（作为参数传入）指向的节点</p><h3 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RBTree.h</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* leftMin = _root;</span><br><span class="line"><span class="keyword">while</span> (leftMin &amp;&amp; leftMin-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">leftMin = leftMin-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(leftMin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set.h Map.h</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RBTree.h</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set.h Map.h</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>现在已经可以基本实现遍历的功能了</p><h2 id="迭代器进阶功能实现"><a href="#迭代器进阶功能实现" class="headerlink" title="迭代器进阶功能实现"></a>迭代器进阶功能实现</h2><h3 id="set：const迭代器及insert的实现"><a href="#set：const迭代器及insert的实现" class="headerlink" title="set：const迭代器及insert的实现"></a>set：const迭代器及insert的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>set</code> 规定 <code>key</code> 是不可以被修改的，因此 <code>iterator</code> 和 <code>const_iterator</code> 本质上其实都是<code>const_iterator</code></p><p>🔥<strong>值得注意的是：</strong> <code>begin()</code> 和 <code>end()</code> 的 <code>const</code> 迭代器函数被 <code>const</code> 修饰是为了满足常量容器对象或非常量容器对象都能调用</p><hr><p><code>insert</code> 的错误代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是返回红黑树的插入，红黑树的插入详见下面的代码展示</p><p>从之前的学习我们知道 <code>insert</code> 返回的是 <code>pair&lt;iterator, bool&gt;</code>，那么是不是直接返回insert的结果就好了呢？看似确实是没问题，但是这里理了个巨大的坑，我们实际分析一波：</p><ul><li><code>_t.Insert(key)</code> 返回的是 <code>RBTree::iterator</code>，是一个普通迭代器</li><li><code>pair&lt;iterator, bool&gt; insert(const K&amp; key)</code> 返回的是 <code>set::iterator</code>，是一个 <code>const</code> 迭代器</li></ul><p><code>insert</code> 的正确代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterator RBTree::const_iterator</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// pair&lt;RBTree::iterator, bool&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::iterator, <span class="type">bool</span>&gt; ret = <span class="type">_t</span>.<span class="built_in">Insert</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(ret.first, ret.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是先将 <code>insert</code> 返回的普通迭代器由变量 <code>ret</code> 存储，然后再用一个匿名对象进行构造，将 <code>ret</code> 的普通迭代器构造成 <code>const</code> 迭代器返回即可，下面将进行详细的构造原理解释：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e75c8299ed0d4935bdce59c8470482ab.png" alt="在这里插入图片描述"></p><p>回看官方文档发现 <code>iterator</code> 和 <code>const_iterator</code> 都是被单独拿出来实例化的，并没有受到 <code>Ref</code> 和 <code>Ptr</code> 的影响，那么此时就分为两种情况：</p><ul><li><strong>普通迭代器的拷贝构造</strong></li></ul><p>当  <code>__rb_tree_iterator</code> 是普通迭代器时，<code>iterator</code> 就是自身类型，此时构造函数等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__rb_tree_iterator(<span class="type">const</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;&amp; it)</span><br><span class="line">    : <span class="built_in">node</span>(it.node) </span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure><p>这是一个标准的拷贝构造函数，用于创建一个新的普通迭代器，指向相同的节点</p><ul><li><strong>const迭代器的构造</strong></li></ul><p>当 <code>__rb_tree_iterator</code> 是 <code>const</code> 迭代器时， <code>iterator</code> 指的是普通迭代器类型，此时构造函数等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__rb_tree_iterator(<span class="type">const</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;&amp; it)</span><br><span class="line">    : <span class="built_in">node</span>(it.node) </span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure><p>这变成了一个构造函数，允许从普通迭代器创建 <code>const</code> 迭代器</p><p>所以可以理解为单独拿出来实例化是为了不让 <code>Ref</code> 和 <code>Ptr</code> 影响参数，而外面的类型就会受 <code>Ref</code> 和 <code>Ptr</code> 影响，这样就能保证外面的类型是 <code>const</code> 迭代器，里面的参数是普通迭代器，成功构造出一个支持普通迭代器构造 <code>const</code> 迭代器的构造函数</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/43809235b03f493eb4440fcf8d1b2673.png" alt="在这里插入图片描述"></p><p>那再转到实际代码上，<code>ret.first</code> 的类型是 <code>typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator</code> ，返回值 <code>pair</code> 的第一个元素类型是 <code>set</code> 类中定义的 <code>iterator</code>，实际上是 <code>typename RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator</code></p><p><code>ret.first</code> 会调用自定义的迭代器类型的构造函数 <code>__TreeIterator(const Iterator&amp; it)</code> 进行单参数转换，变成 <code>const_iterator</code></p><h3 id="map：const迭代器及insert、-运算符重载的实现"><a href="#map：const迭代器及insert、-运算符重载的实现" class="headerlink" title="map：const迭代器及insert、[ ]运算符重载的实现"></a>map：const迭代器及insert、[ ]运算符重载的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>map</code> 来说，<code>key</code> 是不允许改变的，<code>value</code> 是可以改变的，但是如果像 <code>set</code> 那样写的话 <code>key</code> 和 <code>value</code> 都不能修改了，所以直接在 <code>pair</code> 的 <code>key</code> 加 <code>const</code> ，控制 <code>value</code> 即可</p><p>–<br><code>insert</code> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code> 就没有像 <code>set</code> 那么麻烦了，红黑树和 &#96;map 的迭代器是一致的</p><hr><p><code>[ ]运算符重载</code> 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = <span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前详细解释过，可以看之前的博客</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/147564088?spm=1001.2014.3001.5501">C++漫溯键值的长河：map &amp;&amp; set</a></p></blockquote><h1 id="3-代码展示"><a href="#3-代码展示" class="headerlink" title="3.代码展示"></a>3.代码展示</h1><p>🚩<strong>MySet.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator RBTree::const_iterator</span></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// pair&lt;RBTree::iterator, bool&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::iterator, <span class="type">bool</span>&gt; ret = <span class="type">_t</span>.<span class="built_in">Insert</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(ret.first, ret.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, K, SetKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>MyMap.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">map</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> kv.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::iterator iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt;::const_iterator const_iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;iterator, <span class="type">bool</span>&gt; ret = <span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line"><span class="keyword">return</span> ret.first-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(kv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>RBTree.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Colour</span></span><br><span class="line">&#123;</span><br><span class="line">RED,</span><br><span class="line">BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">RBTreeNode&lt;T&gt;* _left;</span><br><span class="line">RBTreeNode&lt;T&gt;* _right;</span><br><span class="line">RBTreeNode&lt;T&gt;* _parent;</span><br><span class="line"></span><br><span class="line">T _data;</span><br><span class="line">Colour _col;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBTreeNode</span>(<span class="type">const</span> T&amp; data)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">, _data(data)</span><br><span class="line">, _col(RED)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__TreeIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> __TreeIterator&lt;T, Ptr, Ref&gt; Self;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __TreeIterator&lt;T, T*, T&amp;&gt; Iterator;</span><br><span class="line"></span><br><span class="line">__TreeIterator(<span class="type">const</span> Iterator&amp; it)</span><br><span class="line">:_node(it._node)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">__TreeIterator(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_node-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; s) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != s._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">Node* subRight = _node-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (subRight-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">subRight = subRight-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = subRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 孩子是父亲的右的那个节点</span></span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_node-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 右树的最左节点(最小节点)</span></span><br><span class="line">Node* subLeft = _node-&gt;_right;</span><br><span class="line"><span class="keyword">while</span> (subLeft-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">subLeft = subLeft-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = subLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* cur = _node;</span><br><span class="line">Node* parent = cur-&gt;_parent;</span><br><span class="line"><span class="comment">// 找孩子是父亲左的那个祖先节点，就是下一个要访问的节点</span></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_node = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set-&gt;RBTree&lt;K, K, SetKeyOfT&gt; _t;</span></span><br><span class="line"><span class="comment">// map-&gt;RBTree&lt;K, pair&lt;K, V&gt;, MapKeyOfT&gt; _t;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 同一个类模板，传的不同的参数实例化出的不同类型</span></span><br><span class="line"><span class="keyword">typedef</span> __TreeIterator&lt;T, T*, T&amp;&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> __TreeIterator&lt;T, <span class="type">const</span> T*, <span class="type">const</span> T&amp;&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* leftMin = _root;</span><br><span class="line"><span class="keyword">while</span> (leftMin &amp;&amp; leftMin-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">leftMin = leftMin-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(leftMin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* leftMin = _root;</span><br><span class="line"><span class="keyword">while</span> (leftMin &amp;&amp; leftMin-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">leftMin = leftMin-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(leftMin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line">KeyOfT kot;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">_root-&gt;_col = BLACK;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(_root), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"></span><br><span class="line">KeyOfT kot;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; <span class="built_in">kot</span>(data))</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(cur), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">cur-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line">Node* newnode = cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kot</span>(parent-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line">Node* grandfather = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == grandfather-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandfather-&gt;_right;</span><br><span class="line"><span class="comment">// u存在且为红</span></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 变色</span></span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向上处理</span></span><br><span class="line">cur = grandfather;</span><br><span class="line">parent = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// u不存在 或 存在且为黑</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//     g</span></span><br><span class="line"><span class="comment">//   p</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">parent-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//     g</span></span><br><span class="line"><span class="comment">//   p</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"><span class="built_in">RotateR</span>(grandfather);</span><br><span class="line"></span><br><span class="line">cur-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// parent == grandfather-&gt;_right</span></span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandfather-&gt;_left;</span><br><span class="line"><span class="comment">// u存在且为红</span></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 变色</span></span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向上处理</span></span><br><span class="line">cur = grandfather;</span><br><span class="line">parent = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">//  p</span></span><br><span class="line"><span class="comment">//       c</span></span><br><span class="line"><span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">parent-&gt;_col = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">//  p</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"><span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">cur-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_root-&gt;_col = BLACK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="built_in">iterator</span>(newnode), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++_rotateCount;</span><br><span class="line"></span><br><span class="line">Node* cur = parent-&gt;_right;</span><br><span class="line">Node* curleft = cur-&gt;_left;</span><br><span class="line"></span><br><span class="line">parent-&gt;_right = curleft;</span><br><span class="line"><span class="keyword">if</span> (curleft)</span><br><span class="line">&#123;</span><br><span class="line">curleft-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_left = parent;</span><br><span class="line"></span><br><span class="line">Node* ppnode = parent-&gt;_parent;</span><br><span class="line"></span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur;</span><br><span class="line">cur-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppnode-&gt;_left == parent)</span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_right = cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = ppnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++_rotateCount;</span><br><span class="line"></span><br><span class="line">Node* cur = parent-&gt;_left;</span><br><span class="line">Node* curright = cur-&gt;_right;</span><br><span class="line"></span><br><span class="line">parent-&gt;_left = curright;</span><br><span class="line"><span class="keyword">if</span> (curright)</span><br><span class="line">curright-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line">Node* ppnode = parent-&gt;_parent;</span><br><span class="line">cur-&gt;_right = parent;</span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ppnode == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur;</span><br><span class="line">cur-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppnode-&gt;_left == parent)</span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = ppnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 17:20继续</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckColour</span><span class="params">(Node* root, <span class="type">int</span> blacknum, <span class="type">int</span> benchmark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (blacknum != benchmark)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == BLACK)</span><br><span class="line">&#123;</span><br><span class="line">++blacknum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == RED &amp;&amp; root-&gt;_parent &amp;&amp; root-&gt;_parent-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;出现连续红色节点&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CheckColour</span>(root-&gt;_left, blacknum, benchmark)</span><br><span class="line">&amp;&amp; <span class="built_in">CheckColour</span>(root-&gt;_right, blacknum, benchmark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">IsBalance</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col != BLACK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基准值</span></span><br><span class="line"><span class="type">int</span> benchmark = <span class="number">0</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_col == BLACK)</span><br><span class="line">++benchmark;</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CheckColour</span>(root, <span class="number">0</span>, benchmark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _rotateCount = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1a02acd6cb13427a80574da2d4c02983.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> map </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++色彩博弈的史诗：红黑树</title>
      <link href="/2025/05/12/CPP%E8%BF%9B%E9%98%B6/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2025/05/12/CPP%E8%BF%9B%E9%98%B6/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>红黑树是一种自平衡二叉查找树，每个节点都带有颜色属性，颜色或为红色或为黑色，可以理解为 <code>AVL</code> 树的进阶版，建议系统学习完 <code>AVL</code> 树再来看本篇博客</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/147686001?spm=1011.2415.3001.5331">C++漫步结构与平衡的殿堂：AVL树</a></p></blockquote><h1 id="红黑树的概念"><a href="#红黑树的概念" class="headerlink" title="红黑树的概念"></a>红黑树的概念</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c7aed7a78c2944bca2ebca94f8f6c1c1.png" alt="在这里插入图片描述"></p><blockquote><p>红黑树，是一种二叉搜索树，但在每个结点上增加一个存储位表示结点的颜色，可以是 <code>Red</code> 或 <code>Black</code>。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保最长路径的节点数量不超过最短路径节点数量的两倍（刚好两倍是可以的），因而是接近平衡的</p></blockquote><p>一个合格的红黑树需要满足以下条件：</p><ul><li>每个结点不是红色就是黑色 </li><li>根节点是黑色的  </li><li>如果一个节点是红色的，则它的两个孩子结点必须是黑色的，任何路径都没有连续的红色节点，也就是说可以有连续的黑色节点，但不可能一颗红黑树全是黑色节点  </li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色节点</li><li>每个叶子结点都是黑色的(此处的叶子结点指的是空结点)</li></ul><p><strong>为什么满足上面的性质，红黑树就能保证：其最长路径中节点个数不会超过最短路径节点个数的两倍？</strong></p><p><code>最短路径</code>就是仅由黑色节点构成的路径。因为如果路径中插入红色节点，会使路径变长，而全黑路径不包含额外红色节点，所以是最短的</p><p><code>最长路径</code>是红黑交替出现的路径。即每一个黑色节点后面都跟着一个红色节点（但红色节点后不能再有红色节点）</p><p>设最短路径的黑色节点数量为 <code>n</code> ，由于所有路径黑色节点数量相同，最长路径的黑色节点数量也为 <code>n</code> ，那么最长路径由于红黑交替的节点总数最多为 <code>2n</code> 。所以，最长路径的节点个数不会超过最短路径节点个数的两倍</p><h1 id="红黑树的结构"><a href="#红黑树的结构" class="headerlink" title="红黑树的结构"></a>红黑树的结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Colour</span></span><br><span class="line">&#123;</span><br><span class="line">RED,</span><br><span class="line">BLACK</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">RBTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">RBTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">RBTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line"></span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line">Colour _col;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RBTreeNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">,_right(<span class="literal">nullptr</span>)</span><br><span class="line">,_parent(<span class="literal">nullptr</span>)</span><br><span class="line">,_kv(kv)</span><br><span class="line">,_col(RED)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在节点的定义中，为什么要将节点的默认颜色给成红色的？</strong></p><p>红黑树的性质要求从根节点到每个叶子节点的路径上黑色节点数量相同。将新节点设为红色，在插入过程中，如果其父节点是黑色，那么插入红色节点不会影响任何路径上黑色节点的数量，也就不需要对树进行调整来满足红黑树的性质，从而减少了调整的可能性，提高了插入操作的效率</p><p>如果新节点是黑色，那么插入后可能会导致某个路径上的黑色节点数量增加，这会引发更复杂的 “双黑” 问题，即删除或插入操作后出现一个节点需要同时承担两个黑色节点的情况，处理起来相对复杂。而默认新节点为红色，出现的问题主要是红节点冲突，处理相对简单，以下的插入会详细解释原因</p><h1 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RBTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//根节点为空的情况</span></span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">_root-&gt;_col = BLACK;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找插入节点位置</span></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接插入节点与红黑树</span></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">cur-&gt;_col = RED;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line">Node* grandfather = parent-&gt;_parent;</span><br><span class="line"><span class="keyword">if</span> (parent == grandfather-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandfather-&gt;_right;</span><br><span class="line"><span class="comment">// u存在且为红</span></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 变色</span></span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向上处理</span></span><br><span class="line">cur = grandfather;</span><br><span class="line">parent = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// u不存在 或 存在且为黑</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//     g</span></span><br><span class="line"><span class="comment">//   p</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">parent-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//     g</span></span><br><span class="line"><span class="comment">//   p</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"><span class="built_in">RotateR</span>(grandfather);</span><br><span class="line"></span><br><span class="line">cur-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// parent == grandfather-&gt;_right</span></span><br><span class="line">&#123;</span><br><span class="line">Node* uncle = grandfather-&gt;_left;</span><br><span class="line"><span class="comment">// u存在且为红</span></span><br><span class="line"><span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 变色</span></span><br><span class="line">parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续向上处理</span></span><br><span class="line">cur = grandfather;</span><br><span class="line">parent = cur-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">//  p</span></span><br><span class="line"><span class="comment">//       c</span></span><br><span class="line"><span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">parent-&gt;_col = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">//  p</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"><span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">cur-&gt;_col = BLACK;</span><br><span class="line">grandfather-&gt;_col = RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_root-&gt;_col = BLACK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于插入的节点，可能会遇到三种情况：</p><p>🚩<strong>uncle存在且为红</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da9790f07aaa4c128a2174e4516e3013.png" alt="在这里插入图片描述"></p><p>我们定义插入节点为 <code>cur</code>，其父节点为 <code>parent</code>，父节点的兄弟节点为 <code>uncle</code>，父节点的父节点为 <code>grandfather</code></p><p>当新插入节点的双亲节点颜色为红色时，就违反了不能有连在一起的红色节点，想要尽可能不破坏红黑树的平衡结构的情况下正常插入，那么通过变色解决是最好的</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d58d394246044dc19c2a75e8191f6302.jpeg" alt="请添加图片描述"></p><p>不能连续出现红色节点，还要保持每条路径的黑色节点相同，可以将 <code>parent</code> 和 <code>uncle</code> 变黑，<code>grandfather</code> 变红解决</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2f78366cceb64f56a60e96fc2778b248.png" alt="在这里插入图片描述"></p><p>发现处理完之后，在子树上是保持平衡的，但是 <code>grandfather</code> 又出现了连续红色节点，这是其中一种情况，总共有三种情况：</p><ol><li><code>grandfather</code>  没有父亲，就是根，直接变黑就好了</li><li><code>grandfather</code> 有父亲，父亲是黑色，直接结束</li><li><code>grandfather</code> 有父亲，父亲是红色，重复上述操作</li></ol><p>很明显示例就是第三种</p><p>🚩<strong>uncle不存在</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c8a7ab1f936542068baea8b58236594c.png" alt="在这里插入图片描述"></p><p>当 <code>uncle</code> 不存在的时候，发现通过变色已经不能解决问题了，这个时候就要旋转调整结构了，根据 <code>cur</code> 的位置判断进行单旋还是双旋</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c5cf816c6b424ad99264d86f6d8e6058.png" alt="在这里插入图片描述"></p><p>然后根据结构性质进行变色即可</p><p>🚩<strong>uncle存在且为黑</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/020d183b4b604c93bdee7edc9fdbea5c.png" alt="在这里插入图片描述"></p><p>当 <code>uncle</code> 存在且为黑的时候，情况和 <code>uncle</code> 不存在是一样的</p><p>🔥<strong>值得注意的是：</strong> <code>AVL</code> 树旋转可以根据平衡因子为 <code>2</code> 的相对位置来判断是要单旋还是双旋，红黑树根据 <code>grandfather</code>，<code>parent</code>，<code>cur</code> 的相对位置来判断，也就是要多画图</p><h1 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h1><p>红黑树的删除本节不做讲解，有兴趣可参考：《算法导论》或者《STL源码剖析》</p><blockquote><p>传送门：<a href="https://www.cnblogs.com/fornever/archive/2011/12/02/2270692.html">博客园相关讲解</a></p></blockquote><h1 id="红黑树与AVL树的比较"><a href="#红黑树与AVL树的比较" class="headerlink" title="红黑树与AVL树的比较"></a>红黑树与AVL树的比较</h1><p><strong>可是红黑树的时间复杂度比AVL树更高啊，为什么反而用的更多？</strong></p><table><thead><tr><th>红黑树</th><th>AVL树</th></tr></thead><tbody><tr><td>最长路径不超过最短路径的2倍</td><td>高度差不超过1</td></tr><tr><td>10亿个值</td><td>10亿个值</td></tr><tr><td>2*logN-&gt;60</td><td>logN-&gt;30</td></tr></tbody></table><p>可以看到数据，性能处理上大概相差两倍，但是要知道 <code>CPU</code> 的性能是很强大的，每秒能处理十几亿的数据，这点差距根本不足为惧，而且红黑树和 <code>AVL</code> 树是处于同一量级的，但是 <code>AVL</code> 树的插入删除需要大量的旋转，控制严格平衡的代价太大，因此使用红黑树更多</p><h1 id="6-红黑树的验证"><a href="#6-红黑树的验证" class="headerlink" title="6.红黑树的验证"></a>6.红黑树的验证</h1><p>🚩<strong>检查是否有连续红色节点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckColour</span><span class="params">(Node* root, <span class="type">int</span> blacknum, <span class="type">int</span> benchmark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (blacknum != benchmark)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == BLACK)</span><br><span class="line">&#123;</span><br><span class="line">++blacknum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col == RED &amp;&amp; root-&gt;_parent &amp;&amp; root-&gt;_parent-&gt;_col == RED)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;出现连续红色节点&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CheckColour</span>(root-&gt;_left, blacknum, benchmark)</span><br><span class="line">&amp;&amp; <span class="built_in">CheckColour</span>(root-&gt;_right, blacknum, benchmark);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>检查是否平衡</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">IsBalance</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_col != BLACK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基准值</span></span><br><span class="line"><span class="type">int</span> benchmark = <span class="number">0</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_col == BLACK)</span><br><span class="line">++benchmark;</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">CheckColour</span>(root, <span class="number">0</span>, benchmark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Height</span>(_root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0da217772232444a83af965f5cc61fba.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++漫步结构与平衡的殿堂：AVL树</title>
      <link href="/2025/05/08/CPP%E8%BF%9B%E9%98%B6/AVL%E6%A0%91/"/>
      <url>/2025/05/08/CPP%E8%BF%9B%E9%98%B6/AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树，时间复杂度会退化成 <code>O(N)</code>，因此 <code>map</code>、<code>set</code> 等关联式容器的底层结构是对二叉树进行了平衡处理，即采用平衡树来实现</p><h1 id="AVL树的概念"><a href="#AVL树的概念" class="headerlink" title="AVL树的概念"></a>AVL树的概念</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/02c01428c6794f6dba721b3bdc716698.png" alt="在这里插入图片描述"></p><p>我们已经从多种树型结构走到现在，每一次变化都是为了提高搜索的效率，即时间复杂度</p><p>二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下，因此发明了 <code>AVL</code> 树</p><p><strong>那么什么是AVL树呢？</strong></p><p>当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过 <code>1</code> (需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/010eb839a53a40e6a82d290f0e45f327.png" alt="在这里插入图片描述"></p><p>一棵 <code>AVL</code> 树或者是空树，应该是具有以下性质的二叉搜索树：</p><ul><li>它的左右子树都是 <code>AVL</code> 树</li><li>左右子树高度之差(简称平衡因子)的绝对值不超过 <code>1(-1/0/1)</code></li></ul><p>二叉搜索树在理想情况下时间复杂度与二叉平衡搜索树相同，均为 $O(log_2 n)$，但在极端情况下二叉平衡搜索树优于二叉搜索树，因为二叉平衡搜索树会自己调整平衡（后面会详细解释）</p><p><strong>为什么是严格的绝对值为 1，不是 0 或者更大的数字？</strong></p><blockquote><p>若要求高度差为 <code>0</code>，即严格平衡，树的结构会过于 <code>rigid</code>（僵化）。每次插入或删除节点都可能需要大量调整操作，导致性能下降。允许高度差为 <code>1</code>，在保持较好平衡性的同时，减少了不必要的调整<br>若允许高度差为 <code>2</code>，树的平衡性会明显下降，可能出现一侧子树比另一侧高很多的情况，导致查找等操作的时间复杂度增加<br>所以平衡因子为 <code>1</code> 是最合适的</p></blockquote><h1 id="AVL树的结构"><a href="#AVL树的结构" class="headerlink" title="AVL树的结构"></a>AVL树的结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K, V&gt; _kv;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">AVLTreeNode&lt;K, V&gt;* _parent;</span><br><span class="line"><span class="type">int</span> _bf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVLTreeNode</span>(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span><br><span class="line">:_kv(kv)</span><br><span class="line">,_left(<span class="literal">nullptr</span>)</span><br><span class="line">,_right(<span class="literal">nullptr</span>)</span><br><span class="line">,_parent(<span class="literal">nullptr</span>)</span><br><span class="line">,_bf(<span class="number">0</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>pair&lt;K, V&gt; _kv</code>：用于存储键值对，<code>pair</code> 是 <code>C++</code> 标准库中的一个模板类，可将两个不同类型的值组合在一起</li><li><code>AVLTreeNode&lt;K, V&gt;* _left</code>：指向左子节点的指针</li><li><code>AVLTreeNode&lt;K, V&gt;* _right</code>：指向右子节点的指针</li><li><code>AVLTreeNode&lt;K, V&gt;* _parent</code>：指向父节点的指针，这在调整树的平衡时很有用</li><li><code>int _bf</code>：平衡因子（<code>Balance Factor</code>），用来记录该节点左右子树的高度差。平衡因子为 <code>0</code> 时表示左右子树高度相等；为 <code>1</code> 时表示右子树比左子树高 <code>1</code>；为 <code>-1</code> 时表示左子树比右子树高 <code>1</code></li></ul><h1 id="AVL树的插入"><a href="#AVL树的插入" class="headerlink" title="AVL树的插入"></a>AVL树的插入</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> AVLTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找节点插入位置</span></span><br><span class="line">Node* cur = _root;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_kv.first &gt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接插入节点与AVL树</span></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_kv.first &lt; kv.first)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整平衡因子</span></span><br><span class="line"><span class="keyword">while</span> (parent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">1</span> || parent-&gt;_bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = parent;</span><br><span class="line">parent = parent-&gt;_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;_bf == <span class="number">2</span> || parent-&gt;_bf == <span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//旋转调整（...）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AVL</code> 树的插入和二叉搜索树是很像的，先根据左大右小的原则，寻找插入节点的位置，然后判断父母节点与插入节点的关系，连接新节点，唯一不同的地方是平衡因子调节的部分，高度差是由右子树减去左子树得出的，<strong>可以总结出以下方法：</strong></p><p>🚩 <strong>(1)新增在左，parent平衡因子减减</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f02b13afd92944c5bb139983f8cc752d.png" alt="在这里插入图片描述"></p><p>🚩 <strong>(2)新增在右，parent平衡因子加加</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/410bc4f488f64023a009729108d1a995.png" alt="在这里插入图片描述"></p><p>🚩 <strong>(3)更新后parent平衡因子 &#x3D;&#x3D; 0</strong></p><p>说明 <code>parent</code> 所在的子树的高度不变，不会影响祖先，不用再继续沿着到 <code>root</code> 的路径往上更新，然后循环结束</p><p>🚩 <strong>(4)更新后parent平衡因子 &#x3D;&#x3D; 1 or -1</strong></p><p>说明 <code>parent</code> 所在的子树的高度变化，会影响祖先，需要继续沿着到 <code>root</code> 的路径往上更新，循环继续</p><p>🚩 <strong>(5)更新后parent平衡因子 &#x3D;&#x3D; 2 or -2</strong></p><p>说明 <code>parent</code> 所在的子树的高度变化且不平衡，需要对parent所在子树进行旋转，让他平衡，然后循环结束</p><p>🔥<strong>值得注意的是：</strong> 如果平衡因子出现比 <code>2</code> 还大，比 <code>-2</code> 还小的数，说明之前的插入就已经出问题了</p><h1 id="4-AVL树的旋转"><a href="#4-AVL树的旋转" class="headerlink" title="4.AVL树的旋转"></a>4.AVL树的旋转</h1><h2 id="4-1-左单旋"><a href="#4-1-左单旋" class="headerlink" title="4.1 左单旋"></a>4.1 左单旋</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = parent-&gt;_right;</span><br><span class="line">Node* curleft = cur-&gt;_left;</span><br><span class="line"></span><br><span class="line">parent-&gt;_right = curleft;</span><br><span class="line"><span class="keyword">if</span> (curleft)</span><br><span class="line">&#123;</span><br><span class="line">curleft-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_left = parent;</span><br><span class="line">Node* ppnode = parent-&gt;_parent;</span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur;</span><br><span class="line">cur-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppnode-&gt;_left == parent)</span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = ppnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_bf = cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下将根据一个图例来解释如何进行的左单旋：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dddf21e387504e9a8aff62141855004e.png" alt="在这里插入图片描述"></p><p>左单旋顾名思义就是右子树太长，需要向左旋转形成平衡，平衡因子为 <code>2</code> 的节点定为 <code>parent</code>，其右节点为 <code>cur</code>，<code>cur</code> 的左节点为 <code>curleft</code></p><ol><li><strong>调整 parent 的右子节点：</strong> 把 <code>parent</code> 的右子节点设置成 <code>curleft</code>，若 <code>curleft</code> 不为空，就把 <code>curleft</code> 的父节点设置成 <code>parent</code></li><li><strong>调整 cur 的左子节点：</strong> 把 <code>cur</code> 的左子节点设置成 <code>parent</code>，<code>ppnode</code> 为 <code>parent</code> 的父节点，把 <code>parent</code> 的父节点设置成 <code>cur</code></li><li><strong>调整根节点或者 ppnode 的子节点：</strong> 若 <code>parent</code> 是根节点，那就把 <code>cur</code> 设为新的根节点，并且将 <code>cur</code> 的父节点设为 <code>nullptr</code>。若 <code>parent</code> 不是根节点，就依据 <code>parent</code> 是  <code>ppnode</code> 的左子节点还是右子节点，来更新 <code>ppnode</code> 的相应子节点为 <code>cur</code>，同时把 <code>cur</code> 的父节点设为 <code>ppnode</code></li></ol><h2 id="4-2-右单旋"><a href="#4-2-右单旋" class="headerlink" title="4.2 右单旋"></a>4.2 右单旋</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = parent-&gt;_left;</span><br><span class="line">Node* curright = cur-&gt;_right;</span><br><span class="line"></span><br><span class="line">parent-&gt;_left = curright;</span><br><span class="line"><span class="keyword">if</span> (curright)</span><br><span class="line">&#123;</span><br><span class="line">curright-&gt;_parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* ppnode = parent-&gt;_parent;</span><br><span class="line">cur-&gt;_right = parent;</span><br><span class="line">parent-&gt;_parent = cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ppnode == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur;</span><br><span class="line">cur-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ppnode-&gt;_left == parent)</span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ppnode-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur-&gt;_parent = ppnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parent-&gt;_bf = cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和左单旋类似，这里就不详细解释了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a6222b4a4b254ffb9796791258a7a6eb.png" alt="在这里插入图片描述"></p><h2 id="右左双旋"><a href="#右左双旋" class="headerlink" title="右左双旋"></a>右左双旋</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateRL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = parent-&gt;_right;</span><br><span class="line">Node* curleft = cur-&gt;_left;</span><br><span class="line"><span class="type">int</span> bf = curleft-&gt;_bf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateR</span>(parent-&gt;_right);</span><br><span class="line"><span class="built_in">RotateL</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">curleft-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">curleft-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">curleft-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右左双旋适用于新节点插入较高右子树的左侧的情况</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/078253d206564deb9643348570a1377d.png" alt="在这里插入图片描述"><br><code>30</code> 为 <code>parent</code> 节点，<code>90</code> 为 <code>cur</code> 节点，<code>60</code> 为 <code>curleft</code> 节点</p><p>先以 <code>90</code> 进行右单旋，再以 <code>30</code> 进行左单旋 </p><p>双旋的重点是平衡节点的调整，根据多个例子可以知道，主要是看 <code>curleft</code> 节点的平衡因子</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a4e59ee00d44fd198f914dbce3f120d.png" alt="在这里插入图片描述"></p><p>如果原来 <code>curleft</code> 平衡因子为 <code>0</code> ，即 <code>curleft</code> 为新增节点导致的双旋，那么 <code>curleft</code>、<code>cur</code>、<code>parent</code> 平衡因子都为 <code>0</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d3ee6f66d5744cf48d45f8ba1fcd24c2.png" alt="在这里插入图片描述"></p><p>如果原来 <code>curleft</code> 平衡因子为 <code>1</code> ，即在 <code>curleft</code> 右边新增，那么 <code>cur</code> 和 <code>curleft</code> 平衡因子都为 <code>0</code>，<code>parent</code> 的平衡因子为 <code>1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/65df007705ab4cdaab2dfb39533109d9.png" alt="在这里插入图片描述"></p><p>如果原来 <code>curleft</code> 平衡因子为 <code>-1</code> ，即在 <code>curleft</code> 左边新增，那么 <code>parent</code> 和 <code>curleft</code> 平衡因子都为 <code>0</code>，<code>cur</code> 的平衡因子为 <code>1</code></p><h2 id="左右双旋"><a href="#左右双旋" class="headerlink" title="左右双旋"></a>左右双旋</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateLR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = parent-&gt;_left;</span><br><span class="line">Node* curright = cur-&gt;_right;</span><br><span class="line"><span class="type">int</span> bf = curright-&gt;_bf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RotateL</span>(parent-&gt;_left);</span><br><span class="line"><span class="built_in">RotateR</span>(parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bf == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">curright-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">1</span>;</span><br><span class="line">cur-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">curright-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bf == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">cur-&gt;_bf = <span class="number">-1</span>;</span><br><span class="line">curright-&gt;_bf = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和右左双旋类似，这里就不详细解释了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4b8a4ca271f24c75a446d68aba9a97a6.png" alt="在这里插入图片描述"></p><h1 id="AVL树的删除"><a href="#AVL树的删除" class="headerlink" title="AVL树的删除"></a>AVL树的删除</h1><blockquote><p>在实际开发中，虽然 <code>AVL</code> 树是一种自平衡的二叉搜索树，但其删除操作通常不被优先实现</p></blockquote><p><code>AVL</code> 树的核心特性是通过旋转操作（左旋、右旋、左右旋、右左旋）来保证树的高度平衡。在插入操作中，仅需从插入节点向上回溯至根节点，检查并调整路径上节点的平衡因子，最多进行两次旋转操作就能恢复树的平衡。然而，删除操作后，平衡的破坏可能会沿着从删除节点到根节点的路径向上传播，导致需要多次旋转操作来恢复平衡。这使得删除操作的实现逻辑变得异常复杂，需要仔细处理各种可能的情况</p><p>而且实现插入删除一般会使用 <code>红黑树</code>、<code>B树</code> 等更优的数据结构</p><h1 id="AVL树的高度"><a href="#AVL树的高度" class="headerlink" title="AVL树的高度"></a>AVL树的高度</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Height</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较左子树和右子树的高度，取较大值并加 <code>1</code>（加上当前根节点），得到当前子树的高度</p><h1 id="AVL树的平衡判断"><a href="#AVL树的平衡判断" class="headerlink" title="AVL树的平衡判断"></a>AVL树的平衡判断</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalance</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHight = <span class="built_in">Height</span>(root-&gt;_left);</span><br><span class="line"><span class="type">int</span> rightHight = <span class="built_in">Height</span>(root-&gt;_right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rightHight - leftHight != root-&gt;_bf)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;平衡因子异常:&quot;</span> &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; root-&gt;_bf &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(rightHight - leftHight) &lt; <span class="number">2</span></span><br><span class="line">&amp;&amp; <span class="built_in">IsBalance</span>(root-&gt;_left)</span><br><span class="line">&amp;&amp; <span class="built_in">IsBalance</span>(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每遍历一个节点就对其左右子树的高度进行计算，然后判断是否绝对值小于 <code>2</code></p><p><strong>总结：</strong> <code>AVL</code> 树是一棵绝对平衡的二叉搜索树，其要求每个节点的左右子树高度差的绝对值都不超过 <code>1</code>，这样可以保证查询时高效的时间复杂度，即$log_2 (N)$。但是如果要对 <code>AVL</code> 树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。因此：如果需要一种查询高效且有序的数据结构，而且数据的个数为静态的(即不会改变)，可以考虑 <code>AVL</code> 树，但一个结构经常修改，就不太适合</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/464c10797ee04a4c8db60dce89c613f4.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++缝隙间的重构史诗：异常</title>
      <link href="/2025/05/05/CPP%E8%BF%9B%E9%98%B6/%E5%BC%82%E5%B8%B8/"/>
      <url>/2025/05/05/CPP%E8%BF%9B%E9%98%B6/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>通过合理的异常处理机制，程序可以在遇到异常情况时，避免直接崩溃，而是采取合适的措施，如提示用户错误信息、进行数据回滚、尝试重新执行操作等，从而增强程序的健壮性和稳定性</p><h1 id="为什么要有异常处理机制？"><a href="#为什么要有异常处理机制？" class="headerlink" title="为什么要有异常处理机制？"></a>为什么要有异常处理机制？</h1><p>🚩<strong>传统的错误处理机制：</strong></p><ol><li>终止程序，如 <code>assert</code>，缺陷：用户难以接受。如发生内存错误，除 <code>0</code> 错误时就会终止程序</li><li>返回错误码，缺陷：需要程序员自己去查找对应的错误。如系统的很多库的接口函数都是通过把错误码放到 <code>errno</code> 中，表示错误</li></ol><p>实际中 <code>C</code> 语言基本都是使用返回错误码的方式处理错误，部分情况下使用终止程序处理非常严重的错误，因此通过异常机制来实现错误的查找回滚修改是很有必要的</p><h1 id="异常的抛出捕获机制"><a href="#异常的抛出捕获机制" class="headerlink" title="异常的抛出捕获机制"></a>异常的抛出捕获机制</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 当b == 0时抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">return</span> ((<span class="type">double</span>)a / (<span class="type">double</span>)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len, time;</span><br><span class="line">cin &gt;&gt; len &gt;&gt; time;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Division</span>(len, time) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* errmsg)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; errmsg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;unkown exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常机制是一种错误处理机制，当一个函数发现自己无法处理的错误时就可以抛出异常，让函数的直接或间接的调用者处理这个错误</p><ul><li><code>throw</code>: 当问题出现时，程序会抛出一个异常。这是通过使用 <code>throw</code> 关键字来完成的，即当出错误时，会通过抛出，然后打印错误信息等方式告诉程序员错误的问题是什么</li><li><code>try</code>: <code>try</code> 块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个 <code>catch</code> 块，即将可能会发生错误的函数放在 <code>try</code> 块里</li><li><code>catch</code>: 在您想要处理问题的地方，通过异常处理程序捕获异常，<code>catch</code> 关键字用于捕获异常，可以有多个 <code>catch</code> 进行捕获，根据环境不同选择合适的类型匹配 <code>catch</code></li></ul><p><code>errmsg</code> 是在异常处理中专门用来存放特定类型异常所携带错误信息的变量，方便后续对异常情况进行处理和提示</p><p><strong>那么异常的实现流程是怎么样的呢？</strong></p><ol><li>首先检查 <code>throw</code> 本身是否在 <code>try</code> 块内部，如果是再查找匹配的 <code>catch</code> 语句。如果有匹配的，则调到 <code>catch</code> 的地方进行处理</li><li>没有匹配的 <code>catch</code> 则退出当前函数栈，继续在调用函数的栈中进行查找匹配的 <code>catch</code></li><li>如果到达 <code>main</code> 函数的栈，依旧没有匹配的，则终止程序。上述这个沿着调用链查找匹配的 <code>catch</code> 子句的过程称为栈展开，所以实际中我们最后都要加一个 <code>catch(...)</code> 捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止</li><li>找到匹配的 <code>catch</code> 子句并处理以后，会继续沿着 <code>catch</code> 子句后面继续执行</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a5919578d65a4cd99ea492f8c0f5ba96.png" alt="在这里插入图片描述"></p><p><code>try</code> 在查找匹配的 <code>catch</code> 的流程图大概模式如图所示，类似于栈的递归</p><p>转换到上述的示例代码，即在 <code>main</code> 函数中，使用 <code>try</code> 块调用 <code>Func</code> 函数。如果 <code>Func</code> 函数中调用的 <code>Division</code> 函数抛出了 <code>const char*</code> 类型的异常，会被第一个 <code>catch</code> 块捕获，并输出异常信息；如果抛出了其他类型的异常，会被第二个 <code>catch</code> 块（使用 <code>...</code> 表示捕获所有类型的异常）捕获，并输出 “<code>unkown exception</code>“</p><p>🔥<strong>值得注意的是：</strong> </p><ol><li>异常是通过抛出对象而引发的，可以抛出任意类型的对象，该对象的类型决定了应该激活哪个 <code>catch</code> 的处理代码</li><li>被选中的处理代码是调用链中与该对象类型匹配且离抛出异常位置最近的那一个</li><li>抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被 <code>catch</code> 以后销毁（这里的处理类似于函数的传值返回）</li><li><code>catch(...)</code> 可以捕获任意类型的异常，问题是不知道异常错误是什么，防止程序直接终止了，也意味着程序抛出了个未知的异常</li><li><code>throw</code> 其实也可以有多个，但是这没有意义，第一个 <code>throw</code> 执行之后，就跳到对应的 <code>catch</code> 语块去了，后面的 <code>throw</code> 并不会执行</li><li>实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，可以抛出的派生类对象，使用基类捕获，这个在实际中非常实用，我们后面会详细讲解这个</li></ol><h1 id="异常的重新抛出"><a href="#异常的重新抛出" class="headerlink" title="异常的重新抛出"></a>异常的重新抛出</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Division</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 当b == 0时抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Division by zero condition!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">double</span>)a / (<span class="type">double</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span> len, time;</span><br><span class="line">cin &gt;&gt; len &gt;&gt; time;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Division</span>(len, time) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* errmsg)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; errmsg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>Division</code> 函数当 <code>b == 0</code> 时抛出异常，<code>Func</code> 函数内如果不直接捕获异常，跳到外面去 <code>catch</code> 的话，后面的 <code>delete[] array</code> 就不会执行了，会造成内存泄漏，因此需要先捕获异常，使语句正常执行，然后再将异常抛出</p><p>诸如此类，像这样为完成操作的抛出，值得注意：</p><ul><li>构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化</li><li>析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等)</li><li><code>C++</code> 中异常经常会导致资源泄漏的问题，比如在 <code>new</code> 和 <code>delete</code> 中抛出了异常，导致内存泄漏，在 <code>lock</code> 和 <code>unlock</code> 之间抛出了异常导致死锁，<code>C++</code> 经常使用 <code>RAII</code> 来解决以上问题，关于 <code>RAII</code> 我们智能指针这节进行讲解</li></ul><h1 id="异常的规范"><a href="#异常的规范" class="headerlink" title="异常的规范"></a>异常的规范</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c65de8e687cf4b02ae5205155c1773e5.png" alt="在这里插入图片描述"><br>以 <a href="https://legacy.cplusplus.com/reference/exception/exception/">exception</a> 异常类为例，发现 <code>C++98</code> 的异常规范为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>;</span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些，可以在函数的后面接 <code>throw(类型)</code>，列出这个函数可能抛掷的所有异常类型；函数的后面接 <code>throw()</code>，表示函数不抛异常；若无异常接口声明，则此函数可以抛掷任何类型的异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 中新增的noexcept，表示不会抛异常</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="built_in">thread</span> (thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>到了 <code>C++11</code>，因为之前的方式几乎没什么人用，索性改成有或没有异常抛出的选项</p><h1 id="5-异常的继承体系"><a href="#5-异常的继承体系" class="headerlink" title="5.异常的继承体系"></a>5.异常的继承体系</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器开发中通常使用的异常继承体系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Exception</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id)</span><br><span class="line">:_errmsg(errmsg)</span><br><span class="line">, _id(id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _errmsg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _errmsg;</span><br><span class="line"><span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SqlException</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SqlException</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id, <span class="type">const</span> string&amp; sql)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg, id)</span><br><span class="line">, _sql(sql)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;SqlException:&quot;</span>;</span><br><span class="line">str += _errmsg;</span><br><span class="line">str += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">str += _sql;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> string _sql;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheException</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CacheException</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg, id)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;CacheException:&quot;</span>;</span><br><span class="line">str += _errmsg;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpServerException</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HttpServerException</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id, <span class="type">const</span> string&amp; type)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg, id)</span><br><span class="line">, _type(type)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;HttpServerException:&quot;</span>;</span><br><span class="line">str += _type;</span><br><span class="line">str += <span class="string">&quot;:&quot;</span>;</span><br><span class="line">str += _errmsg;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> string _type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SQLMgr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">7</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">SqlException</span>(<span class="string">&quot;权限不足&quot;</span>, <span class="number">100</span>, <span class="string">&quot;select * from name = &#x27;张三&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//throw &quot;xxxxxx&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheMgr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">CacheException</span>(<span class="string">&quot;权限不足&quot;</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">CacheException</span>(<span class="string">&quot;数据不存在&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SQLMgr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HttpServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">HttpServerException</span>(<span class="string">&quot;请求资源不存在&quot;</span>, <span class="number">100</span>, <span class="string">&quot;get&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">HttpServerException</span>(<span class="string">&quot;权限不足&quot;</span>, <span class="number">101</span>, <span class="string">&quot;post&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CacheMgr</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">HttpServer</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; e) <span class="comment">// 这里捕获父类对象就可以</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Unkown Exception&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同开发人员可能根据自己的习惯随意抛出各种类型的异常，可能是标准库异常，也可能是自定义的零散异常类。这会导致在捕获异常时，很难使用统一的方式进行处理。例如，有的函数抛出 <code>std::runtime_error</code>，有的抛出自定义的简单字符串异常，外层调用者需要编写多种不同的 <code>catch</code> 块来捕获，代码会变得冗长且难以维护</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4b22128fe5fe439290bacb585ffe929e.png" alt="在这里插入图片描述"></p><p>所以公司就设计出了继承体系，抛出的异常对象都是继承自某个基类的派生类对象。这样，在捕获异常时，只需要捕获基类类型的异常，利用多态特性，就可以处理所有从该基类派生出来的各种具体异常类型</p><p>这里的代码里有一个基类 <code>Exception</code>，以及继承自它的三个派生类 <code>SqlException</code>、<code>CacheException</code> 和 <code>HttpServerException</code>。每个派生类都重写了 <code>what()</code> 方法，用于返回不同的异常信息</p><h1 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h1><p><strong>C++异常的优点：</strong></p><ol><li>异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的 <code>bug</code></li><li>返回错误码的传统方式有个很大的问题就是，在函数调用链中，深层的函数返回了错误，那么我们得层层返回错误，最外层才能拿到错误，具体看下面的详细解释</li><li>很多的第三方库都包含异常，比如 <code>boost</code>、<code>gtest</code>、<code>gmock</code> 等等常用的库，那么我们使用它们也需要使用异常</li><li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如 <code>T&amp; operator</code> 这样的函数，如果 <code>pos</code> 越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误</li></ol><p><strong>C++异常的缺点：</strong></p><ol><li>异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳，这会导致我们跟踪调试时以及分析程序时，比较困难</li><li>异常会有一些性能的开销。当然在现代硬件速度很快的情况下，这个影响基本忽略不计</li><li><code>C++</code> 没有垃圾回收机制，资源需要自己管理。有了异常非常容易导致内存泄漏、死锁等异常安全问题。这个需要使用 <code>RAII</code> 来处理资源的管理问题。学习成本较高</li><li><code>C++</code> 标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱</li><li>异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 <code>func（） throw();</code> 的方式规范化</li></ol><p><strong>总结：异常总体而言，利大于弊，所以工程中我们还是鼓励使用异常的。另外OO的语言基本都是用异常处理错误，这也可以看出这是大势所趋</strong></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/505ee7384196473e89cac0f0e629b1c5.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++漫溯键值的长河：map &amp;&amp; set</title>
      <link href="/2025/05/01/CPP%E8%BF%9B%E9%98%B6/map%20&amp;&amp;%20set/"/>
      <url>/2025/05/01/CPP%E8%BF%9B%E9%98%B6/map%20&amp;&amp;%20set/</url>
      
        <content type="html"><![CDATA[<p>迄今为止，除了二叉搜索树以外的结构，我们学习到的顺序表，链表，栈和队列等都属于这些容器统称为序列式容器，因为其底层为线性序列的数据结构，里面存储的是元素本身</p><h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><blockquote><p>根据应用场景的不同，<code>STL</code> 总共实现了两种不同结构的管理式容器：<code>树型结构</code>与<code>哈希结构</code>。树型结构的关联式容器主要有四种：<code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>。这四种容器的共同点是：使用<code>平衡搜索树(即红黑树)</code>作为其底层结果，容器中的元素是一个有序的序列</p></blockquote><p>关联式容器也是用来存储数据的，与序列式容器不同的是，其里面存储的是<code>&lt;key, value&gt;</code>结构的键值对，在数据检索时比序列式容器效率更高</p><p>键对值中的 <code>key</code> 表示键值，<code>value</code> 表示与 <code>key</code> 对应的信息</p><p><strong>SGI-STL中关于键值对的定义：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> T1 first_type;</span><br><span class="line"><span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">T1 first;</span><br><span class="line">T2 second;</span><br><span class="line"><span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>(<span class="type">const</span> T1&amp; a, <span class="type">const</span> T2&amp; b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> <code>pair</code> 是有重载比较大小的，<code>first</code> 和 <code>second</code> 一起比</p><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4f6c4675bdb642c68fc88bf2c2787b83.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/set/set/">set</a> 的主要特征可总结为：</p><ol><li><code>set</code> 是按照一定次序存储元素的容器</li><li>在 <code>set</code> 中，元素的 <code>value</code> 也标识它( <code>value</code> 就是 <code>key</code>，类型为 <code>T</code> )，并且每个 <code>value</code> 必须是唯一的 <code>set</code> 中的元素不能在容器中修改(元素总是 <code>const</code> )，但是可以从容器中插入或删除它们</li><li>在内部，<code>set</code> 中的元素总是按照其内部比较对象(类型比较)所指示的特定严格弱排序准则进行排序</li><li><code>set</code> 容器通过 <code>key</code> 访问单个元素的速度通常比 <code>unordered_set</code> 容器慢，但它们允许根据顺序对子集进行直接迭代</li><li><code>set</code> 在底层是用二叉搜索树(红黑树)实现的</li></ol><p>🔥<strong>值得注意的是：</strong></p><ol><li>与 <code>map/multimap</code> 不同，<code>map/multimap</code> 中存储的是真正的键值对 <code>&lt;key, value&gt;</code>，<code>set</code> 中只放 <code>value</code>，但在底层实际存放的是由 <code>&lt;value, value&gt;</code> 构成的键值对(后面底层的博客会解释)</li><li><code>set</code> 中插入元素时，只需要插入 <code>value</code> 即可，不需要构造键值对</li><li><code>set</code> 中的元素不可以重复(因此可以使用 <code>set</code> 进行去重)。</li><li>使用 <code>set</code> 的迭代器遍历 <code>set</code> 中的元素，可以得到有序序列</li><li><code>set</code> 中的元素默认按照小于来比较，即 <code>1</code>、<code>2</code>、<code>3</code>……的顺序</li><li><code>set</code> 中查找某个元素，时间复杂度为：$log_2 n$</li><li><code>set</code> 中的元素不允许修改</li><li><code>set</code> 中的底层使用二叉搜索树(红黑树)来实现</li></ol><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/07fe99bdb2e94eca81f83042179849e4.png" alt="在这里插入图片描述"></p><p> 由于 <code>set</code> 的基本功能，像 <code>insert</code>、<code>erase</code>、迭代器等都和 <code>string</code>、<code>vector</code> 等差不多，这里就不过多解释，详细的可以自行查看官方文档，本文将针对部分特殊的函数进行解析</p><p><code>find</code> 简单来说，就是寻找特定的键值，那么可以提出一个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>)</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> pos = s.<span class="built_in">find</span>(<span class="number">3</span>);<span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">3</span>);<span class="comment">//第二种</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>哪一种 <code>find</code> 方式能更好的删除？<strong>显然是第一种</strong></p><p>因为第一种是 <code>set</code> 里面的 <code>find</code>，会以平衡二叉搜索树的方式去查找，大的往左走，小的往右走，时间复杂度为 <code>O(logN)</code>；第二种是 <code>algorithm</code>(算法头文件)中的 <code>find</code>，是以依次遍历的方式，即中序遍历的方式进行的，时间复杂度为 <code>O(N)</code></p><h2 id="lower-bound、upper-bound"><a href="#lower-bound、upper-bound" class="headerlink" title="lower_bound、upper_bound"></a>lower_bound、upper_bound</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; myset;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itlow, itup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) myset.<span class="built_in">insert</span>(i * <span class="number">10</span>); <span class="comment">// 10 20 30 40 50 60 70 80 90</span></span><br><span class="line"></span><br><span class="line">itlow = myset.<span class="built_in">lower_bound</span>(<span class="number">30</span>);                <span class="comment">//            ^</span></span><br><span class="line">itup = myset.<span class="built_in">upper_bound</span>(<span class="number">65</span>);                 <span class="comment">//                        ^</span></span><br><span class="line"></span><br><span class="line">myset.<span class="built_in">erase</span>(itlow, itup);                     <span class="comment">// 10 20 70 80 90</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myset contains:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = myset.<span class="built_in">begin</span>(); it != myset.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为迭代器的区间遵循左闭右开原则，所以 <code>lower_bound</code> 用于查找第一个<code>大于等于</code>给定值 <code>val</code> 的元素位置，<code>upper_bound</code> 用于查找第一个<code>大于</code>给定值 <code>val</code> 的元素位置</p><h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ef030412b1934a5297c74d8295979bd1.png" alt="在这里插入图片描述"><br><a href="https://legacy.cplusplus.com/reference/set/multiset/">multiset</a> 的主要特征可总结为：</p><ol><li><code>multiset</code> 是按照特定顺序存储元素的容器，其中元素是<code>可以重复的</code></li><li>在 <code>multiset</code> 中，元素的 <code>value</code> 也会识别它(因为 <code>multiset</code> 中本身存储的就是 <code>&lt;value, value&gt;</code> 组成的键值对，因此 <code>value</code>本身就是 <code>key</code>，<code>key</code>就是 <code>value</code>，类型为 <code>T</code> )，<code>multiset</code> 元素的值不能在容器中进行修改(因为元素总是 <code>const</code> 的)，但可以从容器中插入或删除</li><li>在内部，<code>multiset</code> 中的元素总是按照其内部比较规则(类型比较)所指示的特定严格弱排序准则进行排序</li><li><code>multiset</code> 容器通过 <code>key</code> 访问单个元素的速度通常比 <code>unordered_multiset</code> 容器慢，但当使用迭代器遍历时会得到一个有序序列</li><li><code>multiset</code> 底层结构为二叉搜索树(红黑树)</li></ol><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>multiset</code> 中再底层中存储的是 <code>&lt;value, value&gt;</code> 的键值对</li><li><code>multiset</code> 的插入接口中只需要插入即可</li><li>与 <code>set</code> 的区别是，<code>multiset</code> 中的元素可以重复，<code>set</code> 是中 <code>value</code> 是唯一的</li><li>使用迭代器对 <code>multiset</code> 中的元素进行遍历，可以得到有序的序列</li><li><code>multiset</code> 中的元素不能修改</li><li>在 <code>multiset</code> 中找某个元素，时间复杂度为$O(log_2 N)$</li><li><code>multiset</code> 的作用：可以对元素进行排序</li></ol><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/57cb49b5685f4b2390f110f2c5284c84.png" alt="在这里插入图片描述"></p><p><code>multiset</code> 同样是这几个，但是 <code>count</code> 和 <code>equal_range</code> 可以说是专门给 <code>multiset</code> 打造的，虽然 <code>set</code> 里也可以用，但是没什么意义</p><p><code>count</code> 用于统计容器中某个值出现的次数</p><h2 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> result = mySet.<span class="built_in">equal_range</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = result.first; it != result.second; ++it) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>equal_range</code> 用于查找重复元素之间的区间，返回一个 <code>pair</code> 对象，该对象包含两个迭代器：</p><ol><li>第一个迭代器指向 <code>multiset</code> 中第一个等于 <code>value</code> 的元素（如果存在），或者指向第一个大于 <code>value</code> 的元素（如果不存在等于 value 的元素）</li><li>第二个迭代器指向 <code>set</code> 中最后一个等于 <code>value</code> 的元素的下一个位置（如果存在等于 <code>value</code> 的元素），或者与第一个迭代器相等（如果不存在等于 <code>value</code> 的元素）</li></ol><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/351acd1ed6f241438ba4fafe106be480.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/map/map/">map</a>的主要特征可总结为：</p><ol><li><code>map</code> 是关联容器，它按照特定的次序(按照 <code>key</code> 来比较)存储由键值 <code>key</code> 和值 <code>value</code> 组合而成的元素</li><li>在 <code>map</code> 中，键值 <code>key</code> 通常用于排序和唯一地标识元素，而值 <code>value</code> 中存储与此键值 <code>key</code> 关联的内容。键值 <code>key</code> 和值 <code>value</code> 的类型可能不同，并且在 <code>map</code> 的内部，<code>key</code> 与 <code>value</code> 通过成员类型 <code>value_type</code> 绑定在一起，为其取别名称为 <code>pair : typedef pair&lt;const key, T&gt;value_type</code></li><li>在内部，<code>map</code> 中的元素总是按照键值 <code>key</code> 进行比较排序的</li><li><code>map</code> 中通过键值访问单个元素的速度通常比 <code>unordered_map</code> 容器慢，但 <code>map</code> 允许根据顺序对元素进行直接迭代(即对 <code>map</code> 中的元素进行迭代时，可以得到一个有序的序列)</li><li><code>map</code> 支持下标访问符，即在 <code>[]</code> 中放入 <code>key</code>，就可以找到与 <code>key</code> 对应的 <code>value</code></li><li><code>map</code> 通常被实现为二叉搜索树(更准确的说：平衡二叉搜索树(红黑树))</li></ol><p>由于 <code>map</code> 的基本功能，像 <code>insert</code>、<code>erase</code>、迭代器等都和 <code>string</code>、<code>vector</code> 等差不多，这里就不过多解释，详细的可以自行查看官方文档，本文将针对部分函数进行解析</p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p><code>map</code> 中的 <code>insert</code> 插入的是一个 <code>pair</code> 结构对象，下面将列举多种插入方式：</p><p>🚩<strong>创建普通对象插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">kv1</span><span class="params">(<span class="string">&quot;insert&quot;</span>, <span class="string">&quot;插入&quot;</span>)</span></span>;</span><br><span class="line">dict.<span class="built_in">insert</span>(kv1);</span><br></pre></td></tr></table></figure><p>🚩<strong>创建匿名对象插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, string&gt;(<span class="string">&quot;sort&quot;</span>, <span class="string">&quot;排序&quot;</span>));</span><br></pre></td></tr></table></figure><p>🚩<strong>调用make_pair函数插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;字符串&quot;</span>));</span><br></pre></td></tr></table></figure><p>调用 <code>make_pair</code> 省去了声明类型的过程</p><p>🚩<strong>隐式类型转换插入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="built_in">insert</span>(&#123; <span class="string">&quot;string&quot;</span>,<span class="string">&quot;字符串&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>通常 <code>C++98</code> 只支持单参数隐式类型转换，到 <code>C++11</code> 的时候就开始支持多参数隐式类型转换</p><p><strong>有这么一个问题：为什么加上了引用反而要加const</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; kv2 = &#123; <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;插入&quot;</span> &#125;;</span><br><span class="line"><span class="type">const</span> pair&lt;string, string&gt;&amp; kv2 = &#123; <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;插入&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>无引用情况：</strong> 对于 <code>pair&lt;string, string&gt; kv2 = &#123; &quot;string&quot;, &quot;字符串&quot; &#125;;</code> ，编译器可能会执行拷贝省略（也叫返回值优化 <code>RVO</code> 或命名返回值优化 <code>NRVO</code> ）。比如在创建 <code>kv2</code> 时，直接在其存储位置构造对象，而不是先创建一个临时对象再拷贝 &#x2F; 移动过去</p><p><strong>加引用情况：</strong> 使用 <code>const pair&lt;string, string&gt;&amp; kv2 = &#123; &quot;string&quot;, &quot;字符串&quot; &#125;;</code> 时，这里 <code>kv2</code> 是引用，它绑定到一个临时对象（由大括号初始化列表创建 ）。因为引用本身不持有对象，只是给对象取别名，所以不存在像非引用对象构造时那种在自身存储位置直接构造的情况。不过，这种引用绑定临时对象的方式，只要临时对象的生命周期延长到与引用一样长（<code>C++</code> 规则规定，常量左值引用绑定临时对象时，临时对象生命周期延长 ），也不会额外增加拷贝 &#x2F; 移动开销</p><h2 id="operate"><a href="#operate" class="headerlink" title="operate-&gt;"></a>operate-&gt;</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, string&gt;::iterator it = dict.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != dict.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//it-&gt;first = &quot;xxx&quot;;</span></span><br><span class="line">    <span class="comment">//it-&gt;second = &quot;xxx&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; (*it).first &lt;&lt; &quot;:&quot; &lt;&lt; (*it).second &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>map</code> 中并没有对 <code>pair</code> 进行流插入运算符重载，<code>(*it).first</code> 这样子的方式又不太简洁不好看，所以进行了 <code>-&gt;</code> 运算符重载，返回的是 <code>first</code> 的地址，因此 <code>(*it).first</code> 等价于 <code>it-&gt;-&gt;first</code>，为了代码可读性，就省略一个 <code>-&gt;</code></p><h2 id="operate-1"><a href="#operate-1" class="headerlink" title="operate[ ]"></a>operate[ ]</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/66b3e2342fe84a1fa03ac17b8176d3a3.png" alt="在这里插入图片描述"></p><p><code>map</code> 中提供了 <code>[]</code> 运算符重载，可以通过 <code>key</code> 来访问 <code>value</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/40fc84735cc9440dbe09803ce3e75b54.png" alt="在这里插入图片描述"></p><p>首先我们知道 <code>insert</code> 的返回值 <code>key</code> 的部分是一个迭代器，<code>value</code> 的部分是个布尔值，文档中对该返回值的解释是：</p><ol><li><code>key</code> 已经在树里面，返回 <code>pair&lt;树里面key所在节点的iterator，false&gt;</code>，<code>false</code> 表示不用插入了</li><li><code>key</code> 不在树里面，返回 <code>pair&lt;树里面key所在节点的iterator，true&gt;</code>，<code>true</code> 表示需要插入新节点</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ec9d0f368d064081ba33e139e8f9df1c.png" alt="在这里插入图片描述"></p><p>再来看，左边是官方文档的原始定义，那么转化成右边的定义能够更直观理解其底层</p><p>这里 <code>V</code> 代表值类型，<code>K</code> 代表键类型 。<code>operator[]</code> 是操作符重载函数，接受一个常量引用类型的键 <code>key</code> ，返回值类型 <code>V</code> 的引用。这样设计是为了支持对容器内元素的读写操作。例如，可以通过 <code>map[key] = newValue;</code> 来修改值，或者通过 <code>auto value = map[key];</code> 来读取值</p><p>然后通过 <code>insert</code> 判断是否插入新节点，最后返回指定节点的 <code>value</code> 值</p><h2 id="map的应用实践：随机链表的复制"><a href="#map的应用实践：随机链表的复制" class="headerlink" title="map的应用实践：随机链表的复制"></a>map的应用实践：随机链表的复制</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/608f2a4050624ac79577407a00569ea3.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ab1adfb6fcad4cbba8ed7477510c5d04.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">随机链表的复制</a></p></blockquote><p><strong>题解:</strong></p><p>利用 <code>map</code> 的映射机制，首先，在第一次遍历原链表时，为原链表的每个节点创建一个对应的新节点，并将原节点和新节点的映射关系存储在 <code>map</code> 中。然后，在第二次遍历原链表时，对于原链表中的每个节点 <code>cur</code>，我们可以通过 <code>cur-&gt;random</code> 找到其随机指针指向的原节点，再利用之前存储的映射关系，在 <code>map</code> 中查找该原节点对应的新节点，将这个新节点赋值给当前新节点 <code>copynode</code> 的随机指针 <code>copynode-&gt;random</code></p><p>🔥<strong>值得注意的是：</strong> </p><p><strong>记录的不是cur和newnode的关系吗，为什么可以通过cur-&gt;random找到newnode-&gt;random？</strong></p><blockquote><p>假设原链表有三个节点 <code>A</code>、<code>B</code>、<code>C</code>，节点 <code>A</code> 的随机指针指向节点 <code>C</code><br><strong>建立映射阶段：</strong> 会为 <code>A</code>、<code>B</code>、<code>C</code> 分别创建对应的新节点 <code>A&#39;</code>、<code>B&#39;</code>、<code>C&#39;</code>，并在 <code>nodeCopyMap</code> 中记录映射关系：{<code>A</code> -&gt; <code>A&#39;</code>, <code>B</code> -&gt; <code>B&#39;</code>, <code>C</code> -&gt; <code>C&#39;</code>}。<br><strong>设置随机指针阶段：</strong> 当处理节点 <code>A</code> 时，<code>cur</code> 指向 <code>A</code>，<code>cur-&gt;random</code> 指向 <code>C</code>。由于 <code>C</code> 作为键存在于 <code>nodeCopyMap</code> 中，通过 <code>nodeCopyMap[cur-&gt;random]</code> 也就是 <code>nodeCopyMap[C]</code> 可以找到 <code>C&#39;</code>，接着把 <code>C&#39;</code> 赋值给 <code>A&#39;</code> 的随机指针 <code>A&#39;-&gt;random</code>，这样新链表中节点 <code>A&#39;</code> 的随机指针就正确地指向了节点 <code>C&#39;</code>，和原链表中节点 <code>A</code> 的随机指针指向 <code>C</code> 相对应</p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map&lt;Node*, Node*&gt; nodeCopyMap;</span><br><span class="line">        Node* copyhead = <span class="literal">nullptr</span>;</span><br><span class="line">        Node* copytail = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* copynode = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (copytail == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                copyhead = copytail = copynode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copytail-&gt;next = copynode;</span><br><span class="line">                copytail = copynode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nodeCopyMap[cur] = copynode;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node* copy = copyhead;</span><br><span class="line">        cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                copy-&gt;random = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy-&gt;random = nodeCopyMap[cur-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            copy = copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> copyhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/14eb6392efe046969e0e716b33701301.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/map/multimap/">multimap</a>的主要特征可总结为：</p><ol><li><code>multimaps</code> 是关联式容器，它按照特定的顺序，存储由 <code>key</code> 和 <code>value</code> 映射成的键值对 <code>&lt;key, value&gt;</code>，其中多个键值对之间的 <code>key</code> 是可以重复的。</li><li>在 <code>multimap</code> 中，通常按照 <code>key</code> 排序和惟一地标识元素，而映射的 <code>value</code> 存储与 <code>key</code> 关联的内容。<code>key</code> 和 <code>value</code> 的类型可能不同，通过 <code>multimap</code> 内部的成员类型 <code>value_type</code> 组合在一起，<code>value_type</code> 是组合 <code>key</code> 和 <code>value</code> 的键值对: <code>typedef pair&lt;const Key, T&gt; value_type;</code></li><li>在内部，<code>multimap</code> 中的元素总是通过其内部比较对象，按照指定的特定严格弱排序标准对 <code>key</code> 进行排序的。</li><li><code>multimap</code> 通过 <code>key</code> 访问单个元素的速度通常比 <code>unordered_multimap</code> 容器慢，但是使用迭代器直接遍历 <code>multimap</code> 中的元素可以得到关于 <code>key</code> 有序的序列</li><li><code>multimap</code> 在底层用二叉搜索树(红黑树)来实现</li></ol><p>注意：<code>multimap</code> 和 <code>map</code> 的唯一不同就是：<code>map</code> 中的 <code>key</code> 是唯一的，而 <code>multimap</code> 中<code>key</code> 是可以重复的</p><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>multimap</code> 中的 <code>key</code> 是可以重复的</li><li><code>multimap</code> 中的元素默认将 <code>key</code> 按照小于来比较</li><li><code>multimap</code> 中没有重载 <code>operator[]</code> 操作，因为一个 <code>key</code> 对应多个 <code>value</code> ，不知道找哪个 <code>value</code></li><li>使用时与 <code>map</code> 包含的头文件相同</li></ol><p><code>multimap</code> 和 <code>mutiset</code> 是差不多的，而且在实际应用中用的不多，所以这里就不细讲了</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7f32c51469a143f49d78553f27f49cf8.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> stl </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> map </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++穿梭树影间的智慧博弈：二叉搜索树OJ</title>
      <link href="/2025/04/25/CPP%E8%BF%9B%E9%98%B6/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91OJ/"/>
      <url>/2025/04/25/CPP%E8%BF%9B%E9%98%B6/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91OJ/</url>
      
        <content type="html"><![CDATA[<p>本篇对搜索二叉树常见的面试OJ进行了总结，方便对常见的数据结构使用方法进行总结</p><h1 id="根据二叉树创建字符串"><a href="#根据二叉树创建字符串" class="headerlink" title="根据二叉树创建字符串"></a>根据二叉树创建字符串</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cf30a0fd4f604d38b056832415c33018.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8ac23616ce564ae1b9ef6487002bf621.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/construct-string-from-binary-tree/description/">根据二叉树创建字符串</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ce58115c76e149aa913b28762a1c1f22.png" alt="在这里插入图片描述"></p><p>观察示例可以知道，无论是左为空还是左为不为空，都要添加括号，所以直接递归下去，右分支则可以根据情况省略括号</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">tree2str</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string str = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left || root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            str += <span class="built_in">tree2str</span>(root-&gt;left);</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            str += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            str += <span class="built_in">tree2str</span>(root-&gt;right);</span><br><span class="line">            str += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历-Ⅰ"><a href="#二叉树的层序遍历-Ⅰ" class="headerlink" title="二叉树的层序遍历 Ⅰ"></a>二叉树的层序遍历 Ⅰ</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f48532f1ac39461485364a057c662331.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8bd54c3a533746f3821828a9350f12ac.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历 Ⅰ</a></p></blockquote><p><strong>题解:</strong></p><p>据题意可知，需要将数据存储在一个二维数组，这里是个典型的层序遍历，即 <code>BFS(广度优先遍历)</code>，之前在数据结构部分用C语言进行了初步解析实现，这里用 <code>C++</code> 更普世的方法来实现 <code>BFS</code></p><blockquote><p><strong>传送门：</strong> <a href="https://blog.csdn.net/Zero_VPN/article/details/145818412">【初阶数据结构】节点层级的逻辑乐章：二叉树</a></p></blockquote><p>💻<strong>细节问题：</strong></p><p>注意二维数组的元素是一维数组，每次 <code>push</code> 要 <code>push</code> 到下一层，<code>vv.back()</code> 表示下一层，即 <code>vv.back().push_back(front-&gt;val)</code> 为下一层添加二叉树那一层的元素</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vv;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = q.<span class="built_in">size</span>();</span><br><span class="line">            vv.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vv.<span class="built_in">back</span>().<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历-Ⅱ"><a href="#二叉树的层序遍历-Ⅱ" class="headerlink" title="二叉树的层序遍历 Ⅱ"></a>二叉树的层序遍历 Ⅱ</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f8516772788e4911b1f9648083184713.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c48cc80545164eba8f440e5576cecadd.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层序遍历 Ⅱ</a></p></blockquote><p><strong>题解:</strong></p><p>这题其实和上面的题逻辑实现是一样的，从下至上遍历的话，看成从上至下的遍历的反转即可</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vv;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = q.<span class="built_in">size</span>();</span><br><span class="line">            vv.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* front = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vv.<span class="built_in">back</span>().<span class="built_in">push_back</span>(front-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vv.<span class="built_in">begin</span>(), vv.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> vv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d88cb3f3e4b14f36bb1816321d06e1b6.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6b4ff2f432a04d0e98e2daf93b3cf99f.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">二叉树的最近公共祖先</a></p></blockquote><p><strong>题解:</strong></p><p>据题目多种情况分析可知一共有三种情况：</p><p>🚩<strong>p和q都在根节点右支</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/39d5160e291a46f7b0b2a9612224e7c6.png" alt="在这里插入图片描述"></p><p>🚩<strong>p和q都在根节点左支</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/433e0edb85dd44cd8b0f4676a1edcc86.jpeg" alt="请添加图片描述"></p><p>🚩<strong>p和q都在根节点左支和右支</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cb5596a76c4248bf82a5d27e942fa684.png" alt="在这里插入图片描述"></p><hr><p>排除了p或q为根节点的情况，那么剩余的情况必定在根节点以下的节点，发现用向下递归的方法，<code>都在右支</code>或<code>都在左支</code>的情况最后都能被化成<code>子树根节点的左支和右支问题</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e807c15442624190877e9e302ae13eba.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(TreeNode* tree, TreeNode* x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree == x</span><br><span class="line">            || <span class="built_in">Find</span>(tree-&gt;left, x)</span><br><span class="line">            || <span class="built_in">Find</span>(tree-&gt;right, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> pLeft, pRight, qLeft, qRight;</span><br><span class="line">        pLeft = <span class="built_in">Find</span>(root-&gt;left, p);</span><br><span class="line">        pRight = !pLeft;</span><br><span class="line"></span><br><span class="line">        qLeft = <span class="built_in">Find</span>(root-&gt;left, q);</span><br><span class="line">        qRight = !qLeft;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qLeft &amp;&amp; pLeft)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(qRight &amp;&amp; pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a81afbf2aee04a2f81a107005e8d38f3.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6eddb1c76e17470bb97e2326a1085731.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">二叉搜索树与双向链表</a></p></blockquote><p><strong>题解:</strong></p><p>看双向链表可知，这是一个典型的中序遍历，左节点、节点、右节点的顺序，那么双向链表的节点顺序解决了，就要考虑节点的链接，前驱节点直接链接上一个中序遍历的节点，后驱节点则是下一个，最后返回最左下角的节点（即 <code>head</code> ）</p><p>💻<strong>细节问题：</strong></p><p>注意 <code>prev</code> 每次赋值完之后要更新一次，为下一个节点做准备，同时要以引用形式传递，全程只有一个 <code>prev</code> 在改变，不加引用的话就是不同层级递归下的 <code>prev</code>，这之间的 <code>prev</code>的改变不会互相影响，无法形成正确的链表关系<br>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(TreeNode* cur, TreeNode*&amp; prev)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Inorder</span>(cur-&gt;left, prev);</span><br><span class="line">        cur-&gt;left = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev)</span><br><span class="line">        &#123;</span><br><span class="line">            prev-&gt;right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = cur;</span><br><span class="line">        <span class="built_in">Inorder</span>(cur-&gt;right, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">Inorder</span>(pRootOfTree, prev);</span><br><span class="line"></span><br><span class="line">        TreeNode* head = pRootOfTree;</span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bcfcc4b00485431d83c4c2d15cdf1474.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/27c5d1f3e83348d2bcaed13f4fc9fcd3.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">从前序与中序遍历序列构造二叉树</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/923f666d20ce4cb2b7421c3cca932ff6.png" alt="在这里插入图片描述"></p><p>首先我们要知道，前序是按照先左根再右根的顺序进行，这也决定了他是二叉树中根的顺序，其次中序的遍历方式我们可以发现找到前序中的根，那么其左右区间就是左右子树，按照此种方法不断划分，就是利用的分治思想</p><p>💻<strong>细节问题：</strong> 当 <code>inbegin &gt; inend</code> 时，也就是最后返回空值的情况别忘了<br>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* _build(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span>&amp; prei, <span class="type">int</span> inbegin, <span class="type">int</span> inend)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inbegin &gt; inend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[prei]);</span><br><span class="line">        <span class="type">int</span> rooti = inbegin;</span><br><span class="line">        <span class="keyword">while</span> (rooti &lt;= inend)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (preorder[prei] == inorder[rooti])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++rooti;</span><br><span class="line">        &#125;</span><br><span class="line">        ++prei;</span><br><span class="line">        root-&gt;left = _build(preorder, inorder, prei, inbegin, rooti<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = _build(preorder, inorder, prei, rooti<span class="number">+1</span>, inend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> _build(preorder, inorder, i, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ef975c0e268a42db928d933d64c4aa97.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0d50565ef6b645cf88e03f537357b6bb.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">从中序与后序遍历序列构造二叉树</a></p></blockquote><p><strong>题解:</strong></p><p>这题与上一题的实现逻辑是一样的，中序负责划分左右区域，后序负责找节点，不过是从右子树开始罢了，要从数组 <code>postorder</code> 结尾往前走</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* _build(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder, <span class="type">int</span>&amp; prei, <span class="type">int</span> inbegin, <span class="type">int</span> inend)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inbegin &gt; inend)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[prei]);</span><br><span class="line">        <span class="type">int</span> rooti = inbegin;</span><br><span class="line">        <span class="keyword">while</span> (rooti &lt;= inend)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[prei] == inorder[rooti])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++rooti;</span><br><span class="line">        &#125;</span><br><span class="line">        --prei;</span><br><span class="line">        root-&gt;right = _build(inorder, postorder, prei, rooti<span class="number">+1</span>, inend);</span><br><span class="line">        root-&gt;left = _build(inorder, postorder, prei, inbegin, rooti<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = postorder.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> _build(inorder, postorder, i, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的前序遍历（非递归）"><a href="#二叉树的前序遍历（非递归）" class="headerlink" title="二叉树的前序遍历（非递归）"></a>二叉树的前序遍历（非递归）</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/eee7c6f54d1f4b3d9dfa68a2cb7298ee.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6e55bb5af0ca401ba65ff93247327ca7.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历（非递归）</a></p></blockquote><p><strong>题解:</strong></p><p>这里直接说明非递归的方法，其实和递归的思想差不多，但这里是用的循环，用非递归是因为递归在某些情况可能造成栈溢出</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e2e035135c9740998749c7b157f70dbe.png" alt="在这里插入图片描述"></p><p>每次遍历将操作的数入栈，输出的结果放在数组里</p><ol><li>遍历左路节点</li><li>遍历左树节点的右路</li></ol><p>对上面的步骤进行循环操作即可，直到栈内的数已经 <code>pop</code> 完说明已经结束</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">            cur = root;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode* top = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            cur = top-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历（非递归）"><a href="#二叉树的中序遍历（非递归）" class="headerlink" title="二叉树的中序遍历（非递归）"></a>二叉树的中序遍历（非递归）</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8d2d45adfcaf4859877dccafd860bcd0.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/44f483d0b29c4baf810e68995755469f.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树的中序遍历（非递归）</a></p></blockquote><p><strong>题解:</strong></p><p>这题和上一题的思路基本一致，只不过是顺序有所改变</p><ol><li>左路节点入栈</li><li>访问左路节点及左路节点的右子树</li></ol><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">            cur = root;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode* top = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            v.<span class="built_in">push_back</span>(top-&gt;val);</span><br><span class="line"></span><br><span class="line">            cur = top-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的后序遍历（非递归）"><a href="#二叉树的后序遍历（非递归）" class="headerlink" title="二叉树的后序遍历（非递归）"></a>二叉树的后序遍历（非递归）</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ba122d654fc84b379a284f22d1427c53.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a502035dc07e4574a9f866e73bddc441.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历（非递归）</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/80442a466c41407fb99b4e47d4958722.png" alt="在这里插入图片描述"></p><p>后序遍历其实也是和上面差不多，但是需要确认右路是否访问过，不然会陷入死循环，所以定义一个 <code>prev</code> 来确认是否访问过</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode* top = st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top-&gt;right == <span class="literal">nullptr</span> || top-&gt;right == prev)</span><br><span class="line">            &#123;</span><br><span class="line">                prev = top;</span><br><span class="line">                v.<span class="built_in">push_back</span>(top-&gt;val);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = top-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/822ba758ced84e6e927cb24c2ad0a12c.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++镌刻数据密码的树之铭文：二叉搜索树</title>
      <link href="/2025/04/19/CPP%E8%BF%9B%E9%98%B6/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2025/04/19/CPP%E8%BF%9B%E9%98%B6/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>继数据结构的二叉树学习，本篇进行更进一步的搜索二叉树，是一种更为常见的结构</p><h1 id="二叉搜索树的概念"><a href="#二叉搜索树的概念" class="headerlink" title="二叉搜索树的概念"></a>二叉搜索树的概念</h1><blockquote><p>二叉搜索树简单来说就是一个排序树</p></blockquote><p><strong>它是具有以下性质的二叉树:</strong></p><ul><li>若它的<code>左子树不为空</code>，则左子树上所有节点的值都<code>小于</code>根节点的值</li><li>若它的<code>右子树不为空</code>，则右子树上所有节点的值都<code>大于</code>根节点的值</li><li>它的<code>左右子树也分别为二叉搜索树</code></li></ul><p>🔥<strong>值得注意的是：</strong> 每棵子树都满足该性质</p><h1 id="二叉搜索树的实现"><a href="#二叉搜索树的实现" class="headerlink" title="二叉搜索树的实现"></a>二叉搜索树的实现</h1><h2 id="二叉搜索树的结构"><a href="#二叉搜索树的结构" class="headerlink" title="二叉搜索树的结构"></a>二叉搜索树的结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">BSTreeNode&lt;K&gt;* _left;</span><br><span class="line">BSTreeNode&lt;K&gt;* _right;</span><br><span class="line">K _key;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTreeNode</span>(<span class="type">const</span> K&amp; key)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">,_right(<span class="literal">nullptr</span>)</span><br><span class="line">,_key(key)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>_left：</code> 指向左子节点的指针。</li><li><code>_right：</code> 指向右子节点的指针。</li><li><code>_key：</code> 存储节点的键值</li></ul><h2 id="二叉搜索树的节点寻找"><a href="#二叉搜索树的节点寻找" class="headerlink" title="二叉搜索树的节点寻找"></a>二叉搜索树的节点寻找</h2><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>cur</code> 指针从根节点开始遍历二叉搜索树：</p><ul><li>若 <code>cur-&gt;_key</code> 小于 <code>key</code>，则转向右子树继续查找</li><li>若 <code>cur-&gt;_key</code> 大于 <code>key</code>，则转向左子树继续查找</li><li>若 <code>cur-&gt;_key</code> 等于 <code>key</code>，说明找到了目标键值，返回 <code>true</code></li><li>若遍历结束 <code>cur</code> 为 <code>nullptr</code>，表示未找到目标键值，返回 <code>false</code></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _FindR(Node* root, <span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _FindR(root-&gt;_right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _FindR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>检查基本情况：</strong> 查看当前节点 <code>root</code> 是否为空。若为空，返回 <code>false</code>，递归结束<br><strong>比较键值：</strong> 若当前节点不为空，将当前节点的键值 <code>root-&gt;_key</code> 与目标键值 <code>key</code> 进行比较重复，每次递归调用都会将问题规模缩小，直至满足基本情况或者找到目标节点</p><p>🔥<strong>值得注意的是：</strong> 注意这些非递归要放在 <code>private</code>，因为 <code>root</code> 也是 <code>private</code>，由于要控制子树，必须要传入 <code>root</code>，如果是 <code>public</code> 的话，就只能传入自己的 <code>root</code>，而不是二叉搜索树的 <code>root</code>，无法保证 <code>root</code> 的正确性</p><h2 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h2><h3 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>cur</code> 为空时，说明已经找到了插入位置。创建一个新节点，并根据 <code>parent</code> 的键和要插入的键的大小关系，将新节点插入到 <code>parent</code> 的左子树或右子树中</p><p>🔥<strong>值得注意的是：</strong> 首先检查树是否为空，如果为空，则直接创建一个新节点作为根节点，并返回 <code>true</code></p><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _InsertR(Node*&amp; root, <span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里递归的流程和查找的递归代码几乎一样，唯一不同的是要传入的 <code>root</code> 需要加引用，这是因为这里的代码只执行了节点寻找创建的操作，那么当我们找到空节点并创建的时候，由于 <code>root</code> 是上一个 <code>_InsertR</code> 函数 <code>root-&gt;_left</code> 或 <code>root-&gt;_right</code> 的别名，创建的时候相当于 <code>root-&gt;_left = new Node(key)</code> 或 <code>root-&gt;_right = new Node(key)</code>，这样才能完成链接</p><h2 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h2><h3 id="非递归-2"><a href="#非递归-2" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 左为空</span></span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left == cur)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 右为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_right == cur)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 左右都不为空 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* parent = cur;</span><br><span class="line">Node* leftMax = cur-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (leftMax-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">parent = leftMax;</span><br><span class="line">leftMax = leftMax-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(leftMax-&gt;_key, cur-&gt;_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_left == leftMax)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_left = leftMax-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;_right = leftMax-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = leftMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先先找到需要删除的节点，接着就需要分了讨论：</p><ol><li>要删除的结点<code>无孩子结点</code></li><li>要删除的结点<code>只有左孩子结点</code></li><li>要删除的结点<code>只有右孩子结点</code></li><li>要删除的结点<code>有左、右孩子结点</code></li></ol><p>🔥<strong>值得注意的是：</strong> 第一点可以直接看成只有一个节点的情况，即链接的是空节点</p><p><strong>删除该结点且使被删除节点的双亲结点指向被删除节点的左孩子结点–直接删除</strong></p><p>如果待删除节点 <code>cur</code> 的左子树为空，分两种情况处理：<br>如果 <code>cur</code> 就是根节点，那么将根节点更新为 <code>cur</code> 的右子树；如果 <code>cur</code> 不是根节点，则根据 <code>cur</code> 是其父节点 <code>parent</code> 的左子节点还是右子节点，相应地将 <code>parent</code> 的左指针或右指针指向 <code>cur</code> 的右子树</p><p><strong>删除该结点且使被删除节点的双亲结点指向被删除结点的右孩子结点–直接删除</strong></p><p>如果待删除节点 cur 的右子树为空，同样分两种情况：</p><p>若 <code>cur</code> 是根节点，将根节点更新为 <code>cur</code> 的左子树；若 <code>cur</code> 不是根节点，根据 <code>cur</code> 是 <code>parent</code> 的左子节点还是右子节点，将 <code>parent</code> 的左指针或右指针指向 <code>cur</code> 的左子树</p><p><strong>在删除节点的左子树中寻找最大节点或者在它的右子树中寻找最小节点，用它的值填补到被删除节点中，再来处理该节点的删除问题–替换法删除</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9bf9f0c932f549499a1fe4a85f1a62e3.png" alt="在这里插入图片描述"></p><p>当待删除节点 <code>cur</code> 的左右子树都不为空时，为了保持二叉搜索树的性质，找到 <code>cur</code> 左子树中的最大节点 <code>leftMax</code>（即左子树中最右侧的节点）。通过一个 <code>while</code> 循环找到 <code>leftMax</code>，并记录其父亲节点 <code>parent</code>。然后交换 <code>leftMax</code> 和 <code>cur</code> 的键值，这样就将删除 <code>cur</code> 节点的问题转化为删除 <code>leftMax</code> 节点的问题，<code>leftMax</code> 由于是最大的节点，所以要么没有节点，要么只有左节点</p><p>🔥<strong>值得注意的是：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3863971c9e074771bfbd01bdb439f364.png" alt="在这里插入图片描述"></p><p><code>Node* parent = cur</code> 而不是 <code>Node* parent = nullptr</code>，因为如果第一个左子节点就是 <code>leftMax</code>，那么 <code>parent</code> 就不会改变，使用 <code>parent</code> 的时候就会出问题</p><h3 id="2-4-2-递归"><a href="#2-4-2-递归" class="headerlink" title="2.4.2 递归"></a>2.4.2 递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _EraseR(Node*&amp; root, <span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* del = root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、左为空</span></span><br><span class="line"><span class="comment">// 2、右为空</span></span><br><span class="line"><span class="comment">// 3、左右都不为空</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* leftMax = root-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (leftMax-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">leftMax = leftMax-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(root-&gt;_key, leftMax-&gt;_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将即 <code>root</code> 和 <code>leftMax</code> 的键值进行交换，此时原本 <code>leftMax</code> 节点处的键值变为要删除的 <code>key</code>，由于交换后要删除的节点在左子树中，所以递归调用 <code>_EraseR(root-&gt;_left, key)</code> 继续在左子树中查找并删除这个键值为 <code>key</code> 的节点。因为在左子树中删除节点时，可能又会遇到不同的情况（如左子树为空、右子树为空或左右子树都不为空），所以递归调用可以继续处理这些情况，直到成功删除节点或者确定节点不存在</p><p>🔥<strong>值得注意的是：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3863971c9e074771bfbd01bdb439f364.png" alt="在这里插入图片描述"></p><p>这里 <code>return _EraseR(root-&gt;_left, key)</code> 不能写成 <code>return _EraseR(leftMax, key)</code></p><p>因为 <code>leftMax</code> 只是个局部变量，对其进行操作没法改变 <code>8</code> 与 <code>1</code> 的链接</p><h2 id="2-5-二叉搜索树的拷贝"><a href="#2-5-二叉搜索树的拷贝" class="headerlink" title="2.5 二叉搜索树的拷贝"></a>2.5 二叉搜索树的拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">Copy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">Node* copyroot = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key);</span><br><span class="line">copyroot-&gt;_left = <span class="built_in">Copy</span>(root-&gt;_left);</span><br><span class="line">copyroot-&gt;_right = <span class="built_in">Copy</span>(root-&gt;_right);</span><br><span class="line"><span class="keyword">return</span> copyroot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为当前节点创建一个新的节点 <code>copyroot</code>，新节点的键值和原节点 <code>root</code> 的键值相同</li><li>递归调用 <code>Copy</code> 函数来拷贝原节点 <code>root</code> 的左子树，将拷贝结果赋值给新节点 <code>copyroot</code> 的左子节点指针 <code>_left</code></li><li>同样地，递归调用 <code>Copy</code> 函数来拷贝原节点 <code>root</code> 的右子树，把拷贝结果赋值给新节点 <code>copyroot</code> 的右子节点指针 <code>_right</code></li><li>最后返回新创建的节点 <code>copyroot</code>，该节点及其子树构成了原节点及其子树的深拷贝</li></ol><h1 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h1><p>🚩<strong>K模型：</strong> 即只有 <code>key</code> 作为关键码，结构中只需要存储 <code>key</code> 即可，关键码即为需要搜索到的值，主要判断在不在的场景</p><p><strong>比如：</strong> 给一个单词 <code>word</code>，判断该单词是否拼写正确，具体方式如下：</p><ul><li>以词库中所有单词集合中的每个单词作为 <code>key</code>，构建一棵二叉搜索树</li><li>在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误。</li></ul><p>🚩<strong>KV模型：</strong> 每一个关键码 <code>key</code>，都有与之对应的值 <code>value</code>，即 <code>&lt;key, value&gt;</code> 的键值对，通过一个值找另外一个值</p><ul><li>比如英汉词典就是英文与中文的对应关系，通过英文可以快速找到与其对应的中文，英文单词与其对应的中文 <code>&lt;word, chinese&gt;</code> 就构成一种键值对；</li><li>再比如统计单词次数，统计成功后，给定单词就可快速找到其出现的次数，单词与其出现次数就是 <code>&lt;word, count&gt;</code> 就构成一种键值对</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> key_value</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">BSTreeNode&lt;K, V&gt;* _left;</span><br><span class="line">BSTreeNode&lt;K, V&gt;* _right;</span><br><span class="line">K _key;</span><br><span class="line">V _value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTreeNode</span>(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span><br><span class="line">:_left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">, _key(key)</span><br><span class="line">, _value(value)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTreeNode&lt;K, V&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BSTree</span>()</span><br><span class="line">:_root(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_InOrder(_root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">FindR</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _FindR(_root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertR</span><span class="params">(<span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(_root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EraseR</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _EraseR(_root, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">bool</span> _EraseR(Node*&amp; root, <span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* del = root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、左为空</span></span><br><span class="line"><span class="comment">// 2、右为空</span></span><br><span class="line"><span class="comment">// 3、左右都不为空</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Node* leftMax = root-&gt;_left;</span><br><span class="line"><span class="keyword">while</span> (leftMax-&gt;_right)</span><br><span class="line">&#123;</span><br><span class="line">leftMax = leftMax-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(root-&gt;_key, leftMax-&gt;_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _EraseR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> _InsertR(Node*&amp; root, <span class="type">const</span> K&amp; key, <span class="type">const</span> V&amp; value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_right, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _InsertR(root-&gt;_left, key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node* _FindR(Node* root, <span class="type">const</span> K&amp; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _FindR(root-&gt;_right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _FindR(root-&gt;_left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _InOrder(Node* root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_InOrder(root-&gt;_left);</span><br><span class="line">cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; root-&gt;_value &lt;&lt; endl;</span><br><span class="line">_InOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>key_value</code> 模型主要是通过一个节点里包含两个值：<code>key</code> 和 <code>value</code> 实现的，只要找到了<code>key</code> 就能顺便找到 <code>value</code>，其余的函数逻辑等都与 <code>K</code> 模型几乎一致</p><p>🔥<strong>值得注意的是：</strong> 二叉搜索树的性能是不错的，插入和删除操作都必须先查找，查找效率代表了二叉搜索树中各个操作的性能，</p><ul><li><code>最优情况下</code>，二叉搜索树为完全二叉树(或者接近完全二叉树)，其平均比较次数为：$log_2 N$</li><li><code>最差情况下</code>，二叉搜索树退化为单支树(或者类似单支)，其平均比较次数为：$\frac{N}{2}$</li></ul><p>如果退化成单支树，二叉搜索树的性能就失去了。那能否进行改进，不论按照什么次序插入关键码，二叉搜索树的性能都能达到最优？那么我们涉及到后续章节学习的 <code>AVL树</code> 和 <code>红黑树</code> </p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/966700ecc2fc4ada8164c3ffdd1745e3.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序诗篇的灵动赋形：多态</title>
      <link href="/2025/04/10/CPP%E8%BF%9B%E9%98%B6/%E5%A4%9A%E6%80%81/"/>
      <url>/2025/04/10/CPP%E8%BF%9B%E9%98%B6/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>本篇将开启 <code>C++</code> 三大特性中的多态篇章，多态允许你以统一的方式处理不同类型的对象，通过相同的接口来调用不同的实现方法。这意味着你可以编写通用的代码，而这些代码可以在运行时根据对象的实际类型来执行特定的操作</p><h1 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h1><blockquote><p>通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态</p></blockquote><p>✏️<strong>举个例子：</strong></p><p>比如买高铁票的时候，我们都属于 <code>Person</code> 类，买的时候会显示为全价，那么我们又属于 <code>Student</code> 类，继承于 <code>Person</code> 类，这时买的时候又会显示为半价，假设两个类都有 <code>BuyTicket</code> 函数，那么相同的函数在继承的基础上，能够实现不同的功能，这就是多态</p><h1 id="多态的语法实现"><a href="#多态的语法实现" class="headerlink" title="多态的语法实现"></a>多态的语法实现</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票-全价&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>被 <code>virtual</code> 修饰的类成员函数称为虚函数，注意这里和菱形虚拟继承的 <code>virtual</code> 没有关系，不过使用了同一个关键字而已</p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>内联函数一般不能是虚函数。内联函数是在编译时将函数体插入到调用处，而虚函数是在运行时进行动态绑定的，两者特性冲突</li><li>静态成员不可以是虚函数，虚函数是通过对象的虚函数表指针来实现动态绑定的，也就是在运行时根据对象的实际类型来确定调用哪个虚函数。而静态成员函数是属于类的，不依赖于具体对象，没有对象的概念，也没有虚函数表指针，无法通过动态绑定来调用</li><li>构造函数不可以是虚函数，对象中的虚函数表指针是在构造函数初始化列表阶段才初始化的</li></ul><h2 id="多态的构成"><a href="#多态的构成" class="headerlink" title="多态的构成"></a>多态的构成</h2><p>虚函数是实现多态的重要组成部分，<strong>将上面举的例子以代码形式实现如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票-全价&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票-半价&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为，比如 <code>Student</code> 继承了 <code>Person</code>，<code>Person</code> 对象买票全价，<code>Student</code> 对象买票半价</p><p>那么在继承中要构成多态还有两个条件：</p><ol><li><p>必须通过父类的指针或者引用调用虚函数</p></li><li><p>被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写</p></li></ol><p>🔥<strong>值得注意的是：</strong> 多态构成条件缺一不可，如果多态产生问题，子类没有对某个方法进行重写，那么子类对象在调用该方法时，就会沿着继承链向上查找，找到父类中对应的方法并调用</p><h2 id="虚函数的重写"><a href="#虚函数的重写" class="headerlink" title="虚函数的重写"></a>虚函数的重写</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票全价&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票半价&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Person&amp; people)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">people.<span class="built_in">BuyTicket</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person Mike;</span><br><span class="line"><span class="built_in">Func</span>(Mike);</span><br><span class="line"></span><br><span class="line">Student Johnson;</span><br><span class="line"><span class="built_in">Func</span>(Johnson);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Person</code> 类的 <code>BuyTicket</code> 和 <code>Student</code> 类的 <code>BuyTicket</code> 构成重写</p><p><strong>虚函数的重写：</strong> 又叫覆盖，派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的<code>返回值类型</code>、<code>函数名字</code>、<code>参数列表</code>完全相同)，<code>称子类的虚函数重写了基类的虚函数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dbbee978e4b540ed9ca420eb9814f8f4.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong> 在重写父类虚函数时，子类的虚函数在不加 <code>virtual</code> 关键字时，虽然也可以构成重写(因为继承后父类的虚函数被继承下来了在子类依旧保持虚函数属性)，但是该种写法不是很规范，不建议这样使用</p><h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> A* <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> A; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> B; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>协变是重写的一种特殊情况，简单来说协变就是<code>派生类重写基类虚函数时，与基类虚函数返回值类型不同</code>，且要求父类虚函数类型和子类虚函数类型必须是<code>父子关系的引用和指针</code></p><p>🔥<strong>值得注意的是：</strong> 必须都是引用或者都是指针，不能一个是引用一个是指针</p><h3 id="析构函数的重写"><a href="#析构函数的重写" class="headerlink" title="析构函数的重写"></a>析构函数的重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Person</span>() </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Student</span>() </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Student()&quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person* p = <span class="keyword">new</span> Person;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里单纯讲解很难理解，所以以<code>一段代码场景+一些提问</code>来解析：</p><p>🚩<strong>析构函数+virtual，是不是虚函数重写？</strong></p><p>是，虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成 <code>destructor</code></p><p>🚩<strong>为什么要处理成统一名字？</strong></p><p>因为要让两个析构函数构成重写</p><p>🚩<strong>为什么要让他们构成重写？</strong></p><p>假设我们上面的这个代码没有加 <code>virtual</code>，运行代码如下：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6b86bc00be61484eb8bdb052af3860a4.png" alt="在这里插入图片描述"></p><p>观察可以发现子类 <code>Student</code> 部分没有得到释放，那么 <code>ptr</code> 指向的空间就会造成内存泄漏</p><p>根据 <code>C++</code> 内存管理学的知识可知</p><blockquote><p><code>p</code> -&gt; <code>destructor()</code> + <code>operator delete</code></p></blockquote><p>这里只能调用 <code>p</code> 这个类型的析构函数，但是我们为了实现能够调用指向空间的析构函数，期望是个多态调用，而不是普通调用，所以必须让这两个析构函数构成重写</p><p>🔥<strong>值得注意的是：</strong></p><ul><li><p>当使用父类指针指向子类对象，析构该指针时，<code>如果父类的析构函数不是虚函数</code>，那么将按指针本身的类型（即父类）来析构。这可能会导致子类部分的资源没有被正确释放，产生内存泄漏等问题</p></li><li><p><code>如果父类的析构函数是虚函数</code>，那么会按照指针实际指向的对象类型（即子类）来析构</p></li></ul><h2 id="override-和-final"><a href="#override-和-final" class="headerlink" title="override 和 final"></a>override 和 final</h2><p>🚩<strong>final：修饰虚函数，表示该虚函数不能再被重写</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> <span class="keyword">final</span> </span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Benz-舒适&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><p>假设有个 <code>A</code> 类和 <code>B</code> 类，不想让 <code>B</code> 类继承 <code>A</code> 类，那么可以写做：<code>class A final</code>，避免 <code>A</code> 类被继承，这是 <code>C++11</code> 才支持的，在这之前使用的是将 <code>A</code> 的构造函数私有化的方法</p><p>🚩<strong>override：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Benz-舒适&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Benz-舒适&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> :<span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Drive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BMW-操控&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Car* pBenz = <span class="keyword">new</span> Benz;</span><br><span class="line">pBenz-&gt;<span class="built_in">Drive</span>();<span class="comment">//访问Benz的虚函数</span></span><br><span class="line"></span><br><span class="line">Car* pBMW = <span class="keyword">new</span> BMW;</span><br><span class="line">pBMW-&gt;<span class="built_in">Drive</span>();<span class="comment">//访问BMW的虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在虚函数的后面写上 <code>= 0</code> ，则这个函数为<code>纯虚函数</code>，包含纯虚函数的类叫做<code>抽象类</code>（也叫<code>接口类</code>）</p><p>抽象类不能实例化出对象，即只要有纯虚函数就不能实例化出对象，派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承</p><p>🔥<strong>值得注意的是：</strong> </p><p>普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数</p><h1 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h1><h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>✏️<strong>以下我们通过多个例子进行详细解析：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sizeof(Base)是多少？</strong></p><blockquote><p>想必大部分人第一次做这道题都会觉得是 <code>1</code>，但运行后发现答案是 <code>8</code></p></blockquote><p>很奇怪，所以我们转到调试查看</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f667f0324bb949558803e534298e703c.png" alt="在这里插入图片描述"></p><p>发现除了 <code>_b</code> 以外，还多一个 <code>_vfptr</code> 放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针( <code>v</code> 代表 <code>virtual</code>，<code>f</code> 代表 <code>function</code>)</p><p>通常虚函数都被放在<code>代码段</code>，<code>_vfptr</code> 就是虚函数的地址，被存放在虚函数表，虚函数表放在<code>只读数据段</code>，也就是<code>常量区</code>，所以虚函数表本质上是个<code>函数指针数组</code>，虚函数表是在编译期间生成的</p><p>✏️<strong>那么多个虚函数是怎样实现多态的，举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::Func2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base::Func3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derive::Func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b;</span><br><span class="line">Derive d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是转到监视窗口调试查看：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2a39f3b2e76a48a390971567d043656c.png" alt="在这里插入图片描述"></p><p><strong>实际上虚函数表是按照一定规则实现的：</strong></p><ul><li><p>🚩<strong>复制基类虚表内容</strong><br>子类在生成虚表时，首先会把父类虚表中的内容完整地复制一份。这意味着子类虚表初始状态下包含了基类所有虚函数的地址，保证了子类对象可以调用父类的虚函数，这是因为子类继承了基类的接口，在某些情况下可能会使用到基类定义的虚函数实现</p></li><li><p>🚩<strong>重写虚函数的替换</strong><br>如果子类对父类中的某个虚函数进行了重写，那么在子类虚表中，对应父类虚函数的地址会被替换为子类自己重写后的虚函数地址。当通过父类指针或引用调用该虚函数时，程序会根据对象的实际类型（即子类类型），从子类虚表中找到并重写后的虚函数来执行，从而实现多态性</p></li><li><p>🚩<strong>新增虚函数的添加</strong><br>对于子类自己新定义的虚函数，会按照它们在子类中声明的先后顺序依次添加到子类虚表的末尾。这些新增的虚函数是子类特有的，父类中并不存在。因此，它们会被单独添加到虚表中，以确保子类对象能够调用这些专属的虚函数</p></li></ul><p>🔥<strong>值得注意的是：</strong> </p><ul><li>父类 <code>b</code> 对象和子类 <code>d</code> 对象虚表是不一样的，这里我们发现 <code>Func1</code> 完成了重写，所以 <code>d</code> 的虚表中存的是重写的 <code>Derive::Func1</code>，所以虚函数的重写也叫作覆盖，覆盖就是指虚表中虚函数的覆盖。<code>重写</code>是语法的叫法，<code>覆盖</code>是原理层的叫法</li><li><code>Func2</code> 继承下来后是虚函数，所以放进了虚表，<code>Func3</code> 也继承下来了，但是不是虚函数，所以不会放进虚表</li><li>虚函数表本质是一个存虚函数指针的指针数组，一般情况这个数组最后面放了一个 <code>nullptr</code></li><li>一个类的不同对象共享同一个类的虚表</li></ul><h2 id="多态原理实现"><a href="#多态原理实现" class="headerlink" title="多态原理实现"></a>多态原理实现</h2><p>那么回归到多态的实现条件：</p><ol><li><p>必须通过父类的指针或者引用调用虚函数</p></li><li><p>被调用的函数必须是虚函数，且子类必须对父类的虚函数进行重写</p></li></ol><p><strong>我们可以提出两个问题：</strong></p><p>🚩<strong>为什么不是子类指针或者引用？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    Animal* animalPtr = &amp;dog;  <span class="comment">// 父类指针指向子类对象</span></span><br><span class="line">    animalPtr-&gt;<span class="built_in">speak</span>();  <span class="comment">// 运行时根据实际对象类型调用Dog的speak函数</span></span><br><span class="line"></span><br><span class="line">    Cat cat;</span><br><span class="line">    Animal&amp; animalRef = cat;  <span class="comment">// 父类引用绑定到子类对象</span></span><br><span class="line">    animalRef.<span class="built_in">speak</span>();  <span class="comment">// 运行时根据实际对象类型调用Cat的speak函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的子类 <code>Dog</code> 和 <code>Cat</code> 都继承于父类 <code>Animal</code>，就是因为是父类的指针或引用才能想调用哪个子类都行</p><p>如果是子类的指针或引用，比如有个 <code>Dog</code> 类的指针 <code>Dog* dogPtr</code>，它只能指向 <code>Dog</code> 类对象，没办法指向 <code>Cat</code> 类对象。如果想用它去调用 <code>speak</code> 函数，不管怎样都是调用 <code>Dog</code> 类的 <code>speak</code> 函数，不能根据实际对象类型（<code>Cat</code> 或其他子类）来动态调用不同的 <code>speak</code> 函数，就实现不了多态了</p><p>🚩<strong>为什么不能是父类对象？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票-全价&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;买票-半价&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person ps;</span><br><span class="line">Student st;</span><br><span class="line">ps = st;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是使用对象，而不是指针或引用，子类中特有的成员变量和函数将被截断，丢失子类的特性</p><p>而使用父类指针或引用指向子类对象时，不会发生切片，能够完整保留子类对象的所有信息，从而可以访问子类重写的虚函数以实现多态</p><p>🔥<strong>值得注意的是：</strong> 子类对象赋值给父类对象的时候，不会拷贝虚函数表过去，如果拷贝了，那么父类虚函数表中的虚函数就变成子类虚函数了，就失去多态的意义了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2dd9713af51a46e4b5e1f93aebedaa1d.png" alt="在这里插入图片描述"></p><p><strong>所以总结：</strong> 满足多态以后的函数调用，不是在编译时确定的，是运行起来以后到对象的中去找的。不满足多态的函数调用时编译时确认好的</p><h2 id="动态绑定与静态绑定"><a href="#动态绑定与静态绑定" class="headerlink" title="动态绑定与静态绑定"></a>动态绑定与静态绑定</h2><p><strong>静态绑定：</strong> 又称为前期绑定(早绑定)，在程序编译期间确定了程序的行为，也称为静态多态，比如：函数重载</p><p><strong>动态绑定：</strong> 又称后期绑定(晚绑定)，是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为动态多态</p><h1 id="继承和多态常见的面试问题"><a href="#继承和多态常见的面试问题" class="headerlink" title="继承和多态常见的面试问题"></a>继承和多态常见的面试问题</h1><ol><li>下面哪种面向对象的方法可以让你变得富有( )<br><code>A</code>: 继承<br><code>B</code>: 封装<br><code>C</code>: 多态<br><code>D</code>: 抽象</li><li>( )是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关，<br>而对方法的调用则可以关联于具体的对象。<br><code>A</code>: 继承<br><code>B</code>: 模板<br><code>C</code>: 对象的自身引用<br><code>D</code>: 动态绑定</li><li>面向对象设计中的继承和组合，下面说法错误的是？（）<br><code>A</code>：继承允许我们覆盖重写父类的实现细节，父类的实现对于子类是可见的，是一种静态复用，也称为白盒复用<br><code>B</code>：组合的对象不需要关心各自的实现细节，之间的关系是在运行时候才确定的，是一种动态复用，也称为黑盒复用<br><code>C</code>：优先使用继承，而不是组合，是面向对象设计的第二原则<br><code>D</code>：继承可以使子类能自动继承父类的接口，但在设计模式中认为这是一种破坏了父类的封装性的表现</li><li>以下关于纯虚函数的说法,正确的是( )<br><code>A</code>：声明纯虚函数的类不能实例化对象<br><code>B</code>：声明纯虚函数的类是虚基类<br><code>C</code>：子类必须实现基类的纯虚函数<br><code>D</code>：纯虚函数必须是空函数</li><li>关于虚函数的描述正确的是( )<br><code>A</code>：派生类的虚函数与基类的虚函数具有不同的参数个数和类型<br><code>B</code>：内联函数不能是虚函数<br><code>C</code>：派生类必须重新定义基类的虚函数<br><code>D</code>：虚函数可以是一个static型的函数 </li><li>关于虚表说法正确的是（ ）<br><code>A</code>：一个类只能有一张虚表<br><code>B</code>：基类中有虚函数，如果子类中没有重写基类的虚函数，此时子类与基类共用同一张虚表<br><code>C</code>：虚表是在运行期间动态生成的<br><code>D</code>：一个类的不同对象共享该类的虚表</li><li>假设A类中有虚函数，B继承自A，B重写A中的虚函数，也没有定义任何虚函数，则（ ）<br><code>A</code>：A类对象的前4个字节存储虚表地址，B类对象前4个字节不是虚表地址<br><code>B</code>：A类对象和B类对象前4个字节存储的都是虚基表的地址<br><code>C</code>：A类对象和B类对象前4个字节存储的虚表地址相同<br><code>D</code>：A类和B类虚表中虚函数个数相同，但A类和B类使用的不是同一张虚表</li></ol><blockquote><p>参考答案：1. <code>A</code>   2. <code>D</code>   3. <code>C</code>   4. <code>A</code>   5. <code>B</code>  6. <code>D</code>  7. <code>D</code></p></blockquote><ol start="8"><li>下面程序输出结果是什么? （）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> <span class="type">char</span>* s)</span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">A</span>() </span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span><br><span class="line">:<span class="built_in">A</span>(s1) </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">C</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2)</span><br><span class="line">:<span class="built_in">A</span>(s1) </span><br><span class="line">&#123; </span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">D</span>(<span class="type">const</span> <span class="type">char</span>* s1, <span class="type">const</span> <span class="type">char</span>* s2, <span class="type">const</span> <span class="type">char</span>* s3, <span class="type">const</span> <span class="type">char</span>* s4)</span><br><span class="line">:<span class="built_in">B</span>(s1, s2)</span><br><span class="line">, <span class="built_in">C</span>(s1, s3)</span><br><span class="line">, <span class="built_in">A</span>(s1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">D* p = <span class="keyword">new</span> <span class="built_in">D</span>(<span class="string">&quot;class A&quot;</span>, <span class="string">&quot;class B&quot;</span>, <span class="string">&quot;class C&quot;</span>, <span class="string">&quot;class D&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>A</code>：class A class B class C class D <code>B</code>：class D class B class C class A<br><code>C</code>：class D class C class B class A <code>D</code>：class A class C class B class D</p></blockquote><p><strong>解析：</strong> 这是个菱形虚拟继承，所以 <code>A</code> 只会被调用一次，<code>D</code> 类里的初始化列表是按声明的顺序来初始化的，所以按 <code>ABCD</code> 的顺序，因此答案选 <code>A</code> </p><ol start="9"><li>多继承中指针偏移问题？下面说法正确的是( )</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b1; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b2; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> _d; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derive d;</span><br><span class="line">Base1* p1 = &amp;d;</span><br><span class="line">Base2* p2 = &amp;d;</span><br><span class="line">Derive* p3 = &amp;d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>A</code>：p1 &#x3D;&#x3D; p2 &#x3D;&#x3D; p3 <code>B</code>：p1 &lt; p2 &lt; p3 <code>C</code>：p1 &#x3D;&#x3D; p3 !&#x3D; p2 <code>D</code>：p1 !&#x3D; p2 !&#x3D; p3</p></blockquote><p><strong>解析：</strong> 画图理解即可，选 <code>C</code><br><img src="https://i-blog.csdnimg.cn/direct/d77f9e16c0594efcb51765b0ed2aba0f.png" alt="在这里插入图片描述"></p><ol start="10"><li>以下程序输出结果是什么（）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">1</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">func</span>(); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B* p = <span class="keyword">new</span> B;</span><br><span class="line">p-&gt;<span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>A</code>: A-&gt;0 <code>B</code>: B-&gt;1 <code>C</code>: A-&gt;1 <code>D</code>: B-&gt;0 <code>E</code>: 编译出错 <code>F</code>: 以上都不正确</p></blockquote><p><strong>解析：</strong> 这题绝大多数人肯定会选到 <code>D</code>，这题的知识点确实比较偏，首先我们要知道多态重写的是实现，即只有 <code>&#123;&#125;</code> 内的内容是多态的，实际上子类的函数头其实相当于是从父类拷贝过来的，因此函数头的内容还是调用的父类的，所以答案选 <code>B</code></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/36334dba41264ebfaf00ebf05d8d75c1.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类间的 “接力棒“ 传递：继承（下）</title>
      <link href="/2025/04/07/CPP%E8%BF%9B%E9%98%B6/%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/04/07/CPP%E8%BF%9B%E9%98%B6/%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇接着补充继承方面的内容，同时本篇的菱形继承尤为重要</p><h1 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s._stuNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"><span class="built_in">Display</span>(p, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元关系不能继承，也就是说父类友元不能访问子类私有和保护成员。想要子类也能访问友元，就必须在子类也加上友元</p><p>🔥<strong>值得注意的是：</strong></p><p><code>class Student;</code> 这一前置声明是为了在 <code>Person</code> 类中声明 <code>Display</code> 函数为友元函数，此函数的参数包含 <code>const Student&amp; s</code>，由于 <code>Person</code> 类的定义处于 <code>Student</code> 类之前，编译器在处理 <code>Person</code> 类定义时还未看到 <code>Student</code> 类的完整定义，所以使用前置声明来告知编译器 <code>Student</code> 是一个类，这样就能在 <code>Person</code> 类中使用 <code>Student</code> 类型的引用</p><h1 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;p._name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;s._name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;Person::_count &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;Student::_count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接说结论：<code>父类定义的静态成员可以继承给子类，不过继承的是使用权</code></p><p>普通变量继承到子类的时候，其实是复制一份过去的，所以一样的变量在子类父类其实是一式两份的，但是静态成员不一样，在子类和父类里是同一份</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/41329c0399de47769063a642a938044b.png" alt="在这里插入图片描述"></p><h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><p>我们要知道 <code>C++</code> 的继承方式有几种情况：</p><p>🚩<strong>单继承：一个子类只有一个直接父类时称这个继承关系为单继承</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/24f821a385684c76a6cb04765b24003c.png" alt="在这里插入图片描述"></p><p>🚩<strong>多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc5da7a6c0534e02a1f6512b83bbf53c.png" alt="在这里插入图片描述"></p><p>🚩<strong>菱形继承：菱形继承是多继承的一种特殊情况</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3b45494e5b3640c3a5c966bfc3197d23.png" alt="在这里插入图片描述"></p><p>菱形继承可以说是 <code>C++</code> 刚出继承的时候的一个失误，<code>Java</code> 就没有多继承这一说法，为的就是避免菱形继承的出现</p><p><strong>为什么菱形继承会出问题呢？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7c97c3c21a3e42cb9d2858d9e8285775.png" alt="在这里插入图片描述"><br><code>Assistant</code> 继承了 <code>Teacher</code> 和 <code>Student</code> 本来是没什么问题的，出问题的点就在于 <code>Teacher</code> 和 <code>Student</code> 都继承了 <code>Person</code> ，这就导致 <code>Assistant</code> 里面会有两份 <code>Person</code> 的成员，导致出现数据冗余的问题</p><p>✏️假设在 <code>Assistant</code> 中访问 <code>Person</code> 的成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _majorCourse;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Assistant a;</span><br><span class="line">a._name = <span class="string">&quot;peter&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对象 <code>a</code> 访问 <code>_name</code> 就不知道要找哪个 <code>Person</code> 的 <code>_name</code>，这样会有二义性无法明确知道访问的是哪一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.Student::_name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">a.Teacher::_name = <span class="string">&quot;yyy&quot;</span>;</span><br></pre></td></tr></table></figure><p>因此需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</p><p><strong>以下是对菱形继承的详细分析及解决方案：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">D d;</span><br><span class="line">d.B::_a = <span class="number">1</span>;</span><br><span class="line">d.C::_a = <span class="number">2</span>;</span><br><span class="line">d._b = <span class="number">3</span>;</span><br><span class="line">d._c = <span class="number">4</span>;</span><br><span class="line">d._d = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个典型的菱形继承的例子，其实这些继承的变量是连续存储的，我们可以调出监视窗口里的内存查看</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/006d8db37cd640b3a16b05b16a5f4c6c.png" alt="在这里插入图片描述"></p><p>在内存里确实是在 <code>B</code> 和 <code>C</code> 中存在两个 <code>_a</code></p><p>✏️<strong>解决方案：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">D d;</span><br><span class="line">d.B::_a = <span class="number">1</span>;</span><br><span class="line">d.C::_a = <span class="number">2</span>;</span><br><span class="line">d._b = <span class="number">3</span>;</span><br><span class="line">d._c = <span class="number">4</span>;</span><br><span class="line">d._d = <span class="number">5</span>;</span><br><span class="line">d._a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++规定，把 <code>virtual</code> 关键字加在从共同基类直接派生的类前</p><p><code>virtual</code> 关键字使得在继承体系中，共同的基类在派生类对象中<code>只存在一份共享的子对象</code>，而不是为每个直接继承的基类都创建一份副本</p><p><strong>同样的转到内存中查看：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8c73ab5c909e45e185dd2fcf6925da9e.png" alt="在这里插入图片描述"></p><p>发现 <code>A</code> 的内存被额外找了一块区域进行存储，变成共享的了，那 <code>B</code> 和 <code>C</code> 中原来存储 <code>A</code> 的地方，根据地址找到对应的值，发现对应回原来的表，其实是与这块共享区域的偏移量</p><p>这里是通过了 <code>B</code> 和 <code>C</code> 的两个指针，指向的一张表。这两个指针叫虚基表指针，这两个表叫虚基表，虚基表就是寻找基类偏移量的表。虚基表中存的偏移量，通过偏移量可以找到 <code>A</code></p><p>🔥<strong>值得注意的是：</strong> </p><ul><li>最右边的图，有具体值的旁边的 <code>00000000</code> ，其实是留给 <code>D</code> 类型其它对象的</li><li>像 <code>d._a = 1</code> 这样子，按照声明顺序就可以直接找到 <code>_a</code> 了，不需要用到偏移量。像 <code>B* pb = &amp;d；pb-&gt;_a = 1；</code>这样子，因为 <code>D</code> 这个子类赋值给 <code>B</code> 类这个父类，需要切割，<code>B</code> 并不是按照声明顺序这样能直接找到，所以需要依靠偏移量才能找到 <code>B</code> 的 <code>_a</code></li><li>其实不止是 <code>D</code> 类，像 <code>B</code> 类和 <code>C</code> 类的内存存储方式、偏移量查找方式和 <code>D</code> 类是一样的</li></ul><p><strong>总的来说：</strong> 比如想要查找 <code>_a</code> 这块共享区域，就根据当前对象的虚基表指针，找到偏移量，然后回到虚基表去找到 <code>_a</code> 这块共享区域</p><h1 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h1><ul><li><code>public</code> 继承是一种 <code>is-a</code> 的关系。也就是说每个派生类对象都是一个基类对象</li><li>组合是一种 <code>has-a</code> 的关系。假设 <code>B</code> 组合了 <code>A</code>，每个 <code>B</code> 对象中都有一个 <code>A</code> 对象</li><li><a href="https://www.cnblogs.com/nexiyi/archive/2013/06/16/3138568.html">优先使用对象组合，而不是类继承</a> </li><li>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(<code>white-box reuse</code>)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高</li><li>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(<code>black-box reuse</code>)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装</li><li>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car和BMW Car和Benz构成is-a的关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _colour = <span class="string">&quot;白色&quot;</span>; <span class="comment">// 颜色</span></span><br><span class="line">string _num = <span class="string">&quot;陕ABIT00&quot;</span>; <span class="comment">// 车牌号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;好开-操控&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Benz</span> : <span class="keyword">public</span> Car &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Drive</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;好坐-舒适&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tire和Car构成has-a的关系</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tire</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _brand = <span class="string">&quot;Michelin&quot;</span>;  <span class="comment">// 品牌</span></span><br><span class="line"><span class="type">size_t</span> _size = <span class="number">17</span>;         <span class="comment">// 尺寸</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _colour = <span class="string">&quot;白色&quot;</span>; <span class="comment">// 颜色</span></span><br><span class="line">string _num = <span class="string">&quot;陕ABIT00&quot;</span>; <span class="comment">// 车牌号</span></span><br><span class="line">Tire <span class="type">_t</span>; <span class="comment">// 轮胎</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bc7e596553bc463ba55252edacf9acd4.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类间的 “接力棒“ 传递：继承（上）</title>
      <link href="/2025/04/03/CPP%E8%BF%9B%E9%98%B6/%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/04/03/CPP%E8%BF%9B%E9%98%B6/%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇将开启 <code>C++</code> 三大特性中的继承篇章，继承是一种派生类能够复用基类的代码，同时还能添加自己特有的属性和方法，或者对基类的方法进行重写。这种机制可以提高代码的复用性和可维护性</p><h1 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a>什么是继承？</h1><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><blockquote><p><code>继承(inheritance)</code>机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称<code>派生类</code>。继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用</p></blockquote><p>✏️<strong>举个例子：</strong></p><ul><li><strong>学生和老师都有的共同点(Person)：</strong> 年龄，性别，名字等</li><li><strong>学生特有的(Student)：</strong> 学号，专业，宿舍号</li><li><strong>老师特有的(Teacher)：</strong> 职工号，职称</li></ul><p>共同点就相当于一个基底，称他为<code>基类</code>或者<code>父类</code>，在基类的基础上拓展出来的各种各样的角色称他为<code>派生类</code>或者<code>子类</code>，这样一个拓展的过程就叫<code>继承</code>，所以继承的本质是一种复用</p><h2 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a>继承的语法</h2><p><code>Person</code> 是父类，也称作基类。<code>Student</code> 是子类，也称作派生类</p><p><strong>其语法为：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c74008baaab8490ebc0aaf94110545af.png" alt="在这里插入图片描述"></p><p>表示 <code>Student</code> 是 <code>public</code> 继承于 <code>Person</code>，那么这个继承方式和类内部的 <code>public</code> 有何区别？</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/48c7e95887c64255b4facc3d7b1684f6.png" alt="在这里插入图片描述"></p><p>🚩类内部的 <code>public</code> 这一类的叫访问限定符，表示访问时类内部的变量函数等是以何种方式被访问，只使用访问限定符时 <code>private</code> 和 <code>protected</code> 是没有区别的</p><ul><li><code>private</code>：成员被声明为 <code>private</code> 后，只能在类的内部被访问和调用，类外部及派生类都无法直接访问</li><li><code>protected</code>：类内部可以访问，类的派生类也可以访问，但类外部不能访问</li></ul><p>🚩派生类后跟的 <code>public</code> 这一类叫继承方式</p><p>🚩那么继承最重要的就是<code>访问限定符和继承方式的组合</code>，组合起来决定了<code>基类成员在派生类中的访问属性</code></p><table><thead><tr><th>类成员&#x2F;继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td><strong>基类的public成员</strong></td><td>派生类的 <code>public</code> 成员</td><td>派生类的 <code>protected</code> 成员</td><td>派生类的 <code>private</code> 成员</td></tr><tr><td><strong>基类的protected成员</strong></td><td>派生类的 <code>protected</code> 成员</td><td>派生类的 <code>protected</code> 成员</td><td>派生类的 <code>private</code> 成员</td></tr><tr><td><strong>基类的private成员</strong></td><td>在派生类中不可见</td><td>在派生类中不可见</td><td>在派生类中不可见</td></tr></tbody></table><p>实际上面的表格我们进行一下总结会发现，<code>public</code> &gt; <code>protected</code> &gt; <code>private</code>，基类的其他成员在子类的访问方式 &#x3D;&#x3D; <code>Min</code>(成员在基类的访问限定符，继承方式)，特别的基类的私有成员在子类都是不可见，而不是 <code>private</code></p><p>🔥<strong>值得注意的是：</strong></p><ol><li><p>基类 <code>private</code> 成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面都不能去访问它</p></li><li><p>基类 <code>private</code> 成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为 <code>protected</code>。可以看出保护成员限定符是因继承才出的</p></li><li><p>使用关键字 <code>class</code> 时默认的继承方式是 <code>private</code>，使用 <code>struct</code> 时默认的继承方式是<code>public</code>，不过最好显示的写出继承方式</p></li><li><p>在实际运用中一般使用都是 <code>public</code> 继承，几乎很少使用 <code>protetced</code> &#x2F; <code>private</code> 继承，也不提倡使用 <code>protetced</code> &#x2F; <code>private</code> 继承，因为 <code>protetced</code> &#x2F; <code>private</code> 继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强</p></li></ol><h1 id="基类和派生类的转换机制"><a href="#基类和派生类的转换机制" class="headerlink" title="基类和派生类的转换机制"></a>基类和派生类的转换机制</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/874a94cbec104ebb89f9ceed8731c875.png" alt="在这里插入图片描述"></p><p><code>Student</code> 是子类，<code>Person</code> 是父类</p><p>因为子类包含了父类的内容，且子类其实是父类的一种特殊类型，存在天然的<code>类型兼容性</code>，所以只能子类赋值给父类，且中间不存在类型转换，是以<code>切割</code> &#x2F; <code>切片</code>的形式</p><p><strong>为什么说不存在类型转换？举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Parent</span>()</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Child</span>()</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Child child;</span><br><span class="line">    Parent parent;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Child: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(child) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Parent before assignment: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(parent) &lt;&lt; endl;</span><br><span class="line">    parent = child;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Parent after assignment: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(parent) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>sizeof</code> 运算符获取父类和子类对象的大小，然后将子类对象赋值给父类对象后，再获取父类对象的大小，比较赋值前后父类对象大小是否发生变化，如果是切片，父类对象大小不会改变，因为只是复制了子类中父类部分的成员</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/43e6bef2fbb14a2b8eed949a669fd278.png" alt="在这里插入图片描述"></p><p>🔥<strong>值得注意的是：</strong></p><p>基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用<code>RTTI(Run-Time Type Information)</code> 的 <code>dynamic_cast</code> 来进行识别后进行安全转换（ps：这个我们后面再讲解，这里先了解一下）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line">string _sex;  <span class="comment">// 性别</span></span><br><span class="line"><span class="type">int</span> _age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _No; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student sobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line">Person pobj = sobj;</span><br><span class="line">Person* pp = &amp;sobj;</span><br><span class="line">Person&amp; rp = sobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.基类对象不能赋值给派生类对象</span></span><br><span class="line">sobj = pobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class="line">pp = &amp;sobj</span><br><span class="line">Student * ps1 = (Student*)pp; <span class="comment">// 这种情况转换时可以的。</span></span><br><span class="line">ps1-&gt;_No = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">pp = &amp;pobj;</span><br><span class="line">Student* ps2 = (Student*)pp; <span class="comment">// 这种情况转换时虽然可以，但是会存在越界访问的问题</span></span><br><span class="line">ps2-&gt;_No = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第三种情况的第二种，<code>pp</code> 是 <code>Person</code> 类型的指针，它指向一个 <code>Person</code> 对象。接着把 <code>pp</code> 强制转换为 <code>Student*</code> 类型并赋值给 <code>ps2</code>。虽然语法上允许这样转换，但实际上 <code>pobj</code> 只是 <code>Person</code> 对象，它并没有 <code>_No</code> 这个成员变量。当执行 <code>ps2</code>-&gt;<code>_No</code> &#x3D; <code>10</code>; 时，程序会尝试在 <code>pobj</code> 对象的内存区域之后写入 <code>_No</code> 的值，这就造成了越界访问，可能会改写其他重要的数据，从而引发未定义行为</p><h1 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h1><p>在继承体系中基类和派生类都有独立的作用域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num = <span class="number">111</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num = <span class="number">999</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里调用 <code>Print</code> 输出的 <code>_num</code> 是多少？根据前面所学有关作用域的知识可知，编译器遵守就近原则，这里优先输出子类类域里的 <code>_num</code></p><p>如果在 <code>Print</code> 局部域里也有 <code>_num</code> 的话，就优先输出局部域 <code>_num</code>；如果想要输出父类的<code>_num</code> 的话，就需要指定类域（<code>Person::_num</code>）</p><p>这里 <code>C++</code> 对这种情况取了个名字叫隐藏&#x2F;重定义：子类和父类有同名成员，子类的成员隐藏了父类的成员（<code>只要函数名相同就构成重定义</code>）</p><p>具体作用域分析可以回顾前文：</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/144021581">C++命运石之门代码抉择：C++入门（上）</a></p></blockquote><p>🔥<strong>值得注意的是：</strong> 假设子类有个 <code>func(int i)</code>，父类有个 <code>func()</code>，这里构成的是重定义，而不是重载，因为<code>重载的前提条件是在同一作用域</code>，同一作用域下就需要根据函数名修饰规则进行区分，虽然只要函数名相同就会进行修饰，但是继承的这种情况根据域的不同就能进行区分了，实际上函数名修饰规则起不到很大作用，因此是重定义，而不是重载</p><h1 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5b4a50bf7e1f4926903089da1026cd87.png" alt="在这里插入图片描述"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;peter&quot;</span>)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;张三&quot;</span>, <span class="type">int</span> id = <span class="number">0</span>)</span><br><span class="line">:<span class="built_in">Person</span>(name)</span><br><span class="line">,_id(id)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类的构造函数只能构造自己的变量，想要构造继承来的父类变量，必须像 <code>Person(name)</code> 这样显示调用父类的构造函数来调用</p><p>🔥<strong>值得注意的是：</strong></p><ul><li>也可以不写 <code>Person(name)</code> 来显示调用，那么就需要调用父类的默认构造函数，即父类的构造函数必须有缺省参数</li><li>派生类初始化列表先初始化父类，再初始化子类</li></ul><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;peter&quot;</span>)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">: _name(p._name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person operator=(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">_name = p._name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;张三&quot;</span>, <span class="type">int</span> id = <span class="number">0</span>)</span><br><span class="line">:<span class="built_in">Person</span>(name)</span><br><span class="line">, _id(id)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)</span><br><span class="line">: <span class="built_in">Person</span>(s)</span><br><span class="line">, _id(s._id)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student(const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Student&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student&amp; operator= (const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">Person::<span class="keyword">operator</span> =(s);</span><br><span class="line">_id = s._id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，拷贝构造的初始化顺序及初始化机制和构造函数基本一致</p><p><strong>但是拷贝构造是如何传Person的对象来拷贝构造的呢？</strong></p><p>其实直接传子类对象即可，因为前面说过，<code>子类对象可以赋值给父类引用</code>，直接切割就行了</p><p>🔥<strong>值得注意的是：</strong></p><ul><li>当不显式写 <code>Person(s)</code> 时，会调用父类的构造函数初始化父类变量</li><li><code>Person::operator =(s)</code> 的 <code>Person::</code> 必须写，不然根据就近原则，这里构成重定义，子类 <code>operator=</code> 会一直调用自己，造成死循环</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">Person::~<span class="built_in">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据初学经验，一般析构函数我们会写成这样，保证父类和子类都能被析构，这里显式调用父类析构要加 <code>Person::</code> 是因为在底层，父类和子类的析构都会被统一处理成 <code>destructor</code> 构成重定义（<code>这部分会在多态部分详细解释</code>）</p><p>但其实这种调用方法是错误的，我们不应该显式调用父类析构，父类析构其实是会被自动调用的，因为必须保证先子后父的调用。如果先析构了父类，那么此时的子类额外的部分可能处于不一致或未定义的状态</p><p>✏️<strong>比如：</strong> 有可能先把父类析构了，但是子类还在访问父类的内容；但是把子类先析构了，父类是不会去访问子类的内容的，就不会造成访问未定义的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Student</span>()</span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;~Student()&quot;</span> &lt;&lt;endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以这里不需要显式调用，子类完成析构之后就会自动析构父类</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0a058046d3f04ce1a2e004f7efa9755a.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++底层学习精进：模板进阶</title>
      <link href="/2025/03/31/CPP%E5%88%9D%E9%98%B6/%E6%A8%A1%E6%9D%BF%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/03/31/CPP%E5%88%9D%E9%98%B6/%E6%A8%A1%E6%9D%BF%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>本篇是对模板初阶的补充说明</p><h1 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h1><p>在<a href="https://blog.csdn.net/Zero_VPN/article/details/145404914?spm=1001.2014.3001.5502">模板初阶</a>部分就介绍过<code>类型形参</code></p><p>即出现在模板参数列表中，跟在 <code>class</code> 或者 <code>typename</code> 之类的参数类型名称</p><p>🔥<strong>值得注意的是：</strong> 这里进行一点之前的补充，在模板初阶部分我们对 <code>class</code> 和<code>typename</code> 进行了介绍，一般这两个参数类型是可以互相替换的，没啥区别，但是有一个<strong>特殊情况：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> Container&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Container::const_iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们用模板参数来写 <code>vector</code> 数组的遍历的时候，<code>Container::const_iterator</code> 包含模板参数没有实例化，编译器无法确定 <code>const_iterator</code> 是个变量还是类型</p><p>因此应该写成 <code>typename Container::const_iterator</code>，<code>typename</code> 告诉编译器这里是类型，等模板实例化再去找</p><hr><p>为了满足某些特定情况下的需求，便有了<code>非类型模板参数</code></p><p>✏️<strong>例如：</strong> 开辟一个静态数组时，有可能大了，也有可能小了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bite</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义一个模板类型的静态数组</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N = <span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">class</span> array</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> _array[index]; &#125;</span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index)<span class="type">const</span> &#123; <span class="keyword">return</span> _array[index]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == _size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T _array[N];</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>非类型形参</code>，就是用一个常量作为类(函数)模板的一个参数，在类(函数)模板中可将该参数<code>当成常量来使用</code>，像 <code>array&lt;int, 10&gt; a1</code> 这样实例化，</p><p>🔥<strong>值得注意的是：</strong> 为非类型模板参数必须是<code>整型</code>，且非类型的模板参数必须在编译期就能确认结果，一般遵循按需编译，即只有按需编译过的函数才会去检查该函数的语法语义错误</p><h1 id="模板的特化"><a href="#模板的特化" class="headerlink" title="模板的特化"></a>模板的特化</h1><p>模板特化一般是在特殊情况下使用的，以下将<strong>结合具体例子说明：</strong></p><h2 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h2><p>通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，需要特殊处理，比如：<strong>实现了一个专门用来进行小于比较的函数模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板 -- 参数匹配</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Less</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl; <span class="comment">// 可以比较，结果正确</span></span><br><span class="line"><span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2022</span>, <span class="number">7</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2022</span>, <span class="number">7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Less</span>(d1, d2) &lt;&lt; endl; <span class="comment">// 可以比较，结果正确</span></span><br><span class="line">Date* p1 = &amp;d1;</span><br><span class="line">Date* p2 = &amp;d2;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Less</span>(p1, p2) &lt;&lt; endl; <span class="comment">// 可以比较，结果错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个比较，这里可能是为了存储方便，我们具体是想要比较 <code>Date*</code> 指向的内容，但是按照正常模板他只会比较地址的大小，此时就需要为这种特殊情况进行模板特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对Less函数模板进行特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">Less</span>&lt;Date*&gt;(Date* left, Date* right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *left &lt; *right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>必须要先有一个基础的函数模板</li><li>关键字 <code>template</code> 后面接一对空的尖括号 <code>&lt;&gt;</code></li><li>函数名后跟一对尖括号，尖括号中指定需要特化的类型</li><li>函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误</li></ol><p><strong>一般情况下如果函数模板遇到不能处理或者处理有误的类型，或者只是使用一两次并不频繁的话，为了实现简单通常都是将该函数直接给出</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(Date* left, Date* right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *left &lt; *right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该种实现简单明了，代码的可读性高，容易书写，因为对于一些参数类型复杂的函数模板，特化时特别给出，因此函数模板不建议特化                                    </p><h2 id="类模板特化"><a href="#类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h2><h3 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h3><p>全特化就是将模板参数列表中的所有参数确定化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 _d1;</span><br><span class="line">T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _d1;</span><br><span class="line"><span class="type">char</span> _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Data&lt;<span class="type">int</span>, <span class="type">int</span>&gt; d1;</span><br><span class="line">Data&lt;<span class="type">int</span>, <span class="type">char</span>&gt; d2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h3><p>还是上面的例子，如果我们只是想将<strong>部分模板参数</strong>进行特化呢？</p><p>🚩<strong>部分特化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Data&lt;T1, int&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 _d1;</span><br><span class="line"><span class="type">int</span> _d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🚩<strong>对参数进一步限制</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Data&lt;T1*, T2*&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 _d1;</span><br><span class="line">T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个参数偏特化为引用类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1&amp;, T2&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> T2&amp; d2)</span><br><span class="line">: _d1(d1)</span><br><span class="line">, _d2(d2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Data&lt;T1&amp;, T2&amp;&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> T1&amp; _d1;</span><br><span class="line"><span class="type">const</span> T2&amp; _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Data&lt;<span class="type">double</span>, <span class="type">int</span>&gt; d1; <span class="comment">// 调用特化的int版本</span></span><br><span class="line">Data&lt;<span class="type">int</span>, <span class="type">double</span>&gt; d2; <span class="comment">// 调用基础的模板 </span></span><br><span class="line">Data&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; d3; <span class="comment">// 调用特化的指针版本</span></span><br><span class="line"><span class="function">Data&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&amp;&gt; <span class="title">d4</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// 调用特化的指针版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板分离编译"><a href="#模板分离编译" class="headerlink" title="模板分离编译"></a>模板分离编译</h1><p>模板分离编译简单来说就是声明和定义分离</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/255b3907691540f199b13631298e3c0b.png" alt="在这里插入图片描述"></p><p>通常是在链接阶段会出现问题，以前在还没有涉及模板的时候，在声明和定义分离时，因为调用的函数有具体的代码所以能够通过生成的地址找到定义；当前涉及模板后，因为模板没有实例化，所以不会生成地址，即使你定义了，声明也无法找到对应的具体代码，导致连接错误</p><p>💻<strong>解决方法</strong></p><ol><li>将声明和定义放到一个文件 <code>xxx.hpp</code> 里面，或者 <code>xxx.h</code> 其实也是可以的，推荐使用这种</li><li>模板定义的位置显式实例化。这种方法不实用，不推荐使用</li></ol><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3c0827b756b24fa1ae8c53e7a19c8564.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：优先级队列priority_queue &amp;&amp; 双端队列deque</title>
      <link href="/2025/03/27/CPP%E5%88%9D%E9%98%B6/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority_queue%20&amp;&amp;%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/"/>
      <url>/2025/03/27/CPP%E5%88%9D%E9%98%B6/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97priority_queue%20&amp;&amp;%20%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97deque/</url>
      
        <content type="html"><![CDATA[<p>本篇是 <code>STL</code> 库专题之 <code>priority_queue</code> 和 <code>deque</code>，书接上文</p><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/db4feb9e64a74c519478d83acfa82fd7.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/queue/priority_queue/?kw=priority_queue">priority_queue</a> 的主要特征可总结为：</p><ol><li>优先队列是一种容器适配器，根据严格的弱排序标准，它的第一个元素总是它所包含的元素中最大的，简单来说就是<code>取出元素的顺序默认是从大到小的</code></li><li>此上下文<code>类似于堆</code>，在堆中可以随时插入元素，并且只能检索最大堆元素(优先队列中位于顶部的元素)</li><li>优先队列被实现为容器适配器，容器适配器即将特定容器类封装作为其底层容器类，<code>queue</code> 提供一组特定的成员函数来访问其元素。元素从特定容器的“尾部”弹出，其称为优先队列的顶部</li><li>底层容器可以是任何标准容器类模板，也可以是其他特定设计的容器类。容器应该可以通过<code>随机访问迭代器访问</code>，并支持以下操作：</li></ol><ul><li><code>empty</code>()：检测容器是否为空</li><li><code>size</code>()：返回容器中有效元素个数</li><li><code>front</code>()：返回容器中第一个元素的引用</li><li><code>push_back</code>()：在容器尾部插入元素</li><li><code>pop_back</code>()：删除容器尾部元素</li></ul><ol start="5"><li>标准容器类 <code>vector</code> 和 <code>deque</code> 满足这些需求。默认情况下，如果没有为特定的<code>priority_queue</code> 类实例化指定容器类，则使用 <code>vector</code></li><li>需要支持随机访问迭代器，以便始终在内部保持堆结构。容器适配器通过在需要时自动调用算法函数 <code>make_heap</code>、<code>push_heap</code> 和 <code>pop_heap</code> 来自动完成此操作</li></ol><h2 id="priority-queue函数"><a href="#priority-queue函数" class="headerlink" title="priority_queue函数"></a>priority_queue函数</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/649a3a474cbd44f3b362f9daa0142424.png" alt="在这里插入图片描述"></p><p>优先级队列默认使用 <code>vector</code> 作为其底层存储数据的容器，在 <code>vector</code> 上又使用了堆算法将<code>vector</code> 中元素构造成堆的结构，因此 <code>priority_queue</code> 就是堆，所有需要用到堆的位置，都可以考虑使用 <code>priority_queue</code></p><p>🔥<strong>值得注意的是：</strong> 默认情况下 <code>priority_queue</code> 是大堆</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>empty</code></td><td>检测优先级队列是否为空，是返回 <code>true</code>，否则返回 <code>false</code></td></tr><tr><td><code>size</code></td><td>返回 <code>stack</code> 中元素的个数</td></tr><tr><td><code>top</code></td><td>返回优先级队列中最大(最小元素)，即堆顶元素</td></tr><tr><td><code>push</code></td><td>在优先级队列中插入元素 <code>x</code></td></tr><tr><td><code>pop</code></td><td>删除优先级队列中最大(最小)元素，即堆顶元素</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span> &#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : v)</span><br><span class="line">q<span class="number">1.</span><span class="built_in">push</span>(e);</span><br><span class="line">cout &lt;&lt; q<span class="number">1.</span><span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">q<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; q<span class="number">1.</span><span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; q<span class="number">1.</span><span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; q<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/adb685a3ddc84171a6e1e2cf1a82c35f.png" alt="在这里插入图片描述"></p><h2 id="priority-queue常见OJ"><a href="#priority-queue常见OJ" class="headerlink" title="priority_queue常见OJ"></a>priority_queue常见OJ</h2><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h3><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/00e2dc91fb8a470b84aef1c1fcc20853.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bb214acfd28841a59b5d8964157ce187.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第K个最大元素</a></p></blockquote><p><strong>题解:</strong></p><p>因为优先级队列的本质是堆，所以每次删除都会把堆的最大元素放到堆顶，删除 <code>k</code> 次，第 <code>k</code> 个元素就在栈顶</p><p>关于堆的详细介绍：</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145785085">【初阶数据结构】森林里的树影 “堆” 光：堆</a></p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i &lt; k<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            p.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="priority-queue模拟实现"><a href="#priority-queue模拟实现" class="headerlink" title="priority_queue模拟实现"></a>priority_queue模拟实现</h2><p>通过对 <code>priority_queue</code> 的底层结构就是堆，因此此处只需对对进行通用的封装即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// priority_queue---&gt;堆</span></span><br><span class="line"><span class="keyword">namespace</span> bite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">less</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left &gt; right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = std::vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 创造空的优先级队列</span></span><br><span class="line"><span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;</span><br><span class="line"><span class="built_in">priority_queue</span>(Iterator first, Iterator last)</span><br><span class="line">: <span class="built_in">c</span>(first, last)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将c中的元素调整成堆的结构</span></span><br><span class="line"><span class="type">int</span> count = c.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> root = ((count - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (; root &gt;= <span class="number">0</span>; root--)</span><br><span class="line"><span class="built_in">AdjustDown</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c.<span class="built_in">push_back</span>(data);</span><br><span class="line"><span class="built_in">AdjustUP</span>(c.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(c.<span class="built_in">front</span>(), c.<span class="built_in">back</span>());</span><br><span class="line">c.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">AdjustDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆顶元素不允许修改，因为：堆顶元素修改可以会破坏堆的特性</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">top</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 向上调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUP</span><span class="params">(<span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = ((child - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (child)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Compare</span>()(c[parent], c[child]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(c[child], c[parent]);</span><br><span class="line">child = parent;</span><br><span class="line">parent = ((child - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下调整</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; c.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 找以parent为根的较大的孩子</span></span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; c.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">Compare</span>()(c[child], c[child + <span class="number">1</span>]))</span><br><span class="line">child += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测双亲是否满足情况</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Compare</span>()(c[parent], c[child]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(c[child], c[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Compare</code> 比较器：这里涉及仿函数的应用，后面会专门讲解</p><ul><li><code>less</code> 结构体：重载了 () 运算符，用于比较两个元素，当 <code>left</code> 小于 <code>right</code> 时返回 <code>true</code>，可用于构建大顶堆</li><li><code>greater</code> 结构体：同样重载了 () 运算符，当 <code>left</code> 大于 <code>right</code> 时返回 <code>true</code>，可用于构建小顶堆</li></ul><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="deque原理"><a href="#deque原理" class="headerlink" title="deque原理"></a>deque原理</h2><p>🤔<strong>什么是deque？</strong></p><blockquote><p><code>deque</code> 也叫做双端队列，虽然叫做队列，但是并不是队列，不符合先进先出的原理<br><code>deque</code> 是一种双开口的”连续”空间的数据结构，双开口的含义是：可以在<code>头尾两端进行插入和删除操作</code>，且时间复杂度为 <code>O(1)</code>，与 <code>vector</code> 比较，头插效率高，不需要搬移元素；与 <code>list</code> 比较，空间利用率比较高</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ab06edadf62548e8871755bf86d1757e.png" alt="在这里插入图片描述"><br><code>deque</code> 并不是真正连续的空间，而是由一段段连续的小空间拼接而成的，实际 <code>deque</code> 类似于一个动态的二维数组，<strong>其底层结构如下面的简单分析所示：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1f673abd0db3497b84c8c131df34e29b.png" alt="在这里插入图片描述"></p><p>首先对两种存储方式进行对比：</p><ul><li>通常使用 <code>vector</code> 数组时，通常是连续存储，但是最麻烦的就是扩容和部分位置的插入删除问题</li><li><code>deque</code> 使用的是把存储空间碎片化的方式进行存储</li></ul><p>🤔<strong>那么是如何实现的呢？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/720432c999d440e2b79a8d94405a3376.png" alt="在这里插入图片描述"><br><code>deque</code> 中有一个中控数组，存储每个碎片化数组的地址，每个碎片化数组的大小通常是相等的，所以实际操作都是在碎片化数组上实现的</p><p><strong>如何扩容：</strong> 直接在中控数组上扩容即可，这就有人问了那和之前的扩容有啥区别，不都是扩容吗？这区别可大了，别忘了中控数组是个指针数组，扩容的代价很小，如果是扩容传统的数组，内置类型的数据还好，但是自定义数据就麻烦了，扩容后的数据迁移涉及实际数据和数据间的连接，特别麻烦，因此 <code>deque</code> 大大降低了扩容的麻烦</p><p><strong>如何头部尾部处理数据：</strong> <code>deque</code> 是从中间开始插入的，从中间往两侧打开，比如尾插，如图就是从左到右，先插入 <code>10</code>，再插入 <code>20</code></p><p>以上是简单对 <code>deque</code> 的底层进行了解，实际的 <code>deque</code> 底层借助其迭代器维护其假想连续的结构相当复杂：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/05d41dee894c4c3c97d1cb26b2ef5805.png" alt="在这里插入图片描述"></p><h2 id="deque缺陷"><a href="#deque缺陷" class="headerlink" title="deque缺陷"></a>deque缺陷</h2><ul><li>相比 <code>vector</code> ，极大的缓解了扩容&#x2F;头插头删问题，头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必 <code>vector</code> 高的</li></ul><p>但是对于像 <code>[]</code> 的访问，是数组必须的，像for循环这样大量访问数组的情景很常见，如图分析，显然在这种场景下 <code>deque</code> 的效率就不如 <code>vector</code> 的直接访问数组</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3c0994441ad54f219fd8605bd4a3e620.png" alt="在这里插入图片描述"></p><ul><li>与 <code>list</code> 比较，其底层是连续空间，空间利用率比较高，不需要存储额外字段</li></ul><p><strong>总的来说：</strong> <code>deque</code> 的致命缺陷就是不适合遍历，因为在遍历时，<code>deque</code> 的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下，而序列式场景中，可能需要经常遍历，因此在实际中，需要线性结构时，大多数情况下优先考虑 <code>vector</code> 和 <code>list</code>，<code>deque</code> 的应用并不多，而目前能看到的一个应用就是，<code>STL</code> 用其作为 <code>stack</code> 和 <code>queue</code> 的底层数据结构</p><h2 id="为什么选择deque作为stack和queue的底层默认容器"><a href="#为什么选择deque作为stack和queue的底层默认容器" class="headerlink" title="为什么选择deque作为stack和queue的底层默认容器"></a>为什么选择deque作为stack和queue的底层默认容器</h2><p><code>stack</code> 是一种后进先出的特殊线性数据结构，因此只要具有 <code>push_back()</code> 和 <code>pop_back()</code> 操作的线性结构，都可以作为 <code>stack</code> 的底层容器，比如 <code>vector</code> 和 <code>list</code> 都可以</p><p><code>queue</code> 是先进先出的特殊线性数据结构，只要具有<code>push_back</code> 和 <code>pop_front</code> 操作的线性结构，都可以作为<code>queue</code> 的底层容器，比如list</p><p>但是 <code>STL</code> 中对 <code>stack</code> 和 <code>queue</code> 默认选择 <code>deque</code> 作为其底层容器，主要是因为：</p><ol><li><code>stack</code> 和 <code>queue</code> 不需要遍历(因此 <code>stack</code> 和 <code>queue</code>没有迭代器)，只需要在固定的一端或者两端进行操作。</li><li>在 <code>stack</code> 中元素增长时，<code>deque</code> 比 <code>vector</code> 的效率高(扩容时不需要搬移大量数据)；<code>queue</code> 中的元素增长时，<code>deque</code> 不仅效率高，而且内存使用率高。结合了<code>deque</code> 的优点，而完美的避开了其缺陷</li></ol><h2 id="STL标准库中对于stack和queue的模拟实现"><a href="#STL标准库中对于stack和queue的模拟实现" class="headerlink" title="STL标准库中对于stack和queue的模拟实现"></a>STL标准库中对于stack和queue的模拟实现</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Con</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">//template&lt;class T, class Con = vector&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">//template&lt;class T, class Con = list&lt;T&gt;&gt;</span></span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">stack</span>() &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; x) &#123; _c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; _c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">top</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Con _c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> bite</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Con</span> = deque&lt;T&gt;&gt;</span><br><span class="line"><span class="comment">//template&lt;class T, class Con = list&lt;T&gt;&gt;</span></span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">queue</span>() &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; x) &#123; _c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; _c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">back</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">back</span>(); &#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">front</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">front</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">size</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> _c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Con _c;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/550c34cc8d7d421fa0fdfd0871e284e7.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> priority_queue </tag>
            
            <tag> deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：stack &amp;&amp; queue函数全解</title>
      <link href="/2025/03/24/CPP%E5%88%9D%E9%98%B6/stack%20&amp;&amp;%20queue%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/"/>
      <url>/2025/03/24/CPP%E5%88%9D%E9%98%B6/stack%20&amp;&amp;%20queue%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本篇是 <code>STL</code> 库专题之 <code>stack</code> 和 <code>queue</code>，本质就是栈和队列，关于该数据结构在初阶数据结构专栏里有详细的解释分析，本篇文章主要针对 <code>stack</code> 和 <code>queue</code> 的使用及拓展进行练习和介绍，建议熟悉好相关的数据结构知识再进行本篇学习</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145672800">【初阶数据结构】先来后到的秩序：栈和队列</a></p></blockquote><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/509a8dde9bb04e4bad2216c66ffce65a.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/stack/stack/">stack</a> 的主要特征可总结为：</p><ol><li><code>stack</code> 是一种容器适配器，专门用在具有后进先出操作的上下文环境中，其删除只能从容器的一端进行元素的插入与提取操作</li><li><code>stack</code> 是作为容器适配器被实现的，容器适配器即是对特定类封装作为其底层的容器，并提供一组特定的成员函数来访问其元素，将特定类作为其底层的，元素特定容器的尾部(即栈顶)被压入和弹出</li><li><code>stack</code> 的底层容器可以是任何标准的容器类模板或者一些其他特定的容器类，这些容器类应该支持以下操作：</li></ol><ul><li><code>empty</code>：判空操作</li><li><code>back</code>：获取尾部元素操作</li><li><code>push_back</code>：尾部插入元素操作</li><li><code>pop_back</code>：尾部删除元素操作</li></ul><ol start="4"><li>标准容器 <code>vector</code>、<code>deque</code>、<code>list</code> 均符合这些需求，默认情况下，如果没有为 <code>stack</code> 指定特定的底层容器，默认情况下使用 <code>deque</code>(后面会介绍)</li></ol><p>🔥<strong>值得注意的是：</strong> 什么是<code>容器适配器</code>？简单来讲，就是它把一些普通的容器包装起来，给它们增加一些新的功能或者改变它们原来的一些行为方式，让这些容器能更好地适应某些特定的需求，让 <code>vector</code>，<code>list</code> 这样的容器也能以这种数据结构进行</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f2adc7eee59a4c719d3aa838a47b03f7.png" alt="在这里插入图片描述"></p><h2 id="stack函数"><a href="#stack函数" class="headerlink" title="stack函数"></a>stack函数</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/54d1e53a0e674666a6e6c91637024814.png" alt="在这里插入图片描述"></p><p><code>C++</code> 的 <code>STL</code> 库将我们在 <code>C</code> 语言阶段需要手撕出来的数据结构进行封装，以容器适配器的形式供我们直接使用</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>empty</code></td><td>检测 <code>stack</code> 是否为空</td></tr><tr><td><code>size</code></td><td>返回 <code>stack</code> 中元素的个数</td></tr><tr><td><code>top</code></td><td>返回栈顶元素</td></tr><tr><td><code>push</code></td><td>将元素 <code>val</code> 压入 <code>stack</code> 中</td></tr><tr><td><code>pop</code></td><td>将 <code>stack</code> 中尾部的元素弹出</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; st.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; st.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;top:&quot;</span> &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop、push:&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ed5b9a4b62f84346b2faffd1e46b40f2.png" alt="在这里插入图片描述"></p><h2 id="stack常见OJ"><a href="#stack常见OJ" class="headerlink" title="stack常见OJ"></a>stack常见OJ</h2><h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9f5798cbae4944698c1a5614b8c1d823.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5acd5a2c22a149a2af925d8929cfdfeb.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/min-stack/description/">最小栈</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7f6be0b7f3644b3492bbe659527bc3e6.png" alt="在这里插入图片描述"></p><p>既然题目的意思是要求能取到各种时刻下栈的最小值，那么一个栈来实现显然是不可取的，因为栈的遍历只能通过 <code>top</code> 和 <code>pop</code> 的循环来实现，这就破坏了原本的栈</p><p>所以我们设置两个栈，一个栈 <code>_st</code> 用于存储入栈的值，一个栈 <code>_minst</code> 用于存储栈各种时刻的最小值，每次存储的时候和此时 <code>_minst</code> 栈顶比较一下（栈顶即最小值），不断把每个时刻的最小值入栈 <code>_minst</code></p><p>再优化的版本就是把重复的最小值去掉，直到遇到更小的值才选择入栈 <code>_minst</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c159a36b53524027953916d94d91e154.png" alt="在这里插入图片描述"></p><p>出栈的操作也是同理，遇到相同的值 <code>_minst</code> 就出栈</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _st.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(_minst.<span class="built_in">empty</span>() || val &lt;= _minst.<span class="built_in">top</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _minst.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_st.<span class="built_in">top</span>() == _minst.<span class="built_in">top</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _minst.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> _st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _minst.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _minst;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; _st;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/48e9347e266649009b10d06917d5b860.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3df80c4094b34d0a8819254b7ccc6eee.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">用栈实现队列</a></p></blockquote><p><strong>题解:</strong></p><p>依然是用 <code>inst</code> 和 <code>outst</code> 两个栈，调转头尾在栈顶的位置实现队列的功能</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() </span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        inst.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outst.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!inst.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                outst.<span class="built_in">push</span>(inst.<span class="built_in">top</span>());</span><br><span class="line">                inst.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = outst.<span class="built_in">top</span>();</span><br><span class="line">        outst.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outst.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!inst.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                outst.<span class="built_in">push</span>(inst.<span class="built_in">top</span>());</span><br><span class="line">                inst.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outst.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outst.<span class="built_in">empty</span>() &amp;&amp; inst.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outst;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="stack的模拟实现"><a href="#stack的模拟实现" class="headerlink" title="stack的模拟实现"></a>stack的模拟实现</h2><p>从栈的接口中可以看出，栈实际是一种特殊的容器，因此使用 <code>vector</code>等容器完全可以模拟实现 <code>stack</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">_con.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container _con;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4ab77e7e372e4b5f9a9145b2538304c7.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/queue/queue/">queue</a> 的主要特征可总结为：</p><ol><li>队列是一种容器适配器，专门用于在 <code>FIFO</code> 上下文(先进先出)中操作，其中从容器一端插入元素，另一端提取元素</li><li>队列作为容器适配器实现，容器适配器即将特定容器类封装作为其底层容器类，<code>queue</code> 提供一组特定的成员函数来访问其元素。元素从队尾入队列，从队头出队列</li><li>底层容器可以是标准容器类模板之一，也可以是其他专门设计的容器类。该底层容器应至少支持以下操作:</li></ol><ul><li><code>empty</code>：检测队列是否为空</li><li><code>size</code>：返回队列中有效元素的个数</li><li><code>front</code>：返回队头元素的引用</li><li><code>back</code>：返回队尾元素的引用</li><li><code>push_back</code>：在队列尾部入队列</li><li><code>pop_front</code>：在队列头部出队列</li></ul><ol start="4"><li>标准容器类 <code>deque</code> 和 <code>list</code> 满足了这些要求。默认情况下，如果没有为 <code>queue</code> 实例化指定容器类，则使用标准容器 <code>deque</code></li></ol><h2 id="queue函数"><a href="#queue函数" class="headerlink" title="queue函数"></a>queue函数</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a904de6e94da4d1ca441a6e9fed4f36e.png" alt="在这里插入图片描述"></p><p><code>C++</code> 的 <code>STL</code> 库将我们在 <code>C</code> 语言阶段需要手撕出来的数据结构进行封装，以容器适配器的形式供我们直接使用</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>empty</code></td><td>检测队列是否为空，是返回 <code>true</code>，否则返回 <code>false</code></td></tr><tr><td><code>size</code></td><td>返回队列中有效元素的个数</td></tr><tr><td><code>front</code></td><td>返回队头元素的引用</td></tr><tr><td><code>back</code></td><td>返回队尾元素的引用</td></tr><tr><td><code>push</code></td><td>在队尾将元素 <code>val</code> 入队列</td></tr><tr><td><code>pop</code></td><td>将队头元素出队列</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; q.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop:&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/965ddedff3d0447e86bf0d3416c8eaf1.png" alt="在这里插入图片描述"></p><h2 id="queue常见OJ"><a href="#queue常见OJ" class="headerlink" title="queue常见OJ"></a>queue常见OJ</h2><h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ea8fe28bdee1440c881170a038ee7dd2.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/596f31930cbf4339bd7c0acd7f2a050f.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong> <a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">用队列实现栈</a></p></blockquote><p><strong>题解:</strong></p><p>使用一个队列时，为了满足栈的特性，即最后入栈的元素最先出栈，同样需要满足队列前端的元素是最后入栈的元素</p><p>入栈操作时，首先获得入栈前的元素个数 n，然后将元素入队到队列，再将队列中的前 n 个元素（即除了新入栈的元素之外的全部元素）依次出队并入队到队列，此时队列的前端的元素即为新入栈的元素，且队列的前端和后端分别对应栈顶和栈底</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="queue的模拟实现"><a href="#queue的模拟实现" class="headerlink" title="queue的模拟实现"></a>queue的模拟实现</h2><p><code>queue</code> 的底层不好以 <code>vector</code> 的形式实现，因为 <code>vector</code> 没有提供头删的操作，虽然可以使用 <code>erase+begin</code> 的操作实现，但还是太麻烦了，所以用 <code>list</code> 来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = list&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">_con.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_con.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _con.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Container _con;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c675bfb3888541fd93307abed4d1e78f.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：list底层剖析及迭代器万字详解</title>
      <link href="/2025/03/17/CPP%E5%88%9D%E9%98%B6/list%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/03/17/CPP%E5%88%9D%E9%98%B6/list%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90%E5%8F%8A%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>list 的函数用法与 STL 库中其他的大差不差，本文章难度有些上升，将针对前面忽略的迭代器和模版进行深度解析，真正了解到底什么是迭代器，和迭代器的实现原理</p><h1 id="学习list底层的重要性"><a href="#学习list底层的重要性" class="headerlink" title="学习list底层的重要性"></a>学习list底层的重要性</h1><blockquote><p><code>list</code> 底层是<code>双向带头循环链表</code>，在链表的任意位置进行插入和删除操作的<code>时间复杂度都是 O(1)</code>。这是因为链表插入或删除节点只需要修改相邻节点的指针。例如，在实现一个任务调度系统时，任务可能会随时被添加或移除，如果使用 <code>std::list</code> 来存储任务，就可以高效地处理这些操作</p></blockquote><p>为了与库里的 <code>list</code> 进行区分，所有的类和函数都放在自定义的命名空间 <code>bit</code> 进行区分</p><h1 id="节点模版"><a href="#节点模版" class="headerlink" title="节点模版"></a>节点模版</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">list_node&lt;T&gt;* _next;</span><br><span class="line">list_node&lt;T&gt;* _prev;</span><br><span class="line">T _val;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list_node</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">:_next(<span class="literal">nullptr</span>)</span><br><span class="line">, _prev(<span class="literal">nullptr</span>)</span><br><span class="line">, _val(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过数据结构的学习我们知道，每个节点都是一个结构体，因为是<code>双向循环链表</code>，所以有 <code>prev</code> 和 <code>next</code>，使用初始化列表进行常规的初始化</p><p>🔥<strong>值得注意的是：</strong></p><ol><li>这里使用 <code>struct</code> 而不是 <code>class</code>，是因为 <code>struct</code> 的默认访问权限是 <code>public</code>，<code>class</code> 的默认访问权限是 <code>private</code> ，虽然用 <code>class＋友元</code> 的方式也是可行的，但不如用 <code>struct</code> 来的方便</li><li>构造函数参数部分为 <code>const T&amp; val = T()</code> ，而不是常写的 <code>0</code> ，是因为 <code>T</code> 无法确定是<code>自定义类型</code>还是<code>内置类型</code>，所以当没有参数传入时就调用各自类型的<code>默认构造函数</code>进行传参</li></ol><h1 id="迭代器模版及实现"><a href="#迭代器模版及实现" class="headerlink" title="迭代器模版及实现"></a>迭代器模版及实现</h1><p>迭代器就是一个桥梁，让容器能通过迭代器实现算法</p><blockquote><p><code>容器</code> &lt;–&gt; <code>迭代器</code> &lt;–&gt; <code>算法</code></p></blockquote><p>根据迭代器的容器底层结构决定的性质，可以大致分为三类：</p><ol><li>单向迭代器（<code>forward iterator</code>）：支持运算符重载 <code>++</code>，常用容器为 <code>forward_list</code>、<code>unordered_map</code>、<code>unordered_set</code></li><li>双向迭代器（<code>bidirectional iterator</code>）：支持运算符重载 <code>++</code>、<code>--</code>，常用容器为 <code>list</code>、<code>map</code>、<code>set</code></li><li>随机迭代器（<code>random access iterator</code>）：支持运算符重载 <code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>，常用容器为<code>vector</code>、<code>string</code>、<code>deque</code></li></ol><p>从下往上为依次包含的关系，比如 <code>list</code> 迭代器为双向，那么<code>既可以用双向</code>，<code>也可以用单向</code>，<code>不能用随机</code>。通常 <code>std</code> 库里的是随机迭代器</p><p>因此这也解释了为什么 <code>vector</code> 迭代器可以使用 <code>std::iterator</code>，也可以使用 <code>vector&lt;T&gt;::iterator</code>。但是 <code>list</code> 迭代器不可以使用 <code>std::iterator</code>，一般使用 <code>list&lt;T&gt;::iterator</code></p><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剖析底层代码先从功能入手，通常我们实现迭代器如代码所示</p><h3 id="迭代器模版"><a href="#迭代器模版" class="headerlink" title="迭代器模版"></a>迭代器模版</h3><p>那么要先实现基本的<code>迭代器模版</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">_list_iterator(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现基本的构造函数，<code>_node</code> 是一个指向 <code>Node</code> 类型对象的指针，它用于存储当前迭代器所指向的链表节点</p><p>实现 <code>push_back</code> 往链表中放置数据，实现方式还是和双线链表中一样，可以去数据结构专题中回顾</p><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145233824?spm=1001.2014.3001.5501">【初阶数据结构】逆流的回环链桥：双链表</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* tail = _head-&gt;_prev;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(x);</span><br><span class="line">tail-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_prev = tail;</span><br><span class="line">newnode-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = newnode;</span><br><span class="line"><span class="comment">//insert(end(), x);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="begin和end"><a href="#begin和end" class="headerlink" title="begin和end"></a>begin和end</h3><p>接下来实现 <code>begin()</code> 和 <code>end()</code> ，还是比较简单的，这里直接展示放在 <code>list</code> 模版中的效果，后续就只单独列出实现功能的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T&gt; iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>list</code> 模版有一个头节点，作为哨兵位，实现了双链表的构造函数，看似简单的代码，实则隐藏了很多的细节</p><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>begin()</code> 和 <code>end()</code> 返回的是 <code>iterator</code> 类型，<code>C++</code> 标准库提供了大量基于迭代器的通用算法（如 <code>std::find</code>、<code>std::sort</code>、<code>std::for_each</code> 等）。当自定义容器的 <code>begin()</code> 函数返回迭代器时，这些通用算法可以直接应用到自定义容器上，实现代码的复用</li><li><code>iterator</code> 是 <code>_list_iterator&lt;T&gt;</code> 模版的重命名，更符合使用习惯</li><li><code>begin()</code> 和 <code>end()</code> 返回的值看似是 <code>Node*</code> 类型，实际上<code>单参数的函数支持隐式转换</code>，<code>Node*</code> 隐式转换为 <code>iterator</code> 类型，<code>return _head-&gt;_next</code> 其实是 <code>return iterator(_head-&gt;_next)</code></li><li><code>begin()</code> 和 <code>end()</code> 函数都用 const 修饰，使函数更具普遍性，包括 <code>const</code> 变量的情况，普通类型调用也是权限的缩小，两种情况共用一个函数</li></ol><h3 id="解引用运算符重载"><a href="#解引用运算符重载" class="headerlink" title="*解引用运算符重载"></a>*解引用运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>_node</code> 应该是一个指向链表节点的指针，<code>_val</code> 是链表节点中存储的数据成员。该函数返回节点数据 <code>_val</code></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="++运算符重载"></a>++运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置</span></span><br><span class="line">_list_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置</span></span><br><span class="line">_list_iterator&lt;T&gt; <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了区分前置后置，前置 <code>++</code> 和后置 <code>++</code> 虽然是运算符重载，但是形式上也构成函数重载，后置 <code>++</code> 增加这个 <code>int</code> 参数不是为了接受具体的值，仅仅是占位，跟前置 <code>++</code> 构成重载， <code>int</code> 这个位置传任何值都可以，实际调用的时候前置 <code>++</code> 和后置 <code>++</code> 可能分别为<code> operator++()</code> 和 <code>operator++(0)</code> ，括号内的值是随机的</p><p>🔥<strong>值得注意的是：</strong> 前置 <code>++</code> 返回的对象还存在，所以可以用引用，而后置 <code>++</code> 返回的对象是个临时对象，所以不能返回引用</p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="!&#x3D;运算符重载"></a>!&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> _list_iterator&lt;T&gt;&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数通过比较当前对象的 <code>_node</code> 成员变量和传入对象 <code>it</code> 的 <code>_node</code> 成员变量来判断两个对象是否不相等。如果 <code>_node</code> 和 <code>it._node</code> 不相等，则返回 <code>true</code>，表示两个对象不相等；否则返回 <code>false</code>，表示两个对象相等</p><p>🔥<strong>值得注意的是：</strong> 调用 <code>end()</code> 时传值返回，具有常性，所以 <code>!=</code> 重载要参数加 <code>const</code></p><p>以上就已经基本实现了迭代器，能够跑起来实现正常功能，<code>范围 for</code> 的底层也是迭代器，所以也能够使用了，但是还有很多需要完善的</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c5c2fcedf10e4b8d96d2bd6993f61908.png" alt="在这里插入图片描述"></p><h2 id="再完善实现"><a href="#再完善实现" class="headerlink" title="再完善实现"></a>再完善实现</h2><p>通常迭代器分为 <code>iterator</code> 和 <code>const_iterator</code></p><p>那么我们难道再写一个来实现吗，显然是<code>不符合编程范式的</code>，代码就显得太冗余了</p><p><strong>有人或许会想到这么写：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> _list_const_iterator&lt;T&gt; const_iterator;</span><br></pre></td></tr></table></figure><p>这样看起或许可行，但是我们要思考 <code>const</code> 的使用</p><p><strong>举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> T* ptr1;</span><br><span class="line">T* <span class="type">const</span> ptr2;</span><br></pre></td></tr></table></figure><p>这两段代码的含义分别为：<code>不可以修改指向对象的内容</code>，<code>不可以修改指向别的对象</code></p><p>显然 <code>typedef const _list_const_iterator&lt;T&gt; const_iterator</code> 是第一种 <code>const</code> 的使用，在 <code>++</code> 运算符重载中有 <code>_node = _node-&gt;_next</code> ，需要通过这段代码来到下一个节点，按照我们这样加 <code>const</code> 就和这段代码冲突了。我们只是不想修改其内容，而不是无法跳转节点</p><p>所以发明 STL库的人真是个天才，<strong>想到了巧妙的办法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">迭代器模版</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>&gt;</span><br><span class="line">......</span><br><span class="line">list模版</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, T&amp;&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, <span class="type">const</span> T&amp;&gt; const_iterator;</span><br></pre></td></tr></table></figure><p><code>iterator</code> 和 <code>const_iterator</code> 的区别就在于 <code>*</code> 运算符重载返回的值是否能够被修改，因此增加一个新的模版参数，当使用对应的迭代器就会调用相应的模版</p><h2 id="最终完善实现"><a href="#最终完善实现" class="headerlink" title="最终完善实现"></a>最终完善实现</h2><p>在查看STL库里的list底层代码时，会发现实际上的迭代器代码有三个参数，单纯去看是很难发现为什么要有第三个参数的，必须要结合实际的应用场景</p><p><strong>举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a1 = <span class="number">0</span>, <span class="type">int</span> a2 = <span class="number">0</span>)</span><br><span class="line">:_a1(a1)</span><br><span class="line">,_a2(a2)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _a1;</span><br><span class="line"><span class="type">int</span> _a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;A&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line">list&lt;A&gt;::iterator it = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; (*it)._a1 &lt;&lt; &quot; &quot; &lt;&lt; (*it)._a2 &lt;&lt; endl;*/</span></span><br><span class="line">cout &lt;&lt; it-&gt;_a1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;_a2 &lt;&lt; endl;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有个<code>类A</code>，需要遍历输出，通常我们会写成 <code>cout &lt;&lt; (*it)._a1 &lt;&lt; &quot; &quot; &lt;&lt; (*it)._a2 &lt;&lt; endl</code> ，但是这并不符合编程范式</p><p><strong>可是为什么写成 cout &lt;&lt; it-&gt;_a1 &lt;&lt; “ “ &lt;&lt; it-&gt;_a2 &lt;&lt; endl 也能通过？</strong></p><blockquote><p>严格来说，应该写成 <code>it-&gt;-&gt;_a2</code>，才符合语法，因为运算符重载要求可读性，所以编译器特殊处理，省略一个 <code>-&gt;</code></p></blockquote><h3 id="运算符重载-2"><a href="#运算符重载-2" class="headerlink" title="-&gt;运算符重载"></a>-&gt;运算符重载</h3><p>所以我们可以写出 <code>-&gt;</code> 运算符重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的道理，为了实现<code>iterator</code> 和 <code>const_iterator</code>两种迭代器，再增加一个模版参数，同时因为模版参数有点过多，导致类型太长了，对类型也进行重命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">迭代器模版</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">......</span><br><span class="line">list模版</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br></pre></td></tr></table></figure><h1 id="其余list函数功能实现"><a href="#其余list函数功能实现" class="headerlink" title="其余list函数功能实现"></a>其余list函数功能实现</h1><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">delete</span> _head;</span><br><span class="line">_head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list&lt;T&gt;&amp; lt)</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line"><span class="comment">//万一拷贝的是string、vector等代价就大了，所以用&amp;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载-3"><a href="#运算符重载-3" class="headerlink" title="&#x3D;运算符重载"></a>&#x3D;运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt;&amp; <span class="keyword">operator</span>=(list&lt;T&gt; lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(lt);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&lt;T&gt;&amp; lt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_head, lt._head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator it = <span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != <span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">it = <span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(x);</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_next = cur;</span><br><span class="line">cur-&gt;_prev = newnode;</span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-front、pop-back、pop-front"><a href="#push-front、pop-back、pop-front" class="headerlink" title="push_front、pop_back、pop_front"></a>push_front、pop_back、pop_front</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">begin</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>;</span><br><span class="line">iterator it = <span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != <span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">++sz;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="–运算符重载"><a href="#–运算符重载" class="headerlink" title="–运算符重载"></a>–运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置</span></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载-4"><a href="#运算符重载-4" class="headerlink" title="&#x3D;&#x3D;运算符重载"></a>&#x3D;&#x3D;运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="list模拟实现代码及测试代码展示"><a href="#list模拟实现代码及测试代码展示" class="headerlink" title="list模拟实现代码及测试代码展示"></a>list模拟实现代码及测试代码展示</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//节点模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">list_node</span></span><br><span class="line">&#123;</span><br><span class="line">list_node&lt;T&gt;* _next;</span><br><span class="line">list_node&lt;T&gt;* _prev;</span><br><span class="line">T _val;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list_node</span>(<span class="type">const</span> T&amp; val = <span class="built_in">T</span>())</span><br><span class="line">:_next(<span class="literal">nullptr</span>)</span><br><span class="line">, _prev(<span class="literal">nullptr</span>)</span><br><span class="line">, _val(val)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代器模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_list_iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">Node* _node;</span><br><span class="line"></span><br><span class="line">_list_iterator(Node* node)</span><br><span class="line">:_node(node)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const T&amp; operator*()就可以实现const_iterator</span></span><br><span class="line">Ref&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node-&gt;_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(_node-&gt;_val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">_node = _node-&gt;_next;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">_node = _node-&gt;_prev;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node != it._node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; it) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _node == it._node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//list类模版</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> list_node&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">typedef</span> _list_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line"><span class="comment">//typedef const _list_const_iterator&lt;T&gt; const_iterator;</span></span><br><span class="line"><span class="comment">//不能这样写，因为++没法next,就没法遍历了</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(_head-&gt;_next);</span><br><span class="line"><span class="comment">//单参数的函数支持隐式转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="type">const</span> list&lt;T&gt;&amp; lt)</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Node;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line"><span class="comment">//万一拷贝的是string、vector等代价就大了，所以用&amp;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(list&lt;T&gt;&amp; lt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_head, lt._head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list&lt;T&gt;&amp; <span class="keyword">operator</span>=(list&lt;T&gt; lt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(lt);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">list</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">delete</span> _head;</span><br><span class="line">_head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iterator it = <span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != <span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">it = <span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*Node* tail = _head-&gt;_prev;</span></span><br><span class="line"><span class="comment">Node* newnode = new Node(x);</span></span><br><span class="line"><span class="comment">tail-&gt;_next = newnode;</span></span><br><span class="line"><span class="comment">newnode-&gt;_prev = tail;</span></span><br><span class="line"><span class="comment">newnode-&gt;_next = _head;</span></span><br><span class="line"><span class="comment">_head-&gt;_prev = newnode;*/</span></span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">begin</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(x);</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_next = cur;</span><br><span class="line">cur-&gt;_prev = newnode;</span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos != <span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line">Node* next = cur-&gt;_next;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = next;</span><br><span class="line">next-&gt;_prev = prev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="number">0</span>;</span><br><span class="line">iterator it = <span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != <span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">++sz;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node* _head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//调用end的函数时传值返回，具有常性,所以!=重载要参数加const</span></span><br><span class="line"><span class="keyword">while</span> (it != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a1 = <span class="number">0</span>, <span class="type">int</span> a2 = <span class="number">0</span>)</span><br><span class="line">:_a1(a1)</span><br><span class="line">,_a2(a2)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _a1;</span><br><span class="line"><span class="type">int</span> _a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;A&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="built_in">A</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">//严格来说，应该写成it-&gt;-&gt;_a2，才符合语法</span></span><br><span class="line"><span class="comment">//因为运算符重载要求可读性，所以编译器特殊处理，省略一个-&gt;</span></span><br><span class="line">list&lt;A&gt;::iterator it = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*cout &lt;&lt; (*it)._a1 &lt;&lt; &quot; &quot; &lt;&lt; (*it)._a2 &lt;&lt; endl;*/</span></span><br><span class="line">cout &lt;&lt; it-&gt;_a1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;_a2 &lt;&lt; endl;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">lt.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">lt.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">lt.<span class="built_in">push_front</span>(<span class="number">7</span>);</span><br><span class="line">lt.<span class="built_in">push_front</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">pop_front</span>();</span><br><span class="line">lt.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">clear</span>();</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; lt.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt1;</span><br><span class="line">lt<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt2;</span><br><span class="line">lt2 = lt1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : lt2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1199f2c346d14cd48db9d118a1abcd1a.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepSeek、Grok 和 ChatGPT 对比分析：从技术与应用场景的角度深入探讨</title>
      <link href="/2025/02/28/%E8%AF%9D%E9%A2%98/DeepSeek%E3%80%81Grok%20%E5%92%8C%20ChatGPT%20%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/"/>
      <url>/2025/02/28/%E8%AF%9D%E9%A2%98/DeepSeek%E3%80%81Grok%20%E5%92%8C%20ChatGPT%20%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在人工智能领域，随着技术的快速发展，不同的工具和框架不断涌现，为开发者提供了更多选择。DeepSeek、Grok 和 ChatGPT 作为三款备受关注的工具，每一款都有其独特的优势和适用场景。本文将从技术特点、应用场景以及实际案例分析的角度，对这三款工具进行对比，帮助读者更好地理解它们的区别和适用场景</p><h1 id="DeepSeek：知识图谱与高效信息检索"><a href="#DeepSeek：知识图谱与高效信息检索" class="headerlink" title="DeepSeek：知识图谱与高效信息检索"></a>DeepSeek：知识图谱与高效信息检索</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8012900c39f34a0497955e7fab2f991b.webp" alt="请添加图片描述"></p><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p><code>DeepSeek</code> 最初成立于 <code>2023</code> 年，由一团深度学习专家组成的团队开发。其核心技术是基于知识图谱的信息检索系统，能够快速从大量数据中提取并生成结构化信息</p><ul><li><strong>知识图谱构建：</strong> 通过深度学习算法，从非结构化文本（如<code>PDF</code>、网页内容）自动抽取实体和关系，构建动态知识图谱。</li><li><strong>语义理解：</strong> 支持上下文感知和语义匹配，能够理解用户的自然语言查询并找到相关信息</li><li><strong>多源数据处理：</strong> 支持多种数据格式（如数据库、文档、网络等）的整合与融合。</li></ul><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li><strong>高效检索：</strong> 可以在毫秒级别完成复杂的语义匹配和知识抽取。</li><li><strong>动态更新：</strong> 能够根据新数据实时更新知识图谱，保持信息的最新性。</li><li><strong>多模态支持：</strong> 除了文本，还支持图片、音频等多种数据类型的检索。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><p><strong>问答系统：</strong> 适合需要快速获取结构化信息的场景，如企业知识库、客服问答系统</p></li><li><p><strong>智能助手：</strong> 可以集成到智能终端（如智能音箱）中，提供实时的知识检索服务。<br>行业应用：在医疗、金融、教育等领域，用于快速提取关键信息和生成相关报告</p></li></ul><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>某大型企业通过 <code>DeepSeek</code> 从内部文档中自动构建了一个动态知识图谱，实现了跨部门的快速查询，提升了员工效率</p><p>一家教育机构利用 <code>DeepSeek</code> 为学生提供个性化学习建议，根据学生的知识背景和学习进度生成个性化学习计划</p><h1 id="Grok：通用人工智能框架"><a href="#Grok：通用人工智能框架" class="headerlink" title="Grok：通用人工智能框架"></a>Grok：通用人工智能框架</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/77c5921463a44f418828ae47de6671e5.webp" alt="请添加图片描述"></p><h2 id="核心技术-1"><a href="#核心技术-1" class="headerlink" title="核心技术"></a>核心技术</h2><p><code>Grok</code>（“理解”）是一款基于大规模语言模型的开源工具，支持多种任务并具有灵活的扩展性。其核心算法是基于 <code>Transformer</code> 架构的大模型，能够处理复杂的自然语言理解和生成任务</p><ul><li><strong>多任务学习：</strong> 支持问答、对话、文本生成、图像描述等多种任务</li><li><strong>上下文感知：</strong> 模型能够在长上下文中保持注意力机制，捕捉复杂的语义关系</li><li><strong>零样本学习：</strong> 无需大量标注数据即可完成新任务的适应</li></ul><h2 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li><strong>通用性强：</strong> 支持多种任务，可以根据需求灵活切换模型</li><li><strong>开源优势：</strong> 开发者可以自由修改代码，实现定制化功能</li><li><strong>计算资源需求高：</strong> 虽然灵活，但在运行时需要较强的计算能力</li></ul><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>问答系统：</strong> 适合支持多轮对话和复杂问题解答的场景</li><li><strong>内容生成：</strong> 可以用于文章撰写、邮件生成等自动化文本生成任务</li><li><strong>数据分析：</strong> 结合外部知识库，能够对非结构化数据进行智能分析</li></ul><h2 id="实际案例-1"><a href="#实际案例-1" class="headerlink" title="实际案例"></a>实际案例</h2><p>一家新闻网站利用 <code>Grok</code> 自动生成新闻稿件，并通过模型检查确保内容的准确性和专业性</p><p>某教育平台使用 <code>Grok</code> 为学生提供个性化学习建议，结合学生成绩和学习行为数据生成定制化的辅导计划</p><h1 id="ChatGPT：聊天机器人与通用对话系统"><a href="#ChatGPT：聊天机器人与通用对话系统" class="headerlink" title="ChatGPT：聊天机器人与通用对话系统"></a>ChatGPT：聊天机器人与通用对话系统</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc11d338e2b6499b9c2b4e2b6392b80b.webp" alt="请添加图片描述"></p><h2 id="核心技术-2"><a href="#核心技术-2" class="headerlink" title="核心技术"></a>核心技术</h2><p><code>ChatGPT</code> 由 <code>OpenAI</code> 开发，是一种基于大规模语言模型的对话机器人工具。其核心特点是支持多轮对话，并能够在不完全理解上下文的情况下，保持对话的连贯性和自然性</p><ul><li><strong>注意力机制：</strong> 通过自注意力层捕捉长距离依赖关系</li><li><strong>上下文存储：</strong> 将对话历史记录在一个外部缓存中，确保上下文的可访问性</li><li><strong>生成优化：</strong> 引入了插件机制，可以根据不同任务加载预训练模型</li></ul><h2 id="主要特点-2"><a href="#主要特点-2" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li><strong>自然对话：</strong> 能够模拟人类对话的流畅性和逻辑性</li><li><strong>灵活应用：</strong> 支持多种领域知识的集成，适用于聊天、客服、教育等场景</li><li><strong>计算资源需求高：</strong> 与 <code>Grok</code> 一样，对运行时有较高要求</li></ul><h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>智能客服：</strong> 通过自然对话模拟人类服务态度，提升用户体验</li><li><strong>教育辅助：</strong> 为学生提供即时答疑和学习建议</li><li><strong>创意写作：</strong> 帮助用户生成文章、邮件等文本内容</li></ul><h2 id="实际案例-2"><a href="#实际案例-2" class="headerlink" title="实际案例"></a>实际案例</h2><p>某电子商务平台将 <code>ChatGPT</code> 集成为客服聊天机器人，解决了高峰期的人力资源不足问题<br>一家公关公司利用 <code>ChatGPT</code> 为客户撰写新闻稿件，并根据客户需求调整语气和内容</p><h1 id="三者比较：优缺点分析"><a href="#三者比较：优缺点分析" class="headerlink" title="三者比较：优缺点分析"></a>三者比较：优缺点分析</h1><h2 id="功能定位"><a href="#功能定位" class="headerlink" title="功能定位"></a>功能定位</h2><p><code>DeepSeek：</code>专注于知识检索与信息处理。<br><code>Grok：</code>通用人工智能框架，支持多种任务。<br><code>ChatGPT：</code>专注于对话生成与文本生成。</p><h2 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h2><table><thead><tr><th>特性</th><th>DeepSeek</th><th>Grok</th><th>ChatGPT</th></tr></thead><tbody><tr><td><strong>知识图谱支持</strong></td><td>是</td><td>否</td><td>否</td></tr><tr><td><strong>对话能力</strong></td><td>否</td><td>否</td><td>是</td></tr><tr><td><strong>多任务处理</strong></td><td>否</td><td>是</td><td>否</td></tr></tbody></table><h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><strong>DeepSeek：</strong> 适合需要快速信息检索的场景，如企业知识库、问答系统</li><li><strong>Grok：</strong> 适合需要复杂任务处理的场景，如自动驾驶、机器人控制等</li><li><strong>ChatGPT：</strong> 适合需要与用户进行对话交流的场景，如客服、教育辅助</li></ul><h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><table><thead><tr><th>工具</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>DeepSeek</td><td>高效信息检索，多源数据支持</td><td>对话能力有限，不适合对话场景</td></tr><tr><td>Grok</td><td>多任务处理，通用人工智能框架</td><td>模型复杂度高，对于非专家用户可能难用</td></tr><tr><td>ChatGPT</td><td>高质量文本生成，易用性强</td><td>知识图谱支持不足，不适合复杂查询</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效利用DeepSeek：深入探索AI搜索引擎的潜力</title>
      <link href="/2025/02/28/%E8%AF%9D%E9%A2%98/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8DeepSeek/"/>
      <url>/2025/02/28/%E8%AF%9D%E9%A2%98/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%88%A9%E7%94%A8DeepSeek/</url>
      
        <content type="html"><![CDATA[<p>随着人工智能技术的飞速发展，传统的搜索引擎正逐步向更智能化、个性化的方向演进。作为一款基于深度学习的 <code>AI</code> 搜索引擎，<code>DeepSeek</code>（深度求索）不仅在理解用户意图方面展现出色，还通过集成丰富的知识图谱和提供多样化的信息类型，成为现代用户的信息获取利器。本文将详细分析如何高效利用 <code>DeepSeek</code>，探讨其核心技术、实际应用场景以及性能优化方法</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e640e59c2f92482993b52c845adf7844.webp" alt="请添加图片描述"></p><h1 id="深入理解DeepSeek的核心优势"><a href="#深入理解DeepSeek的核心优势" class="headerlink" title="深入理解DeepSeek的核心优势"></a>深入理解DeepSeek的核心优势</h1><h2 id="DeepSeek的基本功能与原理"><a href="#DeepSeek的基本功能与原理" class="headerlink" title="DeepSeek的基本功能与原理"></a>DeepSeek的基本功能与原理</h2><p><code>DeepSeek</code> 作为一款 <code>AI</code> 搜索引擎，其核心在于语义理解和信息推荐能力。以下是其关键技术：</p><ul><li><p><strong>自然语言处理（NLP）：</strong> 通过深度学习模型，DeepSeek能够理解用户输入的语义意图，从而提供更相关的搜索结果</p></li><li><p><strong>知识图谱集成：</strong> <code>DeepSeek</code> 内置了庞大的知识图谱，能够将信息进行链接和关联，帮助用户快速定位到所需内容</p></li><li><p><strong>个性化推荐算法：</strong> 基于用户行为数据，<code>DeepSeek</code> 能够为每个用户提供高度定制的搜索结果</p></li></ul><h2 id="DeepSeek与传统搜索引擎的区别"><a href="#DeepSeek与传统搜索引擎的区别" class="headerlink" title="DeepSeek与传统搜索引擎的区别"></a>DeepSeek与传统搜索引擎的区别</h2><p>与传统搜索引擎相比，<code>DeepSeek</code> 有以下显著特点：</p><ul><li><p><strong>语义理解能力强：</strong> 不仅匹配关键词，还能理解用户意图</p></li><li><p><strong>多样化信息类型支持：</strong> 包括文档、图片、视频等多种媒体形式</p></li><li><p><strong>深度知识链接：</strong> 通过知识图谱实现概念间的关联，提升信息查找效率</p></li><li><p><strong>个性化推荐机制：</strong> 根据用户历史行为和偏好动态调整搜索结果</p></li></ul><hr><h1 id="实际应用场景与使用方法"><a href="#实际应用场景与使用方法" class="headerlink" title="实际应用场景与使用方法"></a>实际应用场景与使用方法</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9bf5607ed66e4506b8041a2e35189acd.webp" alt="请添加图片描述"></p><h2 id="学术研究中的应用"><a href="#学术研究中的应用" class="headerlink" title="学术研究中的应用"></a>学术研究中的应用</h2><p>在学术研究领域，<code>DeepSeek</code> 能够帮助用户快速找到相关文献、论文或专利。例如，用户输入“机器学习算法2023年”，<code>DeepSeek</code>不仅会筛选出最新的论文，还能通过知识图谱展示相关概念和发展趋势。此外，<code>DeepSeek</code> 支持导出搜索结果，方便用户整理和引用。</p><h2 id="企业内部知识库管理"><a href="#企业内部知识库管理" class="headerlink" title="企业内部知识库管理"></a>企业内部知识库管理</h2><p>许多企业面临着海量文档、邮件和社交媒体信息的管理难题。通过与企业知识管理系统集成，<code>DeepSeek</code> 可以自动化地进行信息分类、关键词提取和重要性评估，帮助用户快速定位到所需资料</p><h2 id="个性化信息推送"><a href="#个性化信息推送" class="headerlink" title="个性化信息推送"></a>个性化信息推送</h2><p><code>DeepSeek</code> 能够根据用户的历史行为和偏好推荐相关内容。例如，用户对机器学习感兴趣，<code>DeepSeek</code> 会自动推送新的论文、课程和技术博客，提升信息获取效率</p><hr><h1 id="性能优化与技术深度分析"><a href="#性能优化与技术深度分析" class="headerlink" title="性能优化与技术深度分析"></a>性能优化与技术深度分析</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/79400617b0f640c683a5e0ff3db2a288.webp" alt="请添加图片描述"></p><h2 id="高效搜索策略"><a href="#高效搜索策略" class="headerlink" title="高效搜索策略"></a>高效搜索策略</h2><ul><li><p><strong>多语义匹配：</strong> 通过 <code>NLP</code> 模型识别用户输入的不同表述形式（如同义词替换），确保搜索结果的全面性</p></li><li><p><strong>知识图谱推理：</strong> 利用图遍历算法，将相关概念连接起来，提升信息关联程度</p></li><li><p><strong>实时反馈机制：</strong> 通过 <code>A/B</code> 测试不断优化搜索算法，提高用户体验</p></li></ul><h2 id="API集成与自定义化"><a href="#API集成与自定义化" class="headerlink" title="API集成与自定义化"></a>API集成与自定义化</h2><p><code>DeepSeek</code> 提供丰富的 <code>API</code> 接口，允许开发者根据需求定制搜索功能。例如，可以开发自动化的信息检索工具或将其嵌入到企业级知识管理系统中，以满足特定业务需求</p><h2 id="强化学习与迭代优化"><a href="#强化学习与迭代优化" class="headerlink" title="强化学习与迭代优化"></a>强化学习与迭代优化</h2><p>通过强化学习技术，<code>DeepSeek</code> 能够在实际使用过程中不断优化推荐模型。每一次用户交互都会为模型提供反馈，从而提升后续搜索精度和相关性</p><hr><h1 id="与其他工具的对比与优势"><a href="#与其他工具的对比与优势" class="headerlink" title="与其他工具的对比与优势"></a>与其他工具的对比与优势</h1><h2 id="与传统搜索引擎的区别"><a href="#与传统搜索引擎的区别" class="headerlink" title="与传统搜索引擎的区别"></a>与传统搜索引擎的区别</h2><ul><li><strong>语义理解：</strong> <code>DeepSeek</code> 能够理解用户意图，而非仅仅匹配关键词。<br>知识图谱支持：通过深度链接，提供更加丰富和准确的信息关联。</li><li><strong>个性化推荐：</strong> 根据用户行为动态调整搜索结果。</li></ul><h2 id="与其他AI搜索引擎的对比"><a href="#与其他AI搜索引擎的对比" class="headerlink" title="与其他AI搜索引擎的对比"></a>与其他AI搜索引擎的对比</h2><p>相比其他AI搜索引擎，<code>DeepSeek</code> 在知识图谱规模、语义理解能力和个性化推荐上有显著优势。其知识图谱涵盖了百度等大型企业级数据集，能够应对复杂的跨领域信息检索需求。</p><hr><h1 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h1><p>通过对 <code>DeepSeek</code> 的核心技术、实际应用场景及性能优化方法的详细分析，我们可以清晰地看到其在现代信息管理中的重要作用。未来，随着 <code>NLP</code> 和知识图谱技术的不断进步，<code>DeepSeek</code> 有望进一步提升其功能，为用户提供更加智能化、高效率的信息获取体验。</p><p>如果你对 <code>DeepSeek</code> 还有更多疑问或想了解具体实现细节，请留言与我交流！</p>]]></content>
      
      
      <categories>
          
          <category> 话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】星河中的光影 “排” 象：排序（下）</title>
      <link href="/2025/02/25/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/02/25/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接上一篇，解决掉剩余的排序方法，本篇有些许难度，建议巩固好上一篇再来进行本篇的学习</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145803285">【初阶数据结构】星河中的光影 “排” 象：排序（上）</a></p></blockquote><h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><h2 id="冒泡排序（BubbleSort）"><a href="#冒泡排序（BubbleSort）" class="headerlink" title="冒泡排序（BubbleSort）"></a>冒泡排序（BubbleSort）</h2><p><strong>基本思想：</strong> 所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将<code>键值较大</code>的记录向序列的<code>尾部移动</code>，<code>键值较小</code>的记录向序列的<code>前部移动</code></p><p><code>冒泡排序</code>在C语言部分进行过详细的解析，这里就不过多赘述</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143477683">关于我、重生到500年前凭借C语言改变世界科技vlog.14——常见C语言算法</a></p></blockquote><h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><p><code>快速排序</code>是 Hoare 于 1962 年提出的一种二叉树结构的交换排序方法，<strong>其基本思想为：</strong> 任取待排序元素序列中的<code>某元素作为基准值</code>，按照该排序码将待排序集合分割成<code>两子序列</code>，<code>左子序列</code>中所有元素均<code>小于基准值</code>，<code>右子序列</code>中所有元素均<code>大于基准值</code>，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止</p><h3 id="hoare版本"><a href="#hoare版本" class="headerlink" title="hoare版本"></a>hoare版本</h3><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8eec32b2f9014c03b7d7d67782af37c9.gif" alt="请添加图片描述"></p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> begin = left, end = right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机选key</span></span><br><span class="line"><span class="type">int</span> randi = left + (<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[randi]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三数取中</span></span><br><span class="line"><span class="comment">//int midi = GetMidNumi(a, left, right);</span></span><br><span class="line"><span class="comment">//Swap(&amp;a[midi], &amp;a[left]);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyi = left;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//右边找小</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= a[keyi])</span><br><span class="line">--right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左边找大</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= a[keyi])</span><br><span class="line">++left;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[keyi], &amp;a[left]);</span><br><span class="line">keyi = left;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort1</span>(a, begin, keyi - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSort1</span>(a, keyi + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li><code>if (left &gt;= right)</code>， 如果左边界大于等于右边界，说明子数组已经有序或为空，直接返回</li><li>随机选 <code>key</code></li><li>当左边界小于右边界时，继续分区操作。<code>右边找小</code>，从右向左找到第一个小于基准元素的元素；<code>左边找大</code>，从左向右找到第一个大于基准元素的元素。交换左右找到的元素</li><li>最后将基准元素放到正确的位置，更新基准元素的索引</li><li>此时基准元素所放置的位置就是正确的排序位置，基准元素左右两边任然无序，所以对左右两边进行循环操作，<code>每循环一次就确定一个数的位置</code></li></ol><p>🔥<strong>值得注意的是：</strong><br>选取 <code>key</code> 的方式有三种</p><ol><li>选第一个数为 <code>key</code></li><li>三数取中值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMidNumi</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[left] &lt; a[mid])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[left] &gt; a[right])</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; a[right])</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//a[left] &gt; a[mid]</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt; a[right])</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[right] &gt; a[left])</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>随机选 <code>key</code>，经过算法研究发现该选 <code>key</code> 方式是最有效的</li></ol><h3 id="挖坑法"><a href="#挖坑法" class="headerlink" title="挖坑法"></a>挖坑法</h3><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d32dfc810a9246ccbe69b6971458008c.gif" alt="请添加图片描述"></p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> begin = left, end = right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机选key</span></span><br><span class="line"><span class="type">int</span> randi = left + (<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[randi]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//三数取中</span></span><br><span class="line"><span class="comment">//int midi = GetMidNumi(a, left, right);</span></span><br><span class="line"><span class="comment">//Swap(&amp;a[midi], &amp;a[left]);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> key = a[left];</span><br><span class="line"><span class="type">int</span> hole = left;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//右边找小</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= key)</span><br><span class="line">--right;</span><br><span class="line"></span><br><span class="line">a[hole] = a[right];</span><br><span class="line">hole = right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左边找大</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= key)</span><br><span class="line">++left;</span><br><span class="line"></span><br><span class="line">a[hole] = a[left];</span><br><span class="line">hole = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[hole] = key;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort2</span>(a, begin, hole - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSort2</span>(a, hole + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li>选择左边界元素作为基准元素 <code>key</code>，并将其位置标记为 <code>hole</code>（坑）</li><li>从右向左扫描，找到第一个小于 <code>key</code> 的元素，将其填入 <code>hole</code> 位置，并更新 <code>hole</code> 为该元素的位置。</li><li>从左向右扫描，找到第一个大于 <code>key</code> 的元素，将其填入 <code>hole</code> 位置，并更新 <code>hole</code> 为该元素的位置。</li><li>不断重复上述两个步骤，直到 <code>left</code> 和 <code>right</code> 相遇。</li><li>最后将基准元素 <code>key</code> 填入最终的 <code>hole</code> 位置</li></ol><p>🔥<strong>值得注意的是：</strong> 在从右向左查找小于 <code>key</code> 的元素时，<code>right</code> 指针会不断向左移动。如果不添加 <code>left &lt; right</code> 这个条件，<code>right</code> 指针可能会一直向左移动，越过 <code>left</code> 指针，导致访问到数组范围之外的元素，从而引发越界错误。例如，当数组中的元素都大于等于 <code>key</code> 时，如果没有 <code>left &lt; right</code> 的限制，<code>right</code> 指针会一直向左移动，最终可能访问到数组的负索引位置，这是不合法的。<code>从左向右查找大于 key 的元素也是同理</code></p><h3 id="前后指针法"><a href="#前后指针法" class="headerlink" title="前后指针法"></a>前后指针法</h3><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f8353d18aec14fa68c126520255bf6f2.gif" alt="请添加图片描述"></p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort3</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> randi = left + (<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[randi]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义基准值以及cur和dest</span></span><br><span class="line"><span class="type">int</span> keyi = left;</span><br><span class="line"><span class="type">int</span> dest = left, cur = left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[cur] &lt; a[keyi] &amp;&amp; ++dest != cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[cur], &amp;a[dest]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无论cur位置的值是否小于基准值，cur都要++，所以留到这里做调整</span></span><br><span class="line">cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[keyi], &amp;a[dest]);</span><br><span class="line"><span class="built_in">QuickSort3</span>(a, left, dest - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSort3</span>(a, dest + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li><code>keyi</code> 是基准元素的索引，初始化为左边界 <code>left</code>，<code>dest</code> 指针用于标记小于基准元素的元素应该放置的位置，初始化为左边界 <code>left</code>，<code>cur</code> 指针用于遍历数组，初始化为 <code>left + 1</code></li><li>如果 <code>cur</code> 位置的值小于基准值，要和 <code>dest</code> 后面的元素进行交换，但是有可能 <code>dest</code> 后面就是 <code>cur</code>，所以我们可以让 <code>dest</code> 先 <code>++</code> ，再和 <code>cur</code> 比较，如果 <code>++dest == cur</code>，说明它们暂时指向同一个元素，无需交换；如果 <code>++dest != cur</code>，说明它们不指向同一个元素，直接交换</li></ol><p>🖱️<strong>复杂度分析：</strong></p><p>• <strong>时间复杂度：</strong></p><p>○ <strong>最好情况：</strong> 当每次选择的基准元素都能将数组均匀地分成两部分时，递归树的深度为 <code>log n</code> ，每层需要处理的元素总数为 <code>n</code>，因此总的时间复杂度为 <code>O(n * log n)</code></p><p>○ <strong>最坏情况：</strong> 最坏情况下，快速排序的时间复杂度会退化为 <code>O(n²)</code></p><p>○ <strong>平均情况：</strong> 时间复杂度为 <code>O(n * log n)</code></p><p>• <strong>空间复杂度：</strong> 时间复杂度为 <code>O(log n)</code></p><p><strong>总结：</strong> <code>快速排序整体的综合性能和使用场景都是比较好的，所以才敢叫快速排序</code></p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p> 因为上面的三种方法均涉及递归，考虑到递归太多数据会导致<code>栈溢出的风险</code>，所以<code>非递归实现快排</code>也很重要</p><p>那么根据我们学过的<code>栈</code>发现其原理：<code>先进后出</code>，比较符合我们排序的效果</p><p>这里我们引入栈的头文件和源文件</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145672800">【初阶数据结构】先来后到的秩序：栈和队列</a></p></blockquote><p> 💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">PartSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> randi = left + (<span class="built_in">rand</span>() % (right - left + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[randi]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyi = left;</span><br><span class="line"><span class="type">int</span> dest = left, cur = left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[cur] &lt; a[keyi] &amp;&amp; ++dest != cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[cur], &amp;a[dest]);</span><br><span class="line">&#125;</span><br><span class="line">cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[keyi], &amp;a[dest]);</span><br><span class="line"><span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSortNonR</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ST st;</span><br><span class="line"><span class="built_in">STInit</span>(&amp;st);</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, right);</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">STEmpty</span>(&amp;st))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> begin = <span class="built_in">STTop</span>(&amp;st);</span><br><span class="line"><span class="built_in">STPop</span>(&amp;st);</span><br><span class="line"><span class="type">int</span> end = <span class="built_in">STTop</span>(&amp;st);</span><br><span class="line"><span class="built_in">STPop</span>(&amp;st);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> keyi = <span class="built_in">PartSort</span>(a, begin, end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyi + <span class="number">1</span> &lt; end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, end);</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, keyi + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; keyi - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, keyi - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">STPush</span>(&amp;st, begin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">STDestroy</span>(&amp;st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/72049c69d504425b8355b37b3a54b100.png" alt="在这里插入图片描述"></p><ol><li>将初始的排序区间 <code>[left, right]</code> 压入栈中。注意，先压入右边界 <code>right</code>，再压入左边界 <code>left</code>，后续出栈时会先得到左边界，符合后续处理逻辑</li><li>从栈中弹出一个区间 <code>[begin, end]</code>，先弹出的是左边界 <code>begin</code>，再弹出右边界 <code>end</code></li><li>调用 <code>PartSort</code> 函数对当前区间 <code>[begin, end]</code> 进行分区操作，得到基准元素的最终位置 <code>keyi</code></li><li>根据基准元素的位置 <code>keyi</code>，将左右子区间压入栈中。如果基准元素右边还有元素<code>（keyi + 1 &lt; end）</code>，则将右子区间 <code>[keyi + 1, end]</code> 压入栈；如果基准元素左边还有元素<code>（begin &lt; keyi - 1）</code>，则将左子区间 <code>[begin, keyi - 1]</code> 压入栈。这样后续会继续对这些子区间进行排序</li></ol><p>🔥<strong>值得注意的是：</strong> 非递归的方式本质上就是借助栈来存区间，然后 <code>PartSort(a, begin, end)</code> 会对数进行交换排序，进行实质的交换</p><h1 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/008068004b874760ae466a357f0175b2.gif" alt="请添加图片描述"></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fd9eb767e96a4fa4bb9d1dd50bc5fa81.png" alt="在这里插入图片描述"><br>假设有这么个区间，两个有序区间，就是不断对两个移动指针比较，把较小的数插入到新空间，形成新的有序序列，然后再赋值回原来的空间</p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _MergeSort(<span class="type">int</span>* a, <span class="type">int</span> begin, <span class="type">int</span> end, <span class="type">int</span>* tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">_MergeSort(a, begin, mid, tmp);</span><br><span class="line">_MergeSort(a, mid + <span class="number">1</span>, end, tmp);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = begin, end1 = mid;</span><br><span class="line"><span class="type">int</span> begin2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line"><span class="type">int</span> i = begin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(a + begin, tmp + begin, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end - begin + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">_MergeSort(a, <span class="number">0</span>, n - <span class="number">1</span>, tmp);</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li>计算中间索引 <code>mid</code>，将当前数组分成两个子数组，分别递归调用 <code>_MergeSort</code> 函数对左右子数组进行排序，<code>从最下面的子数组依次往上归并</code></li><li>初始化两个指针 <code>begin1</code> 和 <code>begin2</code> 分别指向左右子数组的起始位置，<code>end1</code> 和 <code>end2</code> 指向左右子数组的结束位置</li><li>比较 <code>a[begin1]</code> 和 <code>a[begin2]</code> 的大小，将较小的元素放入临时数组 <code>tmp</code> 中，并将相应的指针后移</li><li>当其中一个子数组遍历完后，将另一个子数组中剩余的元素依次放入临时数组 <code>tmp</code> 中</li><li>使用 <code>memcpy</code> 函数将临时数组 <code>tmp</code> 中排好序的元素复制回原数组 <code>a</code> 中</li></ol><p>🔥<strong>值得注意的是：</strong> <code>memcpy(a + begin, tmp + begin, sizeof(int) * (end - begin + 1))</code>，而不是 <code>memcpy(a, tmp, sizeof(int) * (end - begin + 1))</code>，为了在临时数组中准确找到当前子数组合并结果的起始位置，以便将排好序的数据正确地复制回原数组</p><h2 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>同理，为了<code>避免栈溢出</code>，<code>归并排序</code>也有<code>非递归实现</code></p><p><strong>为什么不用栈处理？</strong></p><blockquote><p><code>栈的非递归实现</code>其实是类似于<code>前序遍历</code>的，而<code>归并的非递归实现</code>类似于<code>后序遍历</code></p></blockquote><p>💻<strong>排序实现：</strong></p><h3 id="一次性全部拷贝回去：memcpy-a-tmp-sizeof-int-n"><a href="#一次性全部拷贝回去：memcpy-a-tmp-sizeof-int-n" class="headerlink" title="一次性全部拷贝回去：memcpy(a, tmp, sizeof(int) * n)"></a>一次性全部拷贝回去：memcpy(a, tmp, sizeof(int) * n)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortNonR1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end1 &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">end1 = n - <span class="number">1</span>;</span><br><span class="line">begin2 = n;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (begin2 &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">begin2 = n;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(a, tmp, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line">gap *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a141e4d6ee944d0588944b95df65911d.png" alt="在这里插入图片描述"><br><code>gap</code> 表示一组有多少个数据，<code>gap = 1</code> 时一个一个归并，<code>gap = 2</code> 时两个两个归并，依次向后推，不断扩大 <code>gap</code> 实现有序</p><p>根据规律写出 <code>int begin1 = i, end1 = i + gap - 1</code>；<code>int begin2 = i + gap, end2 = i + 2 * gap - 1</code>；</p><p>但是我们发现这套规律只适用于<code>偶数个数的归并</code>，当为奇数时会出现&#96;多出来一个数无法进行归并的情况，所以我们要针对这种情况进行修正</p><ol><li><strong>end1 越界示例</strong><br>假设我们有一个长度 <code>n = 5</code> 的数组 <code>arr = [1, 2, 3, 4, 5]</code>，当 <code>gap = 4</code> 时，开始进行合并操作</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bf564d83058547beb1081c356035215c.png" alt="在这里插入图片描述"></p><p><strong>计算过程：</strong></p><p>当 <code>i = 0</code> 时：<code>begin1 = i = 0</code>，<code>end1 = i + gap - 1 = 0 + 4 - 1 = 3</code>，这是正常的，因为数组索引 <code>3</code> 在有效范围内（数组索引范围是 <code>0</code> 到 <code>4</code>）</p><p>当 <code>i = 4</code> 时：<code>begin1 = i = 4</code>，<code>end1 = i + gap - 1 = 4 + 4 - 1 = 7</code>，而数组的最大有效索引是 <code>4</code>，此时 <code>end1</code> 超出了数组的边界，出现越界情况</p><p><strong>修正方法：</strong> <code>end1 = n - 1</code>，<code>begin2 = n</code>，<code>end2 = n - 1</code>，因为是整体赋值，让有效的数据按原路返回，后面的修正为一个不存在的区间，也就不会归并了，那么就有个问题，后面的数不就无序了吗？其实前面的排序保证了其有序性，在 gap 进一步扩大的过程中会将其逐步变为有序</p><ol start="2"><li><strong>begin2 越界示例</strong><br>同样使用长度 <code>n = 5</code> 的数组 <code>arr = [1, 2, 3, 4, 5]</code>，当 <code>gap = 3</code> 时进行分析</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c933c90c07f54dfd9432885887236e30.png" alt="在这里插入图片描述"></p><p><strong>计算过程：</strong></p><p>当 <code>i = 2</code> 时：<code>begin1 = i = 2</code>，<code>end1 = i + gap - 1 = 2 + 3 - 1 = 4</code>，这是正常的，<code>begin2 = i + gap = 2 + 3 = 5</code>，数组的最大有效索引是 <code>4</code>，所以 <code>begin2</code> 超出了数组的边界，出现越界情况</p><p><strong>修正方法：</strong> 同 <code>end1</code> 越界处理情况相同</p><ol start="3"><li><strong>end2 越界示例</strong></li></ol><p>还是以长度 <code>n = 5</code> 的数组 <code>arr = [1, 2, 3, 4, 5]</code> 为例，当 <code>gap = 3</code> 时进行分析</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/22d2efb3e5a44827825103f8a98325a7.png" alt="在这里插入图片描述"></p><p><strong>计算过程：</strong></p><p>当 <code>i = 0</code> 时：<code>begin1 = i = 0</code>，<code>end1 = i + gap - 1 = 0 + 3 - 1 = 2</code>，<code>begin2 = i + gap = 0 + 3 = 3</code>，<code>end2 = i + 2 * gap - 1 = 0 + 2 * 3 - 1 = 5</code>，数组的最大有效索引是 <code>4</code>，所以 <code>end2</code> 超出了数组的边界，出现越界情况</p><p><strong>修正方法：</strong> <code>end2 = n - 1</code>，将有效数据纳入进行排序，剩余的数在 <code>gap</code> 扩大时会得到处理</p><h3 id="分批次拷贝回去：memcpy-a-i-tmp-i-sizeof-int-end2-i-1"><a href="#分批次拷贝回去：memcpy-a-i-tmp-i-sizeof-int-end2-i-1" class="headerlink" title="分批次拷贝回去：memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1))"></a>分批次拷贝回去：memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1))</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSortNonR2</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* tmp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span> * gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> begin1 = i, end1 = i + gap - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> begin2 = i + gap, end2 = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end1 &gt;= n || begin2 &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (end2 &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">end2 = n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[begin1] &lt; a[begin2])</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin1 &lt;= end1)</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin1++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (begin2 &lt;= end2)</span><br><span class="line">&#123;</span><br><span class="line">tmp[j++] = a[begin2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(a + i, tmp + i, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (end2 - i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">gap *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><p><strong>一次性拷贝回去需要调整 end1、begin1 等边界：</strong></p><blockquote><p>一次性拷贝回去意味着我们要把合并好的结果一次性从临时数组 <code>tmp</code> 复制回原数组 <code>a</code>。在这个过程中，如果出现越界情况，比如 <code>end1</code> 或 <code>end2</code> 超出了数组长度，我们需要调整这些边界，以确保只处理有效的数组元素，避免访问非法内存</p></blockquote><p><strong>分批次拷贝回去直接 break：</strong></p><blockquote><p>分批次拷贝回去通常是指在发现越界情况时，由于后续没有有效的子数组可供合并，直接终止当前的合并操作，等待下一轮更大的 <code>gap</code> 再处理剩余元素。这种方式简化了越界处理逻辑，因为不需要对越界的边界进行复杂的调整</p></blockquote><p><strong>end1、begin2 越界：</strong> <code>break</code>，等待 <code>gap</code> 增大时处理未处理的数据</p><p><strong>end2 越界：</strong> 和一次性拷贝的处理相同</p><p>🔥<strong>值得注意的是：</strong> <code>memcpy(a + i, tmp + i, sizeof(int) * (end2 - i + 1)) </code>不能写成 <code>memcpy(a + begin1, tmp + begin1, sizeof(int) * (end2 - begin1 + 1))</code>，因为 <code>begin1</code> 被移动了，<code>i</code> 才是原来的初始位置</p><h1 id="6-排序复杂度及效率对比"><a href="#6-排序复杂度及效率对比" class="headerlink" title="6.排序复杂度及效率对比"></a>6.排序复杂度及效率对比</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8dc0c902262b4c0d809d2723b26aa11b.jpeg" alt="请添加图片描述"></p><p>💻<strong>测试代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span>* a1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a2 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a3 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a4 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a5 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a6 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a7 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a8 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a9 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a10 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a11 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="type">int</span>* a12 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a1[i] = <span class="built_in">rand</span>();</span><br><span class="line">a2[i] = a1[i];</span><br><span class="line">a3[i] = a1[i];</span><br><span class="line">a4[i] = a1[i];</span><br><span class="line">a5[i] = a1[i];</span><br><span class="line">a6[i] = a1[i];</span><br><span class="line">a7[i] = a1[i];</span><br><span class="line">a8[i] = a1[i];</span><br><span class="line">a9[i] = a1[i];</span><br><span class="line">a10[i] = a1[i];</span><br><span class="line">a11[i] = a1[i];</span><br><span class="line">a12[i] = a1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">InsertSort</span>(a1, N);</span><br><span class="line"><span class="type">int</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">ShellSort</span>(a2, N);</span><br><span class="line"><span class="type">int</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin3 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">SelectSort</span>(a3, N);</span><br><span class="line"><span class="type">int</span> end3 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin4 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">HeapSort</span>(a4, N);</span><br><span class="line"><span class="type">int</span> end4 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin5 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">QuickSort1</span>(a5, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> end5 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin8 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">QuickSort2</span>(a8, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> end8 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin9 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">QuickSort3</span>(a9, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> end9 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin10 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">QuickSortNonR</span>(a9, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> end10 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin6 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">MergeSort</span>(a6, N);</span><br><span class="line"><span class="type">int</span> end6 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin11 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">MergeSortNonR1</span>(a11, N);</span><br><span class="line"><span class="type">int</span> end11 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin12 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">MergeSortNonR1</span>(a12, N);</span><br><span class="line"><span class="type">int</span> end12 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin7 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">BubbleSort</span>(a7, N);</span><br><span class="line"><span class="type">int</span> end7 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;InsertSort:%d\n&quot;</span>, end1 - begin1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ShellSort:%d\n&quot;</span>, end2 - begin2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SelectSort:%d\n&quot;</span>, end3 - begin3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HeapSort:%d\n&quot;</span>, end4 - begin4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;BubbleSort:%d\n&quot;</span>, end7 - begin7);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;QuickSort1:%d\n&quot;</span>, end5 - begin5);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;QuickSort2:%d\n&quot;</span>, end8 - begin8);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;QuickSort3:%d\n&quot;</span>, end9 - begin9);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;QuickSortNonR:%d\n&quot;</span>, end10 - begin10);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MergeSort:%d\n&quot;</span>, end6 - begin6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MergeSortNonR1:%d\n&quot;</span>, end11 - begin11);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MergeSortNonR2:%d\n&quot;</span>, end12 - begin12);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a1);</span><br><span class="line"><span class="built_in">free</span>(a2);</span><br><span class="line"><span class="built_in">free</span>(a3);</span><br><span class="line"><span class="built_in">free</span>(a4);</span><br><span class="line"><span class="built_in">free</span>(a5);</span><br><span class="line"><span class="built_in">free</span>(a6);</span><br><span class="line"><span class="built_in">free</span>(a7);</span><br><span class="line"><span class="built_in">free</span>(a8);</span><br><span class="line"><span class="built_in">free</span>(a9);</span><br><span class="line"><span class="built_in">free</span>(a10);</span><br><span class="line"><span class="built_in">free</span>(a11);</span><br><span class="line"><span class="built_in">free</span>(a12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>测试结果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e3f6e6a48ea3413e9449524337257e78.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b199b4a8406e4021801be6f012f45a37.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】星河中的光影 “排” 象：排序（上）</title>
      <link href="/2025/02/25/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/02/25/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="排序的概念及分类"><a href="#排序的概念及分类" class="headerlink" title="排序的概念及分类"></a>排序的概念及分类</h1><blockquote><p>排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作</p></blockquote><p><strong>常见的排序算法的可以按如图所示分类：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45966cfff05c4ba3b602d4c97487975e.png" alt="在这里插入图片描述"></p><p>以下所有的排序算法均以<code>升序的方式</code>实现</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序（InsertSort）"><a href="#直接插入排序（InsertSort）" class="headerlink" title="直接插入排序（InsertSort）"></a>直接插入排序（InsertSort）</h2><p><code>直接插入排序</code>是一种简单的插入排序法，<strong>其基本思想是：</strong> 把待排序的记录按其<code>关键码值的大小</code>逐个插入到一个<code>已经排好序的有序序列</code>中，直到所有的记录插入完为止，得到<code>一个新的有序序列</code></p><p>简单来说我们平常玩的<code>扑克牌游戏就是一种插入排序</code>：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4583dc8fe4764ac49d0b69d0de08065a.png" alt="在这里插入图片描述"></p><p><strong>排序原理：</strong> </p><p>当插入第 <code>i ( i &gt;= 1 )</code> 个元素时，前面的 <code>array[0]</code> ，<code>array[1]</code> ，<code>…</code> ，<code>array[i-1]</code> 已经排好序，此时用 <code>array[i]</code> 的排序码与 <code>array[i - 1]</code> ，<code>array[i - 2]</code> ，<code>…</code> 的排序码顺序进行比较，找到插入位置即将 <code>array[i]</code> 插入，原来位置上的元素顺序后移</p><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/95279ef3f63546a69e1602621d48814f.gif" alt="请添加图片描述"></p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp = a[i];</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">a[end + <span class="number">1</span>] = a[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[end + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li>第一个 <code>for</code> 循环指的是从第一个数开始依次往后遍历，<code>end</code> 指向已排序部分的最后一个元素（即开始的 <code>a[0]</code> ），<code>tmp = a[i]</code> 提前保存该位置的数据，避免移动时的覆盖消除该数据。</li><li>从后往前遍历已排序部分，找到合适的插入位置，<code>如果当前要插入的元素小于已排序部分的元素</code>，将已排序部分的元素后移一位，<code>--end</code> 继续向前比较；<code>如果找到合适的插入位置</code>，<code>break</code> 退出循环</li><li>找到合适位置后，<code>a[end + 1] = tmp</code> 将当前要插入的元素插入到合适的位置</li></ol><p>🖱️<strong>复杂度分析：</strong></p><p>• <strong>时间复杂度：</strong></p><p>○ <strong>最好情况：</strong> <code>数组已经是有序的</code>，此时内层的 <code>while</code> 循环每次只需要比较一次就会退出，时间复杂度为 <code>O(n)</code></p><p>○ <strong>最坏情况：</strong> <code>数组是逆序的</code>，内层的 <code>while</code> 循环每次都需要<code>比较到已排序部分的第一个元素</code>，时间复杂度为 <code>O(n²)</code></p><p>○ <strong>平均情况：</strong> 时间复杂度为 <code>O(n²)</code></p><p>• <strong>空间复杂度：</strong> <code>O(1)</code></p><p><strong>总结：</strong><code>元素集合越接近有序，直接插入排序算法的时间效率越高</code></p><h2 id="希尔排序（ShellSort）"><a href="#希尔排序（ShellSort）" class="headerlink" title="希尔排序（ShellSort）"></a>希尔排序（ShellSort）</h2><p><code>希尔排序</code>又称<code>缩小增量法</code>。<strong>其基本思想是：</strong> 先选定一个整数 <code>gap</code> ，把待排序文件中所有记录分成多个组，所有距离为 <code>gap</code> 的记录分在同一组内，并对每一组内的记录进行排序。然后，取新的 <code>gap</code> ，重复上述分组和排序的工作。当到达 <code>gap = 1</code> 时，所有记录在统一组内排好序</p><p><strong>分组如图所示：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a4a9dacd8c04066ac40234eda19cfeb.png" alt="在这里插入图片描述"></p><p>相同颜色的数字为同一组</p><p>💻<strong>排序实现：</strong></p><p><strong>版本1：</strong> 按组分配排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; gap; j++)</span><br><span class="line">&#123;</span><br><span class="line">gap /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; n - gap; i += gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = a[i + gap];</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">a[end + gap] = a[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[end + gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>版本2：</strong> 依次排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> gap = n;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap /= <span class="number">2</span>;</span><br><span class="line"><span class="comment">//gap = n / 3 + 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - gap; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> end = i;</span><br><span class="line"><span class="type">int</span> tmp = a[i + gap];</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; a[end])</span><br><span class="line">&#123;</span><br><span class="line">a[end + gap] = a[end];</span><br><span class="line">end -= gap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[end + gap] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><p>希尔排序其实和插入排序是十分相似的，<code>希尔排序是对直接插入排序的优化</code>，只不过是每间隔 <code>gap</code> 个数进行排序，插入排序间隔是 <code>1</code> ，通过多次 <code>gap</code> 的改变，多次的分组排序最终能趋向于有序</p><p>🔥<strong>值得注意的是：</strong> </p><ol><li><code>for</code> 循环中 <code>i &lt; n - gap</code> 是因为排完序后剩下的数根据 <code>gap</code> 的大小，剩下的数已经自动有序了</li><li><code>gap /= 2</code> 和 <code>gap = n / 3 + 1</code> 都是可以的，并没有严格的限制</li><li><code>tmp</code> 一直在 <code>end</code> 的下一个位置，插入的位置一直在 <code>end</code> 的下一个位置</li><li>当 <code>gap &gt; 1</code> 时都是预排序，目的是让数组更接近于有序。当 <code>gap == 1</code> 时，数组已经接近有序的了，这样就会很快</li><li>希尔排序的时间复杂度不好计算，因为 <code>gap</code> 的取值方法很多，导致很难去计算，因此在好些书中给出的希尔排序的时间复杂度都不固定</li></ol><p><strong>《数据结构(C语言版)》— 严蔚敏：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e017d83ca7b3454a81661b7067816496.png" alt="在这里插入图片描述"></p><p>🖱️<strong>复杂度分析：</strong></p><p>• <strong>时间复杂度：</strong></p><p>○ <strong>最好情况：</strong> <code>数组已经是有序的</code>，时间复杂度为 <code>O(n)</code></p><p>○ <strong>最坏情况：</strong> <code>数组是逆序的</code>，时间复杂度为 <code>O(n²)</code></p><p>○ <strong>平均情况：</strong> 时间复杂度大约为 O($n^{1.3}$)</p><p>• <strong>空间复杂度：</strong> <code>O(1)</code></p><p><strong>总结：</strong> <code>希尔排序是不稳定的</code></p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序（SelectSort）"><a href="#直接选择排序（SelectSort）" class="headerlink" title="直接选择排序（SelectSort）"></a>直接选择排序（SelectSort）</h2><p><code>直接选择排序</code>可以说是最简单的一种排序了，<strong>其基本思想为：</strong> 每一次从<code>待排序的数据元素</code>中选出<code>最小（或最大）</code>的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完 </p><p><strong>排序原理：</strong></p><ol><li>在元素集合 <code>array[i]</code> – <code>array[n-1]</code> 中选择关键码最大(小)的数据元素</li><li>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换</li><li>在剩余的 <code>array[i]</code> – <code>array[n-2]</code>（<code>array[i+1]</code> – <code>array[n-1]</code>）集合中，重复上述步骤，直到集合剩余 <code>1</code> 个元素</li></ol><p><strong>动图理解：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b13b6c3eb7f646afbd2bdfc7bf27fd56.gif" alt="请添加图片描述"></p><p>💻<strong>排序实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mini = left, maxi = right;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[mini])</span><br><span class="line">&#123;</span><br><span class="line">mini = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[maxi])</span><br><span class="line">&#123;</span><br><span class="line">maxi = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[left], &amp;a[mini]);</span><br><span class="line"><span class="comment">//如果left和maxi重叠，交换后修正一下</span></span><br><span class="line"><span class="keyword">if</span> (left == maxi)</span><br><span class="line">&#123;</span><br><span class="line">maxi = mini;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[right], &amp;a[maxi]);</span><br><span class="line"></span><br><span class="line">++left;</span><br><span class="line">--right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码解读：</strong> </p><ol><li><code>mini</code> 初始化为 <code>left</code>，<code>maxi</code> 初始化为 <code>right</code>，用于记录当前未排序部分的最小值和最大值的索引</li><li>通过 <code>for</code> 循环从 <code>left</code> 到 <code>right</code> 遍历数组，比较每个元素与 <code>a[mini]</code> 和 <code>a[maxi]</code> 的大小，如果发现更小的元素则更新 <code>mini</code>，如果发现更大的元素则更新 <code>maxi</code></li><li>调用 <code>Swap</code> 函数将最小值 <code>a[mini]</code> 交换到左边界 <code>a[left]</code> 的位置，最大值 <code>a[maxi]</code> 交换到右边界 <code>a[right]</code> 的位置</li><li><code>++left</code> 和 <code>--right</code> 分别将左边界右移和右边界左移，缩小未排序部分的范围</li></ol><p>🔥<strong>值得注意的是：</strong> 如果 <code>left</code> 恰好等于 <code>maxi</code>，说明在交换最小值时，最大值的位置已经被交换到了 <code>mini</code> 处，所以需要将 <code>maxi</code> 更新为 <code>mini</code></p><p>🖱️<strong>复杂度分析：</strong></p><p>• <strong>时间复杂度：</strong></p><p>○ <strong>最好情况：</strong> 即使数组已经有序，每一轮仍然需要遍历未排序部分来确定最小值和最大值的位置，时间复杂度为 <code>O(n)</code></p><p>○ <strong>最坏情况：</strong> 当数组是逆序排列时，同样需要进行完整的遍历和交换操作，时间复杂度为 <code>O(n²)</code></p><p>○ <strong>平均情况：</strong> 时间复杂度为 <code>O(n²)</code></p><p>• <strong>空间复杂度：</strong> <code>O(1)</code></p><p><strong>总结：</strong> <code>直接选择排序思考非常好理解，但是效率不是很好，实际中很少使用</code></p><h2 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h2><p><code>堆排序</code>是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。需要注意的是<code>排升序要建大堆</code>，<code>排降序建小堆</code></p><p>在<code>堆的专题章节</code>已经有详细的分析了，这里就不过多讲解</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145785085?spm=1001.2014.3001.5501">【初阶数据结构】森林里的树影 “堆” 光：堆</a></p></blockquote><p><strong>总结：</strong> <code>堆排序使用堆来选数，效率就高了很多</code></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5fbcca0d153a49e5a210ec4d78edd5d7.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序算法 </tag>
            
            <tag> 希尔排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】节点层级的逻辑乐章：二叉树</title>
      <link href="/2025/02/24/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2025/02/24/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本章节是树结构的最后一篇——二叉树，这里我们只实现最简单的二叉树结构，在C++语法部分将学习更高阶的AVL树、红黑树巩固</p><h1 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> BTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">BTDataType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>* left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>* right;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure><p>再看二叉树基本操作前，再回顾下二叉树的概念，<strong>二叉树是：</strong></p><ol><li><strong>空树</strong></li><li><strong>非空：根结点，根结点的左子树、根结点的右子树组成的</strong></li></ol><h1 id="二叉树接口实现"><a href="#二叉树接口实现" class="headerlink" title="二叉树接口实现"></a>二叉树接口实现</h1><h2 id="二叉树节点创建"><a href="#二叉树节点创建" class="headerlink" title="二叉树节点创建"></a>二叉树节点创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BuyNode</span><span class="params">(BTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTNode* node = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode));</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node-&gt;data = x;</span><br><span class="line">node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>malloc</code> 函数为新节点分配内存，其大小为 <code>BTNode</code> 结构体的大小</li><li>检查内存分配是否成功。如果 <code>malloc</code> 返回 <code>NULL</code>，表示内存分配失败，使用 <code>perror</code> 函数输出错误信息，并返回 <code>NULL</code></li><li>若内存分配成功，将传入的数据 <code>x</code> 赋值给新节点的 <code>data</code> 成员</li><li>将新节点的左右子指针 <code>left</code> 和 <code>right</code> 都初始化为 <code>NULL</code>，表示该节点暂时没有左右子节点</li><li>返回新创建的节点指针</li></ol><h2 id="二叉树树的创建"><a href="#二叉树树的创建" class="headerlink" title="二叉树树的创建"></a>二叉树树的创建</h2><p>在学习二叉树的基本操作前，需先要创建一棵二叉树，然后才能学习其相关的基本操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">CreatTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BTNode* node1 = <span class="built_in">BuyNode</span>(<span class="number">1</span>);</span><br><span class="line">BTNode* node2 = <span class="built_in">BuyNode</span>(<span class="number">2</span>);</span><br><span class="line">BTNode* node3 = <span class="built_in">BuyNode</span>(<span class="number">3</span>);</span><br><span class="line">BTNode* node4 = <span class="built_in">BuyNode</span>(<span class="number">4</span>);</span><br><span class="line">BTNode* node5 = <span class="built_in">BuyNode</span>(<span class="number">5</span>);</span><br><span class="line">BTNode* node6 = <span class="built_in">BuyNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">node1-&gt;left = node2;</span><br><span class="line">node1-&gt;right = node4;</span><br><span class="line">node2-&gt;left = node3;</span><br><span class="line">node4-&gt;left = node5;</span><br><span class="line">node4-&gt;right = node6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于现在对二叉树结构掌握还不够深入，为了降低学习成本，此处手动快速创建一棵简单的二叉树，快速进入二叉树操作学习，等二叉树结构了解的差不多时，我们反过头再来研究二叉树真正的创建方式</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d4accca304014521a62219370a7271bb.png" alt="请添加图片描述"></p><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line"><span class="built_in">PreOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">PreOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>前序遍历</code>依据<code>根</code>、<code>左子树</code>、<code>右子树</code>的顺序，<code>前序遍历</code>又叫做<code>深度优先遍历（DFS）</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/684ea429f58a4269bb58ea4bff3c1eea.jpeg" alt="请添加图片描述"></p><p>其本质上是一个<code>有限递归</code>的过程，当<code>左节点</code>递归到<code>最后一个叶节点</code>时，其<code>子节点</code>为 <code>NULL</code> ，<code>向下递归</code>就结束，然后开始回退遍历<code>右节点</code></p><p>🔥<strong>值得注意的是：</strong> <code>root == NULL</code> 的 <code>if</code> 条件句既是为了表示空树的情况，也是为了结束向下递归的过程</p><p>💻<strong>测试结果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9251dde5c4ce44b586f3a05f560bd126.png" alt="在这里插入图片描述"></p><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">InOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line"><span class="built_in">InOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>中序遍历</code>依据<code>左子树</code>、<code>根</code>、<code>右子树</code>的顺序</p><p>其余操作和前序遍历一致</p><p>💻<strong>测试结果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d372ab7801654cb4954ad71ca83e2212.png" alt="在这里插入图片描述"></p><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL &quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PostOrder</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">PostOrder</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>后序遍历</code>依据<code>左子树</code>、<code>右子树</code>、<code>根</code>的顺序</p><p>其余操作和前序遍历一致</p><p>💻<strong>测试结果：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/03c2105cf8684a659494b158a9653a26.png" alt="在这里插入图片描述"></p><h2 id="二叉树结点个数"><a href="#二叉树结点个数" class="headerlink" title="二叉树结点个数"></a>二叉树结点个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeSize</span><span class="params">(BTNode* root, <span class="type">int</span>* psize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">++(*psize);</span><br><span class="line"><span class="built_in">TreeSize</span>(root-&gt;left, psize);</span><br><span class="line"><span class="built_in">TreeSize</span>(root-&gt;right, psize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取节点个数首先想到的肯定是遍历二叉树，如上代码所示的方法，用一个移动指针遍历，每到一个节点就 ++ ，这固然可行，但是有更直观简洁的方法</p><p>⌨️<strong>优化代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeSize</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="literal">NULL</span> ? <span class="number">0</span> :</span><br><span class="line"><span class="built_in">TreeSize</span>(root-&gt;left)</span><br><span class="line">+ <span class="built_in">TreeSize</span>(root-&gt;right)</span><br><span class="line">+ <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式就像学校里的人数统计一样，假设想要统计全校寝室人数</p><ol><li>寝室长统计寝室人数，汇报给宿管阿姨</li><li>宿管阿姨统计每栋宿舍人数，汇报给专业年级主任</li><li>专业年级主任统计专业人数，汇报给校长</li><li>最后由校长汇总专业年级主任上交的数据，就能得出全校寝室人数</li></ol><p>这是一种清晰的统计流程，<code>二叉树结点个数就是从最底下逐渐往上加和进行统计</code></p><h2 id="二叉树高度获取"><a href="#二叉树高度获取" class="headerlink" title="二叉树高度获取"></a>二叉树高度获取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeHeight</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">TreeHeight</span>(root-&gt;left) &gt; <span class="built_in">TreeHeight</span>(root-&gt;right)</span><br><span class="line">? <span class="built_in">TreeHeight</span>(root-&gt;left) + <span class="number">1</span> : <span class="built_in">TreeHeight</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>二叉树高度获取</code>的思想和<code>二叉树结点个数</code>是一致的，高度取决于<code>左子树</code>和<code>右子树</code>路径较长的那条，直接比较然后递归取值即可</p><p>但是这段代码有个问题，<code>比较时需要递归一次</code>，比较完并没有保存每个节点高度的结果，<code>获取结果的时候又要再递归一次</code>，导致代码效率减慢</p><p>⌨️<strong>优化代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeHeight</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">TreeHeight</span>(root-&gt;left);</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">TreeHeight</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftHeight &gt; rightHeight </span><br><span class="line">? leftHeight + <span class="number">1</span> </span><br><span class="line">: rightHeight + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以每次向上回退时，<code>保存每个节点的高度结果即可</code></p><h2 id="二叉树第k层节点个数"><a href="#二叉树第k层节点个数" class="headerlink" title="二叉树第k层节点个数"></a>二叉树第k层节点个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TreeKLevel</span><span class="params">(BTNode* root, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leftK = <span class="built_in">TreeKLevel</span>(root-&gt;left, k - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> rightK = <span class="built_in">TreeKLevel</span>(root-&gt;right, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftK + rightK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是利用递归的思想，假设要<code>获取第三层的节点个数</code>，那么需要<code>向上递归两次</code>到达根节点，所以是 <code>k - 1</code> 次</p><p>从下往上数层数</p><ul><li><p>根节点处于第 <code>1</code> 层，对于根节点的左子节点和右子节点，它们处于第 <code>2</code> 层，距离第 <code>3</code> 层还有 <code>1</code> 层，所以递归调用 <code>TreeKLevel(root-&gt;left, 2)</code> 和 <code>TreeKLevel(root-&gt;right, 2)</code></p></li><li><p>当递归到第 <code>2</code> 层的节点时，对于它们的子节点（即第 <code>3</code> 层的节点），再次递归调用时传入 <code>k - 1</code> 即 <code>1</code>，此时满足 <code>k == 1</code> 的条件，返回 <code>1</code> 表示找到了一个第 <code>3</code> 层的节点</p></li><li><p>通过不断地递归调用并使用 <code>k - 1</code> 作为新的层数参数，最终可以准确计算出二叉树中第 <code>k</code> 层的节点总数</p></li></ul><h2 id="二叉树查找值为x的节点"><a href="#二叉树查找值为x的节点" class="headerlink" title="二叉树查找值为x的节点"></a>二叉树查找值为x的节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">TreeFind</span><span class="params">(BTNode* root, BTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;data == x)</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">BTNode* lret = <span class="built_in">TreeFind</span>(root-&gt;left, x);</span><br><span class="line"><span class="keyword">if</span> (lret)</span><br><span class="line"><span class="keyword">return</span> lret;</span><br><span class="line"></span><br><span class="line">BTNode* rret = <span class="built_in">TreeFind</span>(root-&gt;right, x);</span><br><span class="line"><span class="keyword">if</span> (rret)</span><br><span class="line"><span class="keyword">return</span> rret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>递归查找左子树：</strong><br>如果上述两个 <code>if</code> 条件都不满足，说明当前节点不是目标节点，需要继续在其左子树中查找。递归调用 <code>TreeFind(root-&gt;left, x)</code> 来查找左子树中是否存在值为 <code>x</code> 的节点，并将返回结果存储在 <code>lret</code> 中。如果 <code>lret</code> 不为 <code>NULL</code>，说明在左子树中找到了目标节点，直接返回 <code>lret</code></li><li><strong>递归查找右子树</strong><br>如果在左子树中未找到目标节点（即 <code>lret</code> 为 <code>NULL</code>），则继续在右子树中查找。递归调用 <code>TreeFind(root-&gt;right, x)</code> 来查找右子树中是否存在值为 <code>x</code> 的节点，并将返回结果存储在 <code>rret</code> 中。如果 <code>rret</code> 不为 <code>NULL</code>，说明在右子树中找到了目标节点，直接返回 <code>rret</code></li><li><strong>未找到目标节点</strong><br>如果在左子树和右子树中都未找到值为 <code>x</code> 的节点，说明整个二叉树中不存在该节点，函数最终返回 <code>NULL</code></li></ul><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue q;</span><br><span class="line"><span class="built_in">QueueInit</span>(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">QueueEmpty</span>(&amp;q))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = <span class="built_in">QueueFront</span>(&amp;q);</span><br><span class="line"><span class="built_in">QueuePop</span>(&amp;q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, front-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;left)</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, front-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front-&gt;right)</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, front-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QueueDestroy</span>(&amp;q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>层序遍历</code>就是<code>从上到下</code>，<code>从左到右</code>进行遍历，<code>层序遍历</code>也叫作<code>广度优先遍历（BFS）</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5fb1dbd919a843dc8ed40f3ba75ab637.jpeg" alt="请添加图片描述"></p><p>这里需要利用<code>队列的特性</code>来进行，出上一层，带入下一层（每出一个节点，就插入该节点的子节点）引入<code>队列的头文件和源文件</code></p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145672800?spm=1001.2014.3001.5502">【初阶数据结构】先来后到的秩序：栈和队列</a></p></blockquote><p>🔥<strong>值得注意的是：</strong> <code>BTNode* front = QueueFront(&amp;q)</code> 保存了二叉树的节点作为队列的头节点，释放时并不会影响到二叉树本身，而是释放队列头节点</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aaaed02aef4f430b85ea549d89c0d9c7.png" alt="在这里插入图片描述"></p><h2 id="判断是否为完全二叉树"><a href="#判断是否为完全二叉树" class="headerlink" title="判断是否为完全二叉树"></a>判断是否为完全二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TreeComplete</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue q;</span><br><span class="line"><span class="built_in">QueueInit</span>(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (root)</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">QueueEmpty</span>(&amp;q))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = <span class="built_in">QueueFront</span>(&amp;q);</span><br><span class="line"><span class="built_in">QueuePop</span>(&amp;q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, front-&gt;left);</span><br><span class="line"><span class="built_in">QueuePush</span>(&amp;q, front-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">QueueEmpty</span>(&amp;q))</span><br><span class="line">&#123;</span><br><span class="line">BTNode* front = <span class="built_in">QueueFront</span>(&amp;q);</span><br><span class="line"><span class="built_in">QueuePop</span>(&amp;q);</span><br><span class="line"><span class="keyword">if</span> (front)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">QueueDestroy</span>(&amp;q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">QueueDestroy</span>(&amp;q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要知道一个特性：<code>完全二叉树的非空节点一定是连续的</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a0797ae0ba2843bfbc773a2cedc05c4c.png" alt="在这里插入图片描述"></p><p><code>第一个循环是层序遍历二叉树</code>，直到遇到第一个空就停下来，<code>第二个循环是检查队列中剩余的节点是否都为空</code>，继续遍历队列中剩余的节点，<strong>如果遇到非空节点</strong>，说明该二叉树不是完全二叉树，返回 <code>false</code>；<strong>如果队列中剩余的节点都为空</strong>，说明该二叉树是完全二叉树，返回 <code>true</code></p><h2 id="二叉树的销毁"><a href="#二叉树的销毁" class="headerlink" title="二叉树的销毁"></a>二叉树的销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TreeDestroy</span><span class="params">(BTNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeDestroy</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">TreeDestroy</span>(root-&gt;right);</span><br><span class="line"><span class="built_in">free</span>(root);</span><br><span class="line">root == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://i-blog.csdnimg.cn/direct/e278f1eedf044534bc6df1c0c651942d.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】森林里的树影 “堆” 光：堆</title>
      <link href="/2025/02/21/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/"/>
      <url>/2025/02/21/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>初步了解了关于树型结构的知识与结构后，堆的功能实现能帮我们学会一种排序——堆排序，二叉树也是很重要的一种文件式的结构</p><p>在学习本专题前，请详细学习有关树的知识与结构</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145785028">【初阶数据结构】树型数据的勘探：树</a></p></blockquote><h1 id="堆的概念及结构"><a href="#堆的概念及结构" class="headerlink" title="堆的概念及结构"></a>堆的概念及结构</h1><blockquote><p>如果有一个关键码的集合 K &#x3D; {$k_0$，$k_1$， $k_2$，…，$k_{n-1}$}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足：$K_i$ &lt;&#x3D; $K_{2<em>i+1}$ 且 $K_i$&lt;&#x3D; $K_{2*i+2}$ ($K_i$ &gt;&#x3D; $K_{2</em>i+1}$ 且 $K_i$ &gt;&#x3D; $K_{2*i+2}$)  i &#x3D; 0，1，2…，则称为小堆(或大堆)。将<code>根结点最大的堆</code>叫做<code>最大堆</code>或<code>大根堆</code>，<code>根结点最小的堆</code>叫做<code>最小堆</code>或<code>小根堆</code></p></blockquote><p><strong>堆的性质：</strong></p><p>🚩堆中某个结点的值总是<code>不大于</code>或<code>不小于</code>其<code>父结点的值</code></p><p>🚩堆总是一棵<code>完全二叉树</code></p><p><strong>堆的结构：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> HPDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Heap</span></span><br><span class="line">&#123;</span><br><span class="line">HPDataType* a;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line">&#125;HP;</span><br></pre></td></tr></table></figure><p><code>堆的本质就是一个动态数组</code>，把<code>数组以堆的形式</code>呈现出来而已，所以在实现堆的功能时要多画图来帮助理解</p><h1 id="堆的接口实现"><a href="#堆的接口实现" class="headerlink" title="堆的接口实现"></a>堆的接口实现</h1><h2 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapInit</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line">php-&gt;a = (HPDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HPDataType) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (php-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">php-&gt;size = <span class="number">0</span>;</span><br><span class="line">php-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>熟悉的初始化配方：</strong></p><ol><li>判断是否为空指针</li><li>创建空间，注意是否会因为开辟失败造成空指针</li><li>初始化变量 <code>size</code> 和 <code>capacity</code></li></ol><p>🔥<strong>值得注意的是：</strong> 参数的指针<code>浅拷贝</code>，指向同一块空间，能够改变该空间里的内容，不涉及改变原空间的地址，所以传<code>一级指针</code>即可</p><h2 id="堆的销毁"><a href="#堆的销毁" class="headerlink" title="堆的销毁"></a>堆的销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapDestroy</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(php-&gt;a);</span><br><span class="line">php-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">php-&gt;capacity = php-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的交换"><a href="#堆的交换" class="headerlink" title="堆的交换"></a>堆的交换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(HPDataType* p1, HPDataType* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HPDataType tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在<code>堆调整</code>中涉及多次的<code>节点交换</code>，所以额外写一个 <code>Swap</code> 交换函数方便使用</p><h2 id="堆的向上调整"><a href="#堆的向上调整" class="headerlink" title="堆的向上调整"></a>堆的向上调整</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(HPDataType* a, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[child], &amp;a[parent]);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向上调整通常用于最大堆的调整</strong></p><p>当向最大堆中插入一个新元素时，新元素会被放置在堆的末尾（<code>即数组的最后一个位置</code>），此时可能会破坏堆的性质（<code>最大堆要求每个节点的值都大于或等于其子节点的值</code>）</p><p>通过调用 <code>AdjustUp</code> 函数，可以将新插入的元素上浮到合适的位置，使得整个堆重新满足最大堆的性质</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ea472cf7d80641ad9b660324b3bfe756.jpeg" alt="请添加图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><ol><li>无论是<code>左节点</code>还是<code>右节点</code>，<code>父亲节点</code>的索引可以通过 <code>(child - 1) / 2</code> 计算得出</li><li><code>while</code> 循环的条件 <code>child &gt; 0</code> 不能写成 <code>child &gt;= 0</code>。当 <code>child</code> 等于 <code>0</code> 时，表示已经到达堆顶，按照 <code>parent = (child - 1) / 2</code> 计算，<code>(-1) / 2</code> 结果为 <code>0</code>（<code>整数除法向下取整</code>），这会导致 <code>parent</code> 和 <code>child</code> 相等，无法向上调整，陷入类似死循环的效果</li><li>除了 <code>child</code> 这个数据，前面的数据构成堆，因为向上调整的前提是其他数据都成堆</li></ol><h2 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPush</span><span class="params">(HP* php, HPDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">if</span> (php-&gt;size == php-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">HPDataType* tmp = (HPDataType*)<span class="built_in">realloc</span>(php-&gt;a, php-&gt;capacity * <span class="number">2</span> * <span class="built_in">sizeof</span>(HPDataType));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">php-&gt;a = tmp;</span><br><span class="line">php-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">php-&gt;a[php-&gt;size] = x;</span><br><span class="line"><span class="built_in">AdjustUp</span>(php-&gt;a, php-&gt;size);</span><br><span class="line">php-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了向上调整，那么插入就很容易了，检查容量是否足够插入，调整新插入的数据也构成堆即可</p><p>🔥<strong>值得注意的是：</strong> 不是 <code>php-&gt;capacity * 2</code> ，而是 <code>php-&gt;capacity * 2 * sizeof(HPDataType)</code>，注意是字节数不是容量数</p><h2 id="堆的向下调整"><a href="#堆的向下调整" class="headerlink" title="堆的向下调整"></a>堆的向下调整</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(HPDataType* a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child])</span><br><span class="line">&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[child], &amp;a[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>向下调整通常用于最小堆的调整</strong>（这里写的是最大堆的调整）</p><p>向下调整的前提是<code>左右子树都必须是大堆或者小堆</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2bc6be9a40594fd6a39f7eef1a82cdab.jpeg" alt="请添加图片描述"><br>🔥<strong>值得注意的是：</strong></p><ol><li>必须把大的那个孩子往上调，保证<code>大堆</code>的性质</li><li>这里假设子节点中的左孩子 <code>child = parent * 2 + 1</code> 是子节点中最大的</li><li><code>child + 1 &lt; n &amp;&amp; a[child + 1] &gt; a[child]</code> 的目的是判断<code>是否存在右子节点</code>，如果存在，再判断<code>左子节点是否大于右子节点</code>，如果大于就交换</li><li>不能写成 <code>a[child + 1] &gt; a[child] &amp;&amp; child + 1 &lt; n</code>，要先判断是否存在再访问，不然就非法越界了</li></ol><h2 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h2><p>在写堆删除代码前，我们要思考一个问题：</p><p><strong>为什么不用像之前顺序表那样常用的删除方法——后一个覆盖前一个？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d10e8d7e2ec9403894caf93d52bc572d.png" alt="在这里插入图片描述"></p><p>比如一个数组 <code>&#123;42，12，18，4，2，3&#125;</code></p><p>如果采用<code>后一个覆盖前一个</code>的方法删除节点：</p><ol><li><code>向下调整</code>的效率是 O($log_n$) ，<code>后一个覆盖前一个</code>的效率是 O(n) ，假设需要<code>挪动100万次</code>，那么向下调整<code>只需最多20次</code>就能解决，这效率翻得可不止一倍两倍</li><li><code>后一个覆盖前一个</code>之后<code>父子关系全乱</code>，无法进行堆调整</li></ol><p>删除堆通常是<code>删除堆顶的数据</code>，将<code>堆顶的数据</code>和<code>最后一个数据</code>一换，然后删除数组最后一个数据，再进行向下调整算法</p><p><strong>那么为什么是采用最后一个叶节点和根节点交换？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/18e2b0a359b44ef68ea19b29a3b67239.png" alt="在这里插入图片描述"></p><p>画图可以发现这种交换方式，不会太大程度上破坏堆的结构，保证能够进行<code>向下调整来恢复堆的秩序</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/774bc13b69a94db2bd4adbdfaebf35fb.jpeg" alt="请添加图片描述"></p><p>🔥<strong>值得注意的是：</strong> <code>删除特定位置元素的方法</code>和<code>删除堆顶</code>是一样的</p><ol><li>遍历整个堆来找到目标元素位置</li><li>将<code>目标位置的元素</code>与<code>堆的最后一个元素</code>进行交换</li><li>根据交换后该元素的值与周围元素的大小关系，决定是进行<code>上浮操作</code>还是<code>下沉操作</code>来恢复堆的性质</li></ol><p><strong>因此删除堆的代码也能轻松写出来：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPop</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="built_in">assert</span>(!<span class="built_in">HeapEmpty</span>(php));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;php-&gt;a[<span class="number">0</span>], &amp;php-&gt;a[php-&gt;size - <span class="number">1</span>]);</span><br><span class="line">php-&gt;size--;</span><br><span class="line"><span class="built_in">AdjustDown</span>(php-&gt;a, php-&gt;size, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆顶获取"><a href="#堆顶获取" class="headerlink" title="堆顶获取"></a>堆顶获取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HPDataType <span class="title">HeapTop</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回堆顶元素的值，<code>最大堆</code>的堆顶元素是<code>堆中的最大值</code>，<code>最小堆</code>的堆顶元素是<code>堆中的最小值</code></p><h2 id="堆的判空"><a href="#堆的判空" class="headerlink" title="堆的判空"></a>堆的判空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapEmpty</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>php-&gt;size</code> 等于 <code>0</code>，说明堆中没有元素，函数返回 <code>true</code>；否则返回 <code>false</code></p><h2 id="堆的节点个数"><a href="#堆的节点个数" class="headerlink" title="堆的节点个数"></a>堆的节点个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapSize</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置一个返回 <code>size</code> 的函数方便获取堆的节点个数，否则获取 <code>size</code> 只能通过遍历</p><h2 id="堆的打印"><a href="#堆的打印" class="headerlink" title="堆的打印"></a>堆的打印</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPrint</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; php-&gt;size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, php-&gt;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆的排序（向上建堆）"><a href="#堆的排序（向上建堆）" class="headerlink" title="堆的排序（向上建堆）"></a>堆的排序（向上建堆）</h2><p>既然堆有调整大小顺序的性质，那么就可以据此实现排序的功能</p><p>我们知道无论是向上调整，还是向下调整，都要基于一个具有完整性质的堆下来实现，分为<code>向上建堆</code>和<code>向下建堆</code></p><p><strong>向上建堆：</strong></p><p><code>向上建堆的核心思想是逐个插入元素到堆中</code>，每插入一个元素就对其进行向上调整操作，使其满足堆的性质。具体来说，从数组的第一个元素开始，依次将每个元素插入到已经构建好的部分堆中，然后通过上浮操作将该元素调整到合适的位置，确保整个数组始终保持堆的性质。其实就是对<code>堆插入的模拟实现</code></p><p>建好堆之后，就能对堆进行排序，排序分为<code>升序</code>和<code>降序</code></p><ul><li><code>升序</code>：建<code>大堆</code></li><li><code>降序</code>：建<code>小堆</code></li></ul><p><strong>为什么排序是这样建堆呢？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/749a707f6b42426585c529c63e897c4b.png" alt="在这里插入图片描述"></p><p>假设我们要<code>实现升序</code>，<code>如果是建小堆的话</code>，最小值就放在最上面不能动了，剩下的数如果想排序那又得看成一个堆，但是这样<code>父子关系全乱了</code>，因此每排好一个数就要重新建堆，那么<code>效率就太低了</code>。</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e30c6c3d61a0486d9f0903d05c96f8dd.jpeg" alt="请添加图片描述"></p><p>实现<code>升序</code>就要考虑<code>建大堆</code>，然后再<code>模拟堆删除</code>的方式，不断把<code>大的值调到最下面</code>，<code>最上面小的值</code>通过<code>向下调整</code>，把堆调整为<code>正常的大堆</code>，保证<code>左右子树都是大堆</code>。此时最大的值又在最顶上，<code>--end</code>，和<code>倒数第二个节点</code>交换，重复上面的操作，循环往复就能实现排序</p><p><strong>因此排序的代码为：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HPDataType* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//向上调整建堆,i是下标,n是个数,a是数组 -- O(N * log N)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[end], &amp;a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end, <span class="number">0</span>);</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-13-堆的排序（向下建堆）"><a href="#2-13-堆的排序（向下建堆）" class="headerlink" title="2.13 堆的排序（向下建堆）"></a>2.13 堆的排序（向下建堆）</h2><p><strong>向下建堆：</strong></p><p><code>向下建堆的过程</code>可以看作是一种<code>分治策略</code>，将一个大问题分解为多个小问题。<code>向下建堆的核心思想是从最后一个非叶子节点开始</code>，依次对每个非叶子节点进行向下调整（下沉）操作，使得以该节点为根的子树满足堆的性质，最终整个数组构成一个堆。<code>简单来说就是对下面每一个小堆依次调整，最终整体就形成了一个大堆</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f50820f7f27d4fc691fff7de3c100620.png" alt="在这里插入图片描述"></p><p>假设有个数组<code>&#123;2，1，5，7，6，8，0，9，4，3&#125;</code>，要实现<code>升序建大堆</code></p><ol><li>先从 <code>6</code> 这个堆开始调整</li><li>然后按数组顺序往前推，调整 <code>7</code> 这个堆</li><li>依次往前推对每个堆调整，最终就建成了一个大堆</li></ol><p>建好之后，排序的方法和<code>向上建堆</code>是一样的</p><p><strong>因此排序的代码为：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HPDataType* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//向下调整建堆 -- O(N)</span></span><br><span class="line">    <span class="comment">//n-1是最后一个节点，(n-1-1)/2是最后一个节点的父节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, n, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[end], &amp;a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end, <span class="number">0</span>);</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序效率比较"><a href="#堆排序效率比较" class="headerlink" title="堆排序效率比较"></a>堆排序效率比较</h1><p><strong>向下建堆：</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3d5d0921e1274db28308060b2c5156b3.png" alt="请添加图片描述"><br>因此：<strong>向下建堆的时间复杂度为O(N)</strong></p><p>用同样的方法，也能算出<strong>向上建堆的时间复杂度为O(N * log N)</strong></p><p>所以<strong>向下建堆是更高效的</strong></p><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/master/%E5%A0%86">Gitee堆代码</a></p></blockquote><h2 id="Heap-h"><a href="#Heap-h" class="headerlink" title="Heap.h"></a>Heap.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> HPDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Heap</span></span><br><span class="line">&#123;</span><br><span class="line">HPDataType* a;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line">&#125;HP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapInit</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapDestroy</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(HPDataType* p1, HPDataType* p2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(HPDataType* a, <span class="type">int</span> child)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(HPDataType* a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPush</span><span class="params">(HP* php, HPDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPop</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HPDataType <span class="title">HeapTop</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapEmpty</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapSize</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPrint</span><span class="params">(HP* php)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HPDataType* a, <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Heap-c"><a href="#Heap-c" class="headerlink" title="Heap.c"></a>Heap.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Heap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapInit</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line">php-&gt;a = (HPDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(HPDataType) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (php-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">php-&gt;size = <span class="number">0</span>;</span><br><span class="line">php-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapDestroy</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(php-&gt;a);</span><br><span class="line">php-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">php-&gt;capacity = php-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(HPDataType* p1, HPDataType* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HPDataType tmp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了child这个数据，前面的数据构成堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(HPDataType* a, <span class="type">int</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (child &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[child], &amp;a[parent]);</span><br><span class="line">child = parent;</span><br><span class="line">parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPush</span><span class="params">(HP* php, HPDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">if</span> (php-&gt;size == php-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">HPDataType* tmp = (HPDataType*)<span class="built_in">realloc</span>(php-&gt;a, php-&gt;capacity * <span class="number">2</span> * <span class="built_in">sizeof</span>(HPDataType));</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">php-&gt;a = tmp;</span><br><span class="line">php-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">php-&gt;a[php-&gt;size] = x;</span><br><span class="line"><span class="built_in">AdjustUp</span>(php-&gt;a, php-&gt;size);</span><br><span class="line">php-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右子树都必须是大堆或者小堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(HPDataType* a, <span class="type">int</span> n, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (child &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; a[child + <span class="number">1</span>] &gt; a[child])</span><br><span class="line">&#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[child] &gt; a[parent])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[child], &amp;a[parent]);</span><br><span class="line">parent = child;</span><br><span class="line">child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPop</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="built_in">assert</span>(!<span class="built_in">HeapEmpty</span>(php));</span><br><span class="line"><span class="built_in">Swap</span>(&amp;php-&gt;a[<span class="number">0</span>], &amp;php-&gt;a[php-&gt;size - <span class="number">1</span>]);</span><br><span class="line">php-&gt;size--;</span><br><span class="line"><span class="built_in">AdjustDown</span>(php-&gt;a, php-&gt;size, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HPDataType <span class="title">HeapTop</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HeapEmpty</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">HeapSize</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(php);</span><br><span class="line"><span class="keyword">return</span> php-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapPrint</span><span class="params">(HP* php)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; php-&gt;size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, php-&gt;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(HPDataType* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//向上调整建堆,i是下标，n是个数 -- O(N * log N)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AdjustUp</span>(a, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向下调整建堆 -- O(N)</span></span><br><span class="line"><span class="comment">    n-1是最后一个节点，(n-1-1)/2是最后一个节点的父节点*/</span></span><br><span class="line"><span class="comment">/*for (int i = (n - 1 - 1) / 2; i &gt;= 0; --i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">AdjustDown(a, n, i);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[end], &amp;a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">AdjustDown</span>(a, end, <span class="number">0</span>);</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】树型数据的勘探：树</title>
      <link href="/2025/02/21/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
      <url>/2025/02/21/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>本篇是数据结构中的重点结构——堆和二叉树的知识点储备介绍</p><p>建议先了解清楚链表的结构及使用再来学习</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145186504?spm=1001.2014.3001.5502">单链表</a>、<a href="https://blog.csdn.net/Zero_VPN/article/details/145233824?spm=1001.2014.3001.5502">双链表</a></p></blockquote><h1 id="树的概念及结构"><a href="#树的概念及结构" class="headerlink" title="树的概念及结构"></a>树的概念及结构</h1><h2 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h2><blockquote><p>树是一种<strong>非线性</strong>的数据结构，它是由n（n&gt;&#x3D;0）个有限结点组成一个具有层次关系的集合。<strong>把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的</strong></p></blockquote><p>🚩有一个<code>特殊的结点</code>，<code>称为根结点</code>，根结点没有前驱结点</p><p>🚩除根结点外，<code>其余结点被分成M(M&gt;0)个互不相交的集合T1、T2、……、Tm</code>，其中每一个集合<code>Ti(1&lt;= i &lt;= m)</code>又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继</p><p>🚩因此，<code>树是递归定义</code>的</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b10403ebd3b24fedba703a6e28dd7e5a.png" alt="请添加图片描述"></p><p>🔥<strong>值得注意的是：</strong> 树形结构中，<code>子树之间不能有交集</code>，否则就不是树形结构</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f83f9a4138974be7b57989d728f9303e.jpeg" alt="请添加图片描述"></p><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9c8ffd0b78074acc9e5bdf6c4ef17994.jpeg" alt="请添加图片描述"></p><p>学习堆和二叉树前，首先要理清其所有专业名词和相关概念</p><p>🚩<strong>结点的度</strong>：一个结点含有的子树的个数称为该结点的度，<code>即一个节点连接了几个子节点就是有几个度</code>； 如上图：<code>A</code> 的为 <code>6</code></p><p>🚩<strong>叶结点或终端结点</strong>：度为 <code>0</code> 的结点称为叶结点，<code>即没有子节点的节点</code>； 如上图：<code>B</code>、<code>C</code>、<code>H</code>、<code>I</code>…等结点为叶结点</p><p>🚩<strong>非终端结点或分支结点</strong>：度不为 <code>0</code> 的结点；  如上图：<code>D</code>、<code>E</code>、<code>F</code>、<code>G</code>…等结点为分支结点</p><p>🚩<strong>双亲结点或父结点</strong>：若一个结点含有子结点，则这个结点称为其子结点的父结点； 如上图：<code>A</code> 是 <code>B</code> 的父结点</p><p>🚩<strong>孩子结点或子结点</strong>：一个结点含有的子树的根结点称为该结点的子结点；  如上图：<code>B</code> 是 <code>A</code> 的孩子结点</p><p>🚩<strong>兄弟结点</strong>：具有<code>相同父结点</code>的结点互称为兄弟结点； 如上图：<code>B</code>、<code>C</code> 是兄弟结点</p><p>🚩<strong>树的度</strong>：一棵树中，<code>最大的结点的度</code>称为树的度； 如上图：树的度为 <code>6</code></p><p>🚩<strong>结点的层次</strong>：从根开始定义起，根为第 <code>1</code> 层，根的子结点为第 <code>2</code> 层，以此类推； </p><p>🚩<strong>树的高度或深度</strong>：树中结点的最大层次；  如上图：树的高度为 <code>4</code></p><p>🚩<strong>堂兄弟结点</strong>：双亲在<code>同一层的结点</code>互为堂兄弟；如上图：<code>H</code>、<code>I</code> 互为兄弟结点</p><p>🚩<strong>结点的祖先</strong>：从根到该结点<code>所经分支上的所有结点</code>；如上图：<code>A</code> 是所有结点的祖先</p><p>🚩<strong>子孙</strong>：以某结点为根的子树中任一结点都称为该结点的子孙。如上图：所有结点都是 <code>A</code> 的子孙</p><p>🚩<strong>森林</strong>：由 <code>m（m&gt;0）</code>棵互不相交的树的集合称为森林</p><h2 id="树的结构及应用"><a href="#树的结构及应用" class="headerlink" title="树的结构及应用"></a>树的结构及应用</h2><p>树的结构相对于线性表来说就复杂了许多，其多条分支之间的关系，就注定了其存储表示比较麻烦</p><p><strong>表示方法：</strong></p><ol><li><code>双亲表示法</code></li><li><code>孩子表示法</code></li><li><code>孩子双亲表示法</code></li><li><code>孩子兄弟表示法</code></li></ol><p>常用的表示方法有<strong>孩子兄弟表示法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Node</span>* firstChild1;    <span class="comment">// 第一个孩子结点</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Node</span>* pNextBrother;   <span class="comment">// 指向其下一个兄弟结点</span></span><br><span class="line"> DataType data;               <span class="comment">// 结点中的数据域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以<code>由上到下</code>，然后每一层<code>从左到右</code>的方法链接节点</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/22c6807b73ae4aa3b48aa1c3ac933e60.png" alt="在这里插入图片描述"></p><p>因此树通常用于<strong>表示文件系统的目录树结构</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d9f33012ab8343b59bbb8878b421379d.png" alt="请添加图片描述"></p><h1 id="二叉树的概念及结构"><a href="#二叉树的概念及结构" class="headerlink" title="二叉树的概念及结构"></a>二叉树的概念及结构</h1><h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><blockquote><p><code>二叉树是每个节点最多有两个子树的树结构</code>，通常被称为<code>左子树</code>和<code>右子树</code>。二叉树的子树有左右之分，次序不能颠倒，这是二叉树与普通树结构的重要区别之一</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ac57d4c74b9a455aa988756768b99432.png" alt="请添加图片描述"></p><p>🔥<strong>值得注意的是：</strong> </p><ol><li>二叉树<code>不存在度大于2</code>的结点</li><li>二叉树的子树有左右之分，次序不能颠倒，因此二叉树是<code>有序树</code></li></ol><p><strong>二叉树分为五种情况：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/09faadc0138d4ce1814f239b27fe5f75.png" alt="请添加图片描述"></p><p><strong>空二叉树：</strong> 没有任何节点的二叉树</p><p><strong>只有根节点的二叉树：</strong> 整个树只有一个根节点，没有左子树和右子树</p><p><strong>只有左子树的二叉树：</strong> 除了根节点外，根节点只有左子树，没有右子树</p><p><strong>只有右子树的二叉树：</strong> 除了根节点外，根节点只有右子树，没有左子树</p><p><strong>既有左子树又有右子树的二叉树：</strong> 根节点同时拥有左子树和右子树</p><p>根据这些情况，<strong>有两种特殊的二叉树：</strong></p><ol><li><p><strong>满二叉树：</strong> 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为 <code>K</code>，且结点总数是$2^k -1$ ，则它就是满二叉树</p></li><li><p><strong>完全二叉树：</strong> 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为 <code>K</code> 的，有 <code>n</code> 个结点的二叉树，当且仅当其每一个结点都与深度为 <code>K</code> 的满二叉树中编号从 <code>1</code> 至 <code>n</code> 的结点一一对应时称之为完全二叉树。简单来说就是<code>前 K-1 层都是满的</code>，<code>最后一层要从左到右是连续的</code>要注意的是<code>满二叉树是一种特殊的完全二叉树</code></p></li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e63ce48bacd54becbc761e52d174c67d.jpeg" alt="请添加图片描述"></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p>利用错位相减法可以简单算出一下二叉树的性质</p><p>🚩高度为 <code>h</code> 的<code>满二叉树</code>，有$2^h-1$个节点</p><p>🚩高度为 <code>h</code> 的<code>完全二叉树</code>，其节点个数范围是[$2^{h-1}$，$2^h-1$]</p><p>🚩对任何一棵二叉树, 如果度为 <code>0</code> 其叶结点个数为 $n_0$, 度为 <code>2</code> 的分支结点个数为 $n_2$,则有$n_0$＝$n_2$＋1（<code>简单来说就是度为0永远比度为2多一个，每增加一个度为2的就会增加一个度为0的，增加度为1的不影响</code>）</p><p>🚩具有<code>n个结点的满二叉树的深度</code>为 h &#x3D; $log_2(n+1)$</p><p>🚩对于具有 <code>n</code> 个结点的完全二叉树，如果按照<code>从上至下从左至右</code>的数组顺序对所有结点从 <code>0</code> 开始编号，则对于序号为 <code>i</code> 的结点有：</p><ol><li><strong>若 i &gt; 0，i 位置结点的双亲序号：(i-1) &#x2F; 2</strong>；i &#x3D; 0，i为根结点编号，无双亲结点</li><li><strong>若2i + 1 &lt; n，左孩子序号：2i + 1，2i + 1 &gt;&#x3D; n 否则无左孩子</strong></li><li><strong>若2i + 2 &lt; n，右孩子序号：2i + 2，2i + 2 &gt;&#x3D; n 否则无右孩子</strong></li></ol><p><strong>有这么一道经典题目：</strong><br>在具有 <code>2n</code> 个结点的完全二叉树中，叶子结点个数为（ <code>A</code> ）<br>A <code>n</code><br>B <code>n+1</code><br>C <code>n-1</code><br>D <code>n/2</code></p><p><strong>解析：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8a24481ac63048bd9d7b16e7d6cf7d54.png" alt="在这里插入图片描述"></p><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h3 id="顺序存储（堆）"><a href="#顺序存储（堆）" class="headerlink" title="顺序存储（堆）"></a>顺序存储（堆）</h3><p><code>顺序结构</code>存储就是使用<code>数组来存储</code>，一般使用数组<code>只适合表示完全二叉树</code>，因为不是完全二叉树会有空间的浪费。而现实中使用中<code>只有堆才会使用数组来存储</code>，关于堆我们后面的章节会专门讲解。二叉树顺序存储<strong>在物理上</strong>是<code>一个数组</code>，<strong>在逻辑上</strong>是<code>一颗二叉树</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/46bf99b886c24243bc4163a0f4ebccb6.jpeg" alt="请添加图片描述"></p><h3 id="链式存储（二叉树）"><a href="#链式存储（二叉树）" class="headerlink" title="链式存储（二叉树）"></a>链式存储（二叉树）</h3><p>二叉树的<code>链式存储</code>结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中<code>每个结点由三个域组成</code>，<code>数据域</code>和<code>左右指针域</code>，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为<code>二叉链</code>和<code>三叉链</code>，当前我们学习中一般都是二叉链，学到高阶数据结构如<code>红黑树</code>等会用到三叉链</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4c9f2ffa74e44a84af8bade110584ac5.jpeg" alt="请添加图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8bbae6fa94bf45048951f12bf021272a.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIGC训练效率与模型优化的深入探讨</title>
      <link href="/2025/02/20/%E8%AF%9D%E9%A2%98/AIGC%E8%AE%AD%E7%BB%83%E6%95%88%E7%8E%87/"/>
      <url>/2025/02/20/%E8%AF%9D%E9%A2%98/AIGC%E8%AE%AD%E7%BB%83%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>人工智能领域的发展，人工智能生成内容（ <a href="https://aigc.izzi.cn/">AIGC</a>）越来越受关注。AIGC能够通过学习大量数据生成高质量内容，但训练效率和模型优化仍然是关键的研究方向。本博客将深入探AIGC的训练效率，与模型优化的相关策略和技术，提供相应代码示例和图示，以帮助读者更好地理解该领域</p><h1 id="AIGC概述"><a href="#AIGC概述" class="headerlink" title="AIGC概述"></a>AIGC概述</h1><p><img src="https://i-blog.csdnimg.cn/direct/87c088976afd43bba82603bbd192038e.png" alt="在这里插入图片描述"><br>人工智能生成内容（AIGC）是指利用人工智能技术生成文本、图像、音频等内容的过程。AIGC的核心是深度学习模型，尤其是生成对抗网络（GAN）、变分自编码器（VAE）和大型语言模型（LLM）</p><p><strong>AIGC模型的应用场景</strong></p><p>• <strong>文本生成：</strong> 如新闻撰写、故事创作等<br>• <strong>图像生成：</strong> 如艺术创作、图像补全等<br>• <strong>音乐生成：</strong> 如背景音乐创作、乐谱生成等</p><h1 id="AIGC模型训练效率的重要性"><a href="#AIGC模型训练效率的重要性" class="headerlink" title="AIGC模型训练效率的重要性"></a>AIGC模型训练效率的重要性</h1><p>在AIGC的开发过程中，训练效率是一个重要的指标，它直接影响模型的开发速度和资源使用。高效的训练不仅可以减少等待时间，还能节省计算资源，使得模型能够在较短的时间内达到较好的性能</p><p>🚩<strong>影响训练效率的因素</strong></p><p>• <strong>数据量与数据质量：</strong> 数据的数量和质量影响模型的训练效果和速度。<br>• <strong>计算资源：</strong> 计算资源的充足程度（如GPU、TPU的可用性）直接影响训练效率。<br>• <strong>模型复杂度：</strong> 更复杂的模型通常需要更多的训练时间，但可以带来更好的性能。</p><h1 id="模型优化的概念与目标"><a href="#模型优化的概念与目标" class="headerlink" title="模型优化的概念与目标"></a>模型优化的概念与目标</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/74b84adc17c74142b25b2a6214421e82.png" alt="在这里插入图片描述"></p><p>模型优化指的是通过多种技术和方法提高模型的性能和训练效率，其目标包括但不限于：</p><ol><li><strong>提升模型准确性：</strong> 通过优化使模型在测试上表现更好</li><li><strong>减少训练时间：</strong> 有效地减少的训练时间</li><li><strong>减少计算资源占用：</strong> 在可能的情况下降低对计算资源的需求</li></ol><h1 id="模型优化策略"><a href="#模型优化策略" class="headerlink" title="模型优化策略"></a>模型优化策略</h1><h2 id="学习率调节"><a href="#学习率调节" class="headerlink" title="学习率调节"></a>学习率调节</h2><p>学习率是影响模型训练的关键因素之一。太高的学习率会导致模型训练不稳定，而太低的学习率则会导致收敛速度过慢</p><p>🚩<strong>策略：</strong></p><p><strong>学习率衰减：</strong> 可以在训练过程中逐渐降低学习率，以便在模型接近最优解时保持稳定</p><p><strong>自适应学习率算法：</strong> 如Adam、RMSProp等算法能够根据梯度的变化动态调整学习率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim as optim</span><br><span class="line"></span><br><span class="line">model = ...  # 模型实例</span><br><span class="line">optimizer = optim.<span class="built_in">Adam</span>(model.<span class="built_in">parameters</span>(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"># 在每个epoch结束时调整学习率</span><br><span class="line">def <span class="built_in">adjust_learning_rate</span>(optimizer, epoch):</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">10</span> == <span class="number">0</span>:  # 每<span class="number">10</span>个epoch调整一次</span><br><span class="line">        <span class="keyword">for</span> param_group in optimizer.param_groups:</span><br><span class="line">            param_group[<span class="string">&#x27;lr&#x27;</span>] *= <span class="number">0.1</span></span><br></pre></td></tr></table></figure><h2 id="模型架构选择"><a href="#模型架构选择" class="headerlink" title="模型架构选择"></a>模型架构选择</h2><p>不同的模型架构表现差异较大，因此选择合适的架构至关重要。例如，Transformer网络在文本生成和理解方面表现优异</p><p>🚩<strong>比较不同模型架构的性能：</strong></p><p>• <strong>RNN（循环神经网络）：</strong> 适合处理序列数据，但训练速度较慢<br>• <strong>CNN（卷积神经网络）：</strong> 在图像处理方面表现最佳<br>• <strong>Transformer：</strong> 在自然语言处理（NLP）任务中革命性地表现出色</p><h2 id="数据预处理与增强"><a href="#数据预处理与增强" class="headerlink" title="数据预处理与增强"></a>数据预处理与增强</h2><p>数据预处理决定了模型训练的基础，而数据增强可以有效提升模型的泛化能力</p><p>🚩<strong>数据预处理技巧：</strong></p><p><strong>归一化：</strong> 将数据标准化，提高模型训练效率</p><p><strong>数据增强：</strong> 如翻转、旋转、裁剪等手段可以增加数据集的多样性，从而提升模型的鲁棒性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">transform = transforms.<span class="built_in">Compose</span>([</span><br><span class="line">    transforms.<span class="built_in">RandomHorizontalFlip</span>(),</span><br><span class="line">    transforms.<span class="built_in">RandomRotation</span>(<span class="number">10</span>),</span><br><span class="line">    transforms.<span class="built_in">ToTensor</span>(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"># 使用transform处理数据集</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="正则化技术"><a href="#正则化技术" class="headerlink" title="正则化技术"></a>正则化技术</h2><p>正则化是抑制模型过拟合的有效方法，常用的方法包括L1&#x2F;L2正则化和Dropout</p><p>• <strong>L2正则化：</strong> 通过惩罚模型权重的大小来防止过拟合<br>• <strong>Dropout：</strong> 在训练时随机丢弃一定比例的神经元，以提高模型的泛化能力</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn as nn</span><br><span class="line"></span><br><span class="line">model = nn.<span class="built_in">Sequential</span>(</span><br><span class="line">    nn.<span class="built_in">Linear</span>(<span class="number">128</span>, <span class="number">64</span>),</span><br><span class="line">    nn.<span class="built_in">ReLU</span>(),</span><br><span class="line">    nn.<span class="built_in">Dropout</span>(<span class="number">0.5</span>),</span><br><span class="line">    nn.<span class="built_in">Linear</span>(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="量化与剪枝"><a href="#量化与剪枝" class="headerlink" title="量化与剪枝"></a>量化与剪枝</h2><p>量化和剪枝是优化模型的两种有效技术，它们能够有效减少模型的大小和计算需求</p><p><strong>模型剪枝：</strong> 去除那些冗余的神经元或神经连接，以简化模型结构<br><strong>模型量化：</strong> 将浮点数模型转换为较低位数表示（如8位整数）以减少内存占用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from torch.quantization <span class="keyword">import</span> quantize_dynamic</span><br><span class="line"></span><br><span class="line"># 动态量化示例</span><br><span class="line">model = <span class="built_in">quantize_dynamic</span>(model, &#123;nn.Linear&#125;, dtype=torch.qint8)</span><br></pre></td></tr></table></figure><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>下面是一个简单的训练循环示例，结合了上述优化策略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn as nn</span><br><span class="line"><span class="keyword">import</span> torch.optim as optim</span><br><span class="line">from torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"># 数据预处理和增强</span><br><span class="line">transform = transforms.<span class="built_in">Compose</span>([</span><br><span class="line">    transforms.<span class="built_in">RandomHorizontalFlip</span>(),</span><br><span class="line">    transforms.<span class="built_in">ToTensor</span>(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">train_dataset = datasets.<span class="built_in">MNIST</span>(root=<span class="string">&#x27;./data&#x27;</span>, train=True, download=True, transform=transform)</span><br><span class="line">train_loader = torch.utils.data.<span class="built_in">DataLoader</span>(train_dataset, batch_size=<span class="number">64</span>, shuffle=True)</span><br><span class="line"></span><br><span class="line"># 定义一个简单的神经网络</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">SimpleNet</span>(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">super</span>(SimpleNet, self).__init__()</span><br><span class="line">        self.fc1 = nn.<span class="built_in">Linear</span>(<span class="number">28</span> * <span class="number">28</span>, <span class="number">128</span>)</span><br><span class="line">        self.fc2 = nn.<span class="built_in">Linear</span>(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.fc3 = nn.<span class="built_in">Linear</span>(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        self.dropout = nn.<span class="built_in">Dropout</span>(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = x.<span class="built_in">view</span>(<span class="number">-1</span>, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        x = nn.<span class="built_in">ReLU</span>()(self.<span class="built_in">fc1</span>(x))</span><br><span class="line">        x = self.<span class="built_in">dropout</span>(x)</span><br><span class="line">        x = nn.<span class="built_in">ReLU</span>()(self.<span class="built_in">fc2</span>(x))</span><br><span class="line">        x = self.<span class="built_in">fc3</span>(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = <span class="built_in">SimpleNet</span>()</span><br><span class="line">criterion = nn.<span class="built_in">CrossEntropyLoss</span>()</span><br><span class="line">optimizer = optim.<span class="built_in">Adam</span>(model.<span class="built_in">parameters</span>(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"># 训练模型</span><br><span class="line"><span class="keyword">for</span> epoch in <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    model.<span class="built_in">train</span>()</span><br><span class="line">    <span class="built_in">adjust_learning_rate</span>(optimizer, epoch)  # 调整学习率</span><br><span class="line">    <span class="keyword">for</span> data, target in train_loader:</span><br><span class="line">        optimizer.<span class="built_in">zero_grad</span>()</span><br><span class="line">        output = <span class="built_in">model</span>(data)</span><br><span class="line">        loss = <span class="built_in">criterion</span>(output, target)</span><br><span class="line">        loss.<span class="built_in">backward</span>()</span><br><span class="line">        optimizer.<span class="built_in">step</span>()</span><br><span class="line">    <span class="built_in">print</span>(f<span class="string">&#x27;Epoch &#123;epoch + 1&#125;, Loss: &#123;loss.item()&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># 模型剪枝与量化</span><br><span class="line">model = <span class="built_in">quantize_dynamic</span>(model, &#123;nn.Linear&#125;, dtype=torch.qint8)</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote><p>AIGC的训练效率和模型优化是确保高效和高质量内容生成的关键。通过多种优化策略，如学习率调节、模型架构选择、数据预处理与增强、正则化和量化技术等，我们可以有效提升AIGC模型的性能和训练效率，为进一步开发提供更坚实的基础<br>未来，随着技术的进步，我们期待更高效的训练方法和更优秀的模型架构能够不断涌现，以满足各种AIGC应用的需求</p></blockquote><hr><p>以上就是关于AIGC训练效率与模型优化的深入分析。希望这篇博客能够对你理解和应用AIGC模型优化有所帮助！如果你有任何问题，欢迎随时讨论</p>]]></content>
      
      
      <categories>
          
          <category> 话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AIGC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当前就业形势下C++方向后端开发学习指南</title>
      <link href="/2025/02/20/%E8%AF%9D%E9%A2%98/C++%E6%96%B9%E5%90%91%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
      <url>/2025/02/20/%E8%AF%9D%E9%A2%98/C++%E6%96%B9%E5%90%91%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>传送门：<a href="https://legacy.cplusplus.com/">C++学习网站入口</a></p></blockquote><h1 id="C-后端开发的职业方向"><a href="#C-后端开发的职业方向" class="headerlink" title="C++后端开发的职业方向"></a>C++后端开发的职业方向</h1><h2 id="C-的应用领域"><a href="#C-的应用领域" class="headerlink" title="C++的应用领域"></a>C++的应用领域</h2><p><code>C++</code> 作为一种高效的系统编程语言，具有高性能和对硬件的控制能力，广泛应用于以下几个领域：<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1d878207c7d048fb84443e62c81e3283.png" alt="在这里插入图片描述"><br>• <strong>操作系统开发：</strong> 操作系统底层通常使用 <code>C++</code> 编写，尤其是与硬件交互的部分</p><p>• <strong>数据库开发：</strong> 大型数据库系统（如 <code>MySQL</code> ）在核心部分使用 <code>C++</code> 开发，优化了数据存储、查询效率和多线程性能</p><p>• <strong>网络编程：</strong> <code>C++</code> 具有非常强的网络编程能力，可以用于高性能网络服务的开发</p><p>• <strong>游戏开发：</strong> <code>C++</code> 是大型游戏开发的主要语言之一，具有出色的性能表现</p><p>• <strong>嵌入式开发：</strong> 由于 <code>C++</code> 支持底层编程，嵌入式系统的开发经常使用 <code>C++</code></p><h2 id="后端开发的职业选择"><a href="#后端开发的职业选择" class="headerlink" title="后端开发的职业选择"></a>后端开发的职业选择</h2><p>对于 <code>C++</code> 后端开发者，以下几种职业选择比较常见：</p><p>• <strong>后端开发工程师：</strong> 主要负责后端服务的设计与开发，涉及到的技术包括数据库、<code>API</code> 设计、消息队列等</p><p>• <strong>系统工程师：</strong> 负责底层系统架构的设计和优化，通常需要有深厚的 <code>C++</code> 编程功底和操作系统知识</p><p>• <strong>性能优化工程师：</strong> 专注于提升系统的性能和响应速度，通常需要深入了解多线程、内存管理等底层知识</p><p><strong>• 数据库开发工程师：</strong> 负责数据库系统的开发与优化，尤其是在处理大量数据和高并发情况下，<code>C++</code> 的优势尤为明显</p><h1 id="当前就业形势分析"><a href="#当前就业形势分析" class="headerlink" title="当前就业形势分析"></a>当前就业形势分析</h1><h2 id="C-开发者的市场需求"><a href="#C-开发者的市场需求" class="headerlink" title="C++开发者的市场需求"></a>C++开发者的市场需求</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/31584311db1443a2b084a0ed9d3b8c85.png" alt="在这里插入图片描述"><br>根据最新的行业报告，<code>C++</code> 开发者在一些特定领域的需求仍然较为强劲，尤其是在游戏开发、嵌入式开发以及金融技术领域。随着人工智能和大数据的发展，很多企业仍然需要高效、可扩展的系统，这正是 <code>C++</code> 擅长的地方</p><h2 id="C-开发者的薪资水平"><a href="#C-开发者的薪资水平" class="headerlink" title="C++开发者的薪资水平"></a>C++开发者的薪资水平</h2><p>在中国，<code>C++</code> 开发者的薪资水平通常高于很多其他编程语言的开发者。根据不同城市和经验水平，<code>C++</code> 后端开发工程师的薪资普遍较为可观。例如，北京、上海等一线城市<code>C++</code> 后端开发工程师年薪通常在 <code>20</code> 万 - <code>40</code>万人民币之间</p><h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><h2 id="入门阶段：掌握基础知识"><a href="#入门阶段：掌握基础知识" class="headerlink" title="入门阶段：掌握基础知识"></a>入门阶段：掌握基础知识</h2><p>如果你是 <code>C++</code> 编程的新手，建议先学习 <code>C++</code> 的基础语法和编程思想，以下是一些关键知识点：</p><p>• <strong>C++基础语法：</strong> 变量、数据类型、控制结构、函数、类与对象、指针与引用</p><p>• <strong>面向对象编程：</strong> 类、继承、多态、封装、虚函数</p><p>• <strong>STL（标准模板库）：</strong> 学习常用的容器如 <code>vector</code>、<code>map</code>、<code>set</code>，以及迭代器、算法等</p><p>• <strong>内存管理：</strong> 指针、动态内存分配、内存泄漏、<code>RAII</code>（资源获取即初始化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶阶段：掌握后端开发的核心技术"><a href="#进阶阶段：掌握后端开发的核心技术" class="headerlink" title="进阶阶段：掌握后端开发的核心技术"></a>进阶阶段：掌握后端开发的核心技术</h2><p>进入后端开发的进阶阶段，需要了解以下内容：</p><h3 id="数据库与C"><a href="#数据库与C" class="headerlink" title="数据库与C++"></a>数据库与C++</h3><p>后端开发中，数据库是不可避免的部分。<code>C++</code> 开发者需要学习如何与数据库进行交互。常见的数据库包括关系型数据库（如 <code>MySQL</code>、<code>PostgreSQL </code>）和 <code>NoSQL</code> 数据库（如<code>MongoDB</code>）</p><p>学习如何使用 <code>C++</code> 连接和操作数据库是后端开发的核心技能之一。使用如 <code>MySQL Connector</code> &#x2F; <code>C++</code> 等库可以帮助你在 <code>C++</code> 中实现数据库操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MYSQL *conn;</span><br><span class="line">MYSQL_RES *res;</span><br><span class="line">MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">conn = <span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;mysql_init() failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_real_connect</span>(conn, <span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;database&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;mysql_real_connect() failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">mysql_close</span>(conn);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">mysql_query</span>(conn, <span class="string">&quot;SELECT * FROM users&quot;</span>)) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;SELECT * FROM users failed. Error: &quot;</span> &lt;&lt; <span class="built_in">mysql_error</span>(conn) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">mysql_close</span>(conn);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">mysql_store_result</span>(conn);</span><br><span class="line"><span class="keyword">while</span> ((row = <span class="built_in">mysql_fetch_row</span>(res)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; row[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; row[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mysql_free_result</span>(res);</span><br><span class="line"><span class="built_in">mysql_close</span>(conn);</span><br></pre></td></tr></table></figure><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>后端开发离不开网络编程，尤其是开发 <code>API</code>、处理 <code>HTTP</code> 请求等。<code>C++</code> 提供了多种网络编程库，如 <code>Boost.Asio</code> 、<code>libcurl</code> 等，可以帮助你构建高效的网络服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_service io;</span><br><span class="line">    ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io)</span></span>;</span><br><span class="line">    ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io)</span></span>;</span><br><span class="line">    ip::tcp::<span class="function">resolver::query <span class="title">query</span><span class="params">(<span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">    ip::tcp::resolver::iterator endpoint_iterator = resolver.<span class="built_in">resolve</span>(query);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">connect</span>(socket, endpoint_iterator);</span><br><span class="line">    </span><br><span class="line">    std::string msg = <span class="string">&quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(socket, <span class="built_in">buffer</span>(msg));</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(buf));</span><br><span class="line">    std::cout.<span class="built_in">write</span>(buf, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级阶段：深入理解C-性能优化"><a href="#高级阶段：深入理解C-性能优化" class="headerlink" title="高级阶段：深入理解C++性能优化"></a>高级阶段：深入理解C++性能优化</h2><p><img src="https://i-blog.csdnimg.cn/direct/c8bfa4b5fd0248c6ad55277a20403569.png" alt="在这里插入图片描述"><br>在后端开发中，性能优化是一个关键环节。<code>C++</code> 的优势在于其对硬件资源的精细控制，能够提供高效的执行速度。学习 <code>C++</code> 的高级特性，尤其是多线程编程、内存管理、数据结构优化等，将大大提升你在后端开发中的竞争力</p><h3 id="多线程与并发编程"><a href="#多线程与并发编程" class="headerlink" title="多线程与并发编程"></a>多线程与并发编程</h3><p><code>C++11</code> 引入了线程库，使得多线程编程变得更加简单。你需要学习如何使用 <code>std::thread </code>、<code>std::mutex</code> 等来实现并发操作，从而提高系统的吞吐量和响应速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_message</span><span class="params">(<span class="type">const</span> std::string&amp; message)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(print_message, <span class="string">&quot;Hello from thread 1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(print_message, <span class="string">&quot;Hello from thread 2&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><code>C++</code> 的内存管理非常复杂，但它的精细控制也是 <code>C++</code> 的一大优势。掌握 <code>C++</code> 的内存管理，尤其是智能指针（如 <code>std::unique_ptr</code> 、<code>std::shared_ptr</code> ）和内存池的使用，将帮助你编写更高效、更安全的后端代码</p><h1 id="总结与职业规划"><a href="#总结与职业规划" class="headerlink" title="总结与职业规划"></a>总结与职业规划</h1><p><code>C++</code> 作为一种经典的后端开发语言，具有高性能和深厚的技术底蕴，适合那些希望深入理解计算机底层原理、并解决复杂技术难题的开发者。学习 <code>C++</code> 后端开发，不仅需要掌握基本的编程技能，还需要不断学习并跟进最新的技术趋势</p><p>职业规划方面，<code>C++</code> 后端开发者可以根据自己的兴趣选择不同的方向，如游戏开发、系统编程、数据库开发等。无论选择哪条路线，扎实的编程基础和持续的技术积累都是必不可少的</p><hr>]]></content>
      
      
      <categories>
          
          <category> 话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 后端 </tag>
            
            <tag> 团队开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：list函数全解</title>
      <link href="/2025/02/19/CPP%E5%88%9D%E9%98%B6/list%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/"/>
      <url>/2025/02/19/CPP%E5%88%9D%E9%98%B6/list%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习list？什么是list？"><a href="#为什么要学习list？什么是list？" class="headerlink" title="为什么要学习list？什么是list？"></a>为什么要学习list？什么是list？</h1><blockquote><p><code>list</code> 是 <code>C++</code> 标准模板库中的一个容器，它实现了<code>双向链表</code>的数据结构。双向链表由一系列节点组成，每个节点包含<code>一个数据元素</code>和<code>两个指针</code>，分别指向<code>前一个节点</code>和<code>后一个节点</code>。在链表的任意位置进行插入和删除操作的<code>时间复杂度都是O(1)</code> 。这使得它在需要频繁插入和删除元素的场景下表现出色，比如实现一个任务调度器，需要不断地添加新任务、移除已完成的任务</p></blockquote><p><code>list</code> 也是一种很常用的容器，对于链表的处理提供了极大的便利性</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b33aaed91a0047778014bd6fe44de543.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/list/list/">list</a> 的主要特征可总结为：</p><ol><li><code>list</code> 是可以在常数范围内在任意位置进行插入和删除的序列式容器，并且该容器可以前后双向迭代</li><li><code>list</code> 的底层是双向链表结构，双向链表中每个元素存储在互不相关的独立节点中，在节点中通过指针指向其前一个元素和后一个元素</li><li><code>list</code> 与 <code>forward_list</code> 非常相似：最主要的不同在于 <code>forward_list</code> 是单链表，只能朝前迭代，已让其更简单高效</li><li>与其他的序列式容器相比(<code>array</code>，<code>vector</code>，<code>deque</code>)，<code>list</code> 通常在任意位置进行插入、移除元素的执行效率更好。</li><li>与其他序列式容器相比，<code>list</code> 和 <code>forward_list</code> 最大的缺陷是不支持任意位置的随机访问，比如：要访问 <code>list</code> 的第 <code>6</code> 个元素，必须从已知的位置(比如头部或者尾部)迭代到该位置，在这段位置上迭代需要线性的时间开销；<code>list</code> 还需要一些额外的空间，以保存每个节点的相关联信息(对于存储类型较小元素的大 <code>list</code> 来说这可能是一个重要的因素)</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/392642415eda42c988668f81aa668adf.png" alt="在这里插入图片描述"></p><h1 id="list类对象的常见构造"><a href="#list类对象的常见构造" class="headerlink" title="list类对象的常见构造"></a>list类对象的常见构造</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9284220f8ea44a1e89b3314b740db2b7.png" alt="在这里插入图片描述"></p><p><code>list</code>作为一个类也有<a href="https://legacy.cplusplus.com/reference/list/list/list/">构造函数</a>，析构函数，&#x3D;运算符重载，我们重点介绍构造函数里的功能</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>list()</code></td><td>无参构造</td></tr><tr><td><code>list (size_type n, const value_type&amp; val = value_type())</code></td><td>构造并初始化n个val</td></tr><tr><td><code>list (const list&amp; x)</code></td><td>拷贝构造</td></tr><tr><td><code>list (InputIterator first, InputIterator last)</code></td><td>使用迭代器进行初始化构造</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; first;                                </span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">second</span><span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>;                       </span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">third</span><span class="params">(second.begin(), second.end())</span></span>;  </span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                       </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> myints[] = &#123; <span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span> &#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">fifth</span><span class="params">(myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The contents of fifth are: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it = fifth.<span class="built_in">begin</span>(); it != fifth.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4673f7b9681b43fcba3a8f42062433c8.png" alt="在这里插入图片描述"></p><h1 id="list类对象的容量操作"><a href="#list类对象的容量操作" class="headerlink" title="list类对象的容量操作"></a>list类对象的容量操作</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e649b5d1941948aabfec08d55ee0c044.png" alt="在这里插入图片描述"></p><p>因为是链表，所以对容量的操作并不需要太多，大部分是通过创建节点并链接实现</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>empty</code></td><td>检测list是否为空，是返回true，否则返回false</td></tr><tr><td><code>size</code></td><td>返回list中有效节点的个数</td></tr><tr><td><code>max_size</code></td><td>返回链表能存储的最多节点个数</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; lt.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; lt.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max_size:&quot;</span> &lt;&lt; lt.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/080d1062797d4f6c9489a0b7359846df.png" alt="在这里插入图片描述"></p><h1 id="list类对象的迭代器"><a href="#list类对象的迭代器" class="headerlink" title="list类对象的迭代器"></a>list类对象的迭代器</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0ab8946e4c0d48a38f981daa6f76c090.png" alt="在这里插入图片描述"></p><p><code>list</code> 的迭代器和 <code>vector</code> 的基本使用方法一致，但是底层的迭代器结构不同，在 <code>list</code> 底层结构剖析有详细的解答</p><blockquote><p>传送门：</p></blockquote><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>begin + end</code></td><td>迭代器：<code>begin</code> 获取开头一个节点 + <code>end</code> 获取最后一个节点下一个位置</td></tr><tr><td><code>rbegin + rend</code></td><td>反向迭代器：<code>rbegin</code> 获取最后一个节点 + <code>end</code> 获取开头一个节点上一个位置</td></tr><tr><td><code>cbegin + cend</code></td><td>和 <code>begin</code> + <code>end</code> 一样，但是常量迭代器只读</td></tr><tr><td><code>crbegin + crend</code></td><td>和 <code>rbegin</code> + <code>rend</code> 一样，但是反向常量迭代器只读</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>begin</code> 与 <code>end</code> 为正向迭代器，对迭代器执行 <code>++</code> 操作，迭代器向后移动</li><li><code>rbegin(end)</code> 与 <code>rend(begin)</code> 为反向迭代器，对迭代器执行 <code>++</code> 操作，迭代器向前移动</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/af25c77604c04c2bac8999e9e10c1bf8.png" alt="在这里插入图片描述"></p><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;迭代器:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反向迭代器:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::reverse_iterator it1 = lt.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != lt.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it1;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1bdb96229dca48c48a3281364aa0724d.png" alt="在这里插入图片描述"></p><h1 id="list类对象的元素修改"><a href="#list类对象的元素修改" class="headerlink" title="list类对象的元素修改"></a>list类对象的元素修改</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6c5a56b234db4810bf8ebe2896ecc9af.png" alt="在这里插入图片描述"></p><p><code>emplace</code> 的实现涉及 <code>C++11</code> 左值右值的知识，等到后面再拓展</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>assign</code></td><td>将新的内容赋值给链表</td></tr><tr><td><code>push_front</code></td><td>在 <code>list</code> 首元素前插入值为 <code>val</code> 的元素</td></tr><tr><td><code>pop_front</code></td><td>删除 <code>list</code> 中第一个元素</td></tr><tr><td><code>push_back</code></td><td>在 <code>list</code> 尾部插入值为 <code>val</code> 的元素</td></tr><tr><td><code>pop_back</code></td><td>删除 <code>list</code> 中最后一个元素</td></tr><tr><td><code>insert</code></td><td>在 <code>list position</code> 位置中插入值为 <code>val</code> 的元素</td></tr><tr><td><code>erase</code></td><td>删除 <code>list position</code> 位置的元素</td></tr><tr><td><code>swap</code></td><td>交换两个 <code>list</code> 中的元素</td></tr><tr><td><code>resize</code></td><td>将有效数据的个数增加或减少 <code>n</code> 个，多出的空间用默认值，少的截断即可</td></tr><tr><td><code>clear</code></td><td>清空 <code>list</code> 中的有效元素</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it1 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it1;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">assign</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;assign:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it2 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push_front:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it3 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it3 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it3 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it3++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">pop_front</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop_front:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it4 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it4 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it4 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it4++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it5 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it5 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it5 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it5++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop_back:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it6 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it6 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it6 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it6++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it7 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (--num1)</span><br><span class="line">&#123;</span><br><span class="line">it7++;</span><br><span class="line">&#125;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator pos = it7;</span><br><span class="line">lt.<span class="built_in">insert</span>(pos, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;insert:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it8 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it8 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it8 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it8++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it9 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> num2 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (--num2)</span><br><span class="line">&#123;</span><br><span class="line">it9++;</span><br><span class="line">&#125;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator pos1 = it9;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it10 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> num3 = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">while</span> (--num3)</span><br><span class="line">&#123;</span><br><span class="line">it10++;</span><br><span class="line">&#125;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator pos2 = it10;</span><br><span class="line">lt.<span class="built_in">erase</span>(pos1, pos2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;erase:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it11 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it11 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it11 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it11++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; ltt;</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ltt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it12 = ltt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it12 != ltt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it12 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it12++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(lt, ltt);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap:&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;lt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it13 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it13 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it13 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it13++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;ltt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it14 = ltt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it14 != ltt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it14 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it14++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize:&quot;</span> &lt;&lt; lt.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;clear:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it15 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it15 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it15 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it15++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/372d33c86d3a44809c146616cf6e0d64.png" alt="在这里插入图片描述"></p><h1 id="list类对象的链表操作"><a href="#list类对象的链表操作" class="headerlink" title="list类对象的链表操作"></a>list类对象的链表操作</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da1f4c8f651c40d8a4b00c60eaff385d.png" alt="在这里插入图片描述"></p><p>这一部分针对链表拓展了一些新的函数</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>splice</code></td><td>将一个 <code>list</code> 中的元素转移到另一个 <code>list</code> 中</td></tr><tr><td><code>remove</code></td><td>移除 <code>list</code> 中所有等于指定值的元素</td></tr><tr><td><code>remove_if</code></td><td>移除 <code>list</code> 满足特定条件的所有元素</td></tr><tr><td><code>unique</code></td><td>从 <code>list</code> 中移除连续重复的元素</td></tr><tr><td><code>merge</code></td><td>将两个已排序的列表合并成一个有序列表</td></tr><tr><td><code>sort</code></td><td>对 <code>list</code> 中的元素进行排序</td></tr><tr><td><code>reverse</code></td><td>将 <code>list</code> 中的元素顺序进行反转</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong> <code>remove_if</code>、<code>unique</code>、<code>merge</code> 涉及谓词等知识，放到后面讲</p><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lt;</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it1 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it1++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; ltt;</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">ltt.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ltt:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it2 = ltt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != ltt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">splice</span>(lt.<span class="built_in">begin</span>(), ltt);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;splice:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it3 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it3 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it3 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it3++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">remove</span>(<span class="number">40</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;remove:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it4 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it4 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it4 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it4++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">sort</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sort:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it5 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it5 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it5 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it5++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">lt.<span class="built_in">reverse</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;reverse:&quot;</span>;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it6 = lt.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it6 != lt.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it6 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it6++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s<br>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8322be675dea4647af4fe541b62dca7b.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3c06c828dba44443b8770833b8925cf2.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：vector底层剖析</title>
      <link href="/2025/02/19/CPP%E5%88%9D%E9%98%B6/vector%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
      <url>/2025/02/19/CPP%E5%88%9D%E9%98%B6/vector%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在学习本专题前，请详细学习有关 vector 的使用</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145672860">C++效率掌握之STL库：vector函数全解</a></p></blockquote><h1 id="学习vector底层的必要性"><a href="#学习vector底层的必要性" class="headerlink" title="学习vector底层的必要性"></a>学习vector底层的必要性</h1><blockquote><p><code>vector</code> 底层通过动态数组实现，学习其内存分配策略，能让我们明白如何避免<code>不必要的内存分配和拷贝操作</code>，<code>迭代器失效问题</code>、<code>扩容策略</code>等</p></blockquote><h1 id="vector类对象基本函数实现"><a href="#vector类对象基本函数实现" class="headerlink" title="vector类对象基本函数实现"></a>vector类对象基本函数实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T* iterator;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>()</span><br><span class="line">:_start(<span class="literal">nullptr</span>)</span><br><span class="line">,_finish(<span class="literal">nullptr</span>)</span><br><span class="line">,_end_of_storage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&lt;T&gt;&amp; v)</span><br><span class="line">:_start(<span class="literal">nullptr</span>)</span><br><span class="line">,_finish(<span class="literal">nullptr</span>)</span><br><span class="line">,_end_of_storage(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_start = <span class="keyword">new</span> T[v.<span class="built_in">capacity</span>()];</span><br><span class="line"><span class="built_in">memcpy</span>(_start, v._start, <span class="built_in">sizeof</span>(T) * v.<span class="built_in">size</span>());</span><br><span class="line">_finish = _start + v.<span class="built_in">size</span>();</span><br><span class="line">_end_of_storage = _start + <span class="built_in">capacity</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">_start = _finish = _end_of_storage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">iterator _start;</span><br><span class="line">iterator _finish;</span><br><span class="line">iterator _end_of_storage;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先了解<code>迭代器的本质也是指针类型</code>，后续会针对迭代器进行详细的本质剖析</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/146324257?spm=1011.2415.3001.5331">C++效率掌握之STL库：list底层剖析及迭代器万字详解</a></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f63331b84a7b42af8f337642c80b5a5f.png" alt="在这里插入图片描述"></p><p>此图选自《STL源码剖析》这本书，有时间建议去读一读这本书，会对STL库有更详细且清晰的认识，所以 <code>_start</code> 是头指针，<code>_finish</code> 是有效字节的尾指针，<code>_end_of_storage</code> 是容量的尾指针，实现基本的<code>构造</code>、<code>析构</code>、<code>拷贝</code>，注意都是 <code>iterator</code> 类型，为了方便配合迭代器使用</p><h1 id="vector类对象的遍历"><a href="#vector类对象的遍历" class="headerlink" title="vector类对象的遍历"></a>vector类对象的遍历</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;T&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_start, v._start);</span><br><span class="line">std::<span class="built_in">swap</span>(_finish, v._finish);</span><br><span class="line">std::<span class="built_in">swap</span>(_end_of_storage, v._end_of_storage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(vector&lt;T&gt; v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(v);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>operator=</code> 通过值传递 <code>v</code>，会调用 <code>vector</code> 的拷贝构造函数创建一个临时对象，然后将当前对象和这个临时对象进行交换，最后返回当前对象的引用</p><p>🔥<strong>值得注意的是：</strong> 这种实现方式具有异常安全性，如果拷贝构造函数抛出异常，当前对象的状态不会被改变，同时避免了手动管理内存</p><h1 id="vector类对象的扩容追加"><a href="#vector类对象的扩容追加" class="headerlink" title="vector类对象的扩容追加"></a>vector类对象的扩容追加</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, _start, <span class="built_in">sizeof</span>(T) * <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_finish = tmp + <span class="built_in">size</span>();</span><br><span class="line">_start = tmp;</span><br><span class="line">_end_of_storage = _start + n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> T&amp; val = T())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">_finish = _start + n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"><span class="keyword">while</span> (_finish != _start + n)</span><br><span class="line">&#123;</span><br><span class="line">*_finish = val;</span><br><span class="line">++_finish;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_finish == _end_of_storage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">4</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>; </span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line">&#125;</span><br><span class="line">*_finish = x;</span><br><span class="line">++_finish;</span><br><span class="line"><span class="comment">//insert(end(), x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reserve</code>：注意不要写成 <code>_finish = _start + size()</code>，必须写在 <code>_start = tmp</code> ，因为 <code>size()</code> 的计算依赖于 <code>_start</code> ，所以要在 <code>_start</code> 没有被改变前计算</p><p><code>resize</code>：如果 <code>n</code> 小于当前大小，会截断 <code>vector</code>；如果 <code>n</code> 大于当前大小，会将 <code>vector</code> 扩展到 <code>n</code> 个元素，并使用 <code>val</code> 填充新增的元素</p><p>🔥<strong>值得注意的是：</strong> <code>push_back</code> 函数 <code>reserve</code> 时要判断下是因为扩容是 <code>*2</code> ，避免空间为 <code>0</code> 时扩容 <code>*2</code> 导致出错</p><h1 id="string类对象的插入、删除"><a href="#string类对象的插入、删除" class="headerlink" title="string类对象的插入、删除"></a>string类对象的插入、删除</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt;= _finish);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_finish == _end_of_storage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> len = pos - _start;</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">4</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>;</span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line">pos = _start + len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator end = _finish - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)</span><br><span class="line">&#123;</span><br><span class="line">*(end + <span class="number">1</span>) = *end;</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pos = x;</span><br><span class="line">++_finish;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &gt;= _start &amp;&amp; pos &lt; _finish);</span><br><span class="line">iterator it = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (it != _finish)</span><br><span class="line">&#123;</span><br><span class="line">*(it - <span class="number">1</span>) = *it;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">--_finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code>：</p><p><strong>• 扩容处理：</strong> 当容器已满 <code>_finish == _end_of_storage</code> 时，能够自动进行扩容操作，保证有足够的空间插入新元素</p><p><strong>• 元素移动逻辑：</strong> 通过将插入位置之后的元素依次向后移动一个位置，为新元素腾出空间，实现了在指定位置插入元素的功能</p><p><strong>• 返回值：</strong> 函数返回指向插入元素的迭代器，方便调用者后续操作</p><p>🔥<strong>值得注意的是：</strong> <code>size_t len = pos - _start</code> 和 <code>pos = _start + len</code> 的目的是通过记录插入位置相对于起始位置的偏移量 <code>len</code>，在扩容后可以正确恢复插入位置</p><h1 id="vector类对象的其余操作"><a href="#vector类对象的其余操作" class="headerlink" title="vector类对象的其余操作"></a>vector类对象的其余操作</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _end_of_storage - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _finish - _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">return</span> *(_start + pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">return</span> *(_start + pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ol><li>常量正确性是 <code>C++</code> 编程中的一个重要原则，它确保对象在被声明为 <code>const</code> 时，其状态不会被意外修改。当一个对象被声明为 <code>const</code> 时，只能调用该对象的 <code>const</code> 成员函数。如果没有 <code>const</code> 版本的 <code>[]</code> 运算符，就无法通过 <code>const</code> 对象访问其元素</li><li>虽然理论上仅提供 <code>const</code> 版本的 <code>[]</code> 运算符是可行的，但在实际编程中这样做会有诸多局限性，<code>const</code> 版本的 <code>[]</code> 运算符返回的是 <code>const</code> 引用，这意味着通过该运算符获取的元素不能被修改。在很多场景下，我们需要对容器中的元素进行修改操作，如果只有 <code>const</code> 版本的 <code>[]</code> 运算符，就无法实现这一功能</li></ol><h1 id="使用memcpy拷贝问题"><a href="#使用memcpy拷贝问题" class="headerlink" title="使用memcpy拷贝问题"></a>使用memcpy拷贝问题</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> bite::vector&lt;bite::string&gt; v;</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="string">&quot;2222&quot;</span>);</span><br><span class="line"> v.<span class="built_in">push_back</span>(<span class="string">&quot;3333&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_finish == _end_of_storage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="built_in">capacity</span>() == <span class="number">0</span> ? <span class="number">4</span> : <span class="built_in">capacity</span>() * <span class="number">2</span>; </span><br><span class="line"><span class="built_in">reserve</span>(newcapacity);</span><br><span class="line">&#125;</span><br><span class="line">*_finish = x;</span><br><span class="line">++_finish;</span><br><span class="line"><span class="comment">//insert(end(), x);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">&#123;</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[n];</span><br><span class="line"><span class="keyword">if</span> (_start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, _start, <span class="built_in">sizeof</span>(T) * <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">delete</span>[] _start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_finish = tmp + <span class="built_in">size</span>();</span><br><span class="line">_start = tmp;</span><br><span class="line">_end_of_storage = _start + n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>memcpy</code> 是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存空间中</li><li>如果拷贝的是内置类型的元素，<code>memcpy</code> 既高效又不会出错，但如果拷贝的是自定义类型元素，并且自定义类型元素中涉及到资源管理时，就会出错，因为 <code>memcpy</code> 的拷贝实际是浅拷贝</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8389728b7e9468e8f1e01456fea31d4.png" alt="在这里插入图片描述"></p><p>比如 <code>reserve</code> 函数，<code>memcpy</code> 后，新内存的指针和旧内存的指针都指向原来的内存，<code>delete[] _start</code> 之后原来的空间就被释放了，内置类型就没事，自定义类型会出问题</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：vector函数全解</title>
      <link href="/2025/02/17/CPP%E5%88%9D%E9%98%B6/vector%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/"/>
      <url>/2025/02/17/CPP%E5%88%9D%E9%98%B6/vector%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习vector？什么是vector？"><a href="#为什么要学习vector？什么是vector？" class="headerlink" title="为什么要学习vector？什么是vector？"></a>为什么要学习vector？什么是vector？</h1><blockquote><p><code>vector</code> 是标准模板库（<code>STL</code>）提供的一个容器类，它是动态数组的一种实现。这意味着它可以像普通数组一样存储一组相同类型的元素，并且能根据需要自动调整自身的大小，例如，你可以创建一个存储整数的 <code>vector</code>，然后不断往里面添加或删除元素，它会自动管理内存空间</p></blockquote><p><code>vector</code> 类是和 <code>STL</code> 库一起问世的，<code>string</code> 函数是在 <code>STL</code> 库之前创造的，为了一致性简便性，<code>vector</code> 、<code>list</code> 等类都减少了一部分不必要的函数，也将 <code>string</code> 加入了 <code>STL</code> 库</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d87d88be2940464b8f0e1240a28a582d.png" alt="在这里插入图片描述"></p><p><a href="https://legacy.cplusplus.com/reference/vector/vector/">vector</a> 的主要特征可总结为：</p><ol><li><code>vector</code> 是表示可变大小数组的序列容器。</li><li>就像数组一样，<code>vector</code> 也采用的连续存储空间来存储元素。也就是意味着可以采用下标对 <code>vector</code> 的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理</li><li>本质讲，<code>vector</code> 使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，<code>vector</code> 并不会每次都重新分配大小</li><li><code>vector</code> 分配空间策略：<code>vector</code> 会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的</li><li>因此，<code>vector</code> 占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长</li><li>与其它动态序列容器相比（<code>deque</code>，<code>list and forward_list</code>），<code>vector</code> 在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起 <code>list</code> 和 <code>forward_list</code> 统一的迭代器和引用更好</li></ol><h1 id="vector类对象的常见构造"><a href="#vector类对象的常见构造" class="headerlink" title="vector类对象的常见构造"></a>vector类对象的常见构造</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6c3b97fef7c341199b044b0df8060f92.png" alt="在这里插入图片描述"></p><p><code>vector</code>作为一个类也有<a href="https://legacy.cplusplus.com/reference/vector/vector/vector/">构造函数</a>，析构函数，&#x3D;运算符重载，我们重点介绍构造函数里的功能</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>vector()</code></td><td>无参构造</td></tr><tr><td><code>vector（size_type n, const value_type&amp; val = value_type()）</code></td><td>构造并初始化n个val</td></tr><tr><td><code>vector (const vector&amp; x)</code></td><td>拷贝构造</td></tr><tr><td><code>vector (InputIterator first, InputIterator last)</code></td><td>使用迭代器进行初始化构造</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; first;                                </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">second</span><span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>;                       </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">third</span><span class="params">(second.begin(), second.end())</span></span>;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> myints[] = &#123; <span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fifth</span><span class="params">(myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The contents of fifth are:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = fifth.<span class="built_in">begin</span>(); it != fifth.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/01d32abf66894e53afd3eb4e2ee8253d.png" alt="在这里插入图片描述"></p><h1 id="vector类对象的容量操作"><a href="#vector类对象的容量操作" class="headerlink" title="vector类对象的容量操作"></a>vector类对象的容量操作</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/79f21557f95c4e8ca3835f1c68fb7460.png" alt="在这里插入图片描述"></p><p>在 <code>vector</code> 中同样对数组实现了容量操作，只不过相比 <code>string</code> ，删掉了 <code>lenth</code> 这类作用不大的函数</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>size</code></td><td>返回数组有效数据个数</td></tr><tr><td><code>max_size</code></td><td>返回的是 <code>vector</code> 理论上能够容纳的最大有效数据</td></tr><tr><td><code>resize</code></td><td>将有效数据的个数增加或减少 <code>n</code> 个，多出的空间用默认值，少的截断即可</td></tr><tr><td><code>capacity</code></td><td>返回空间总大小，即容量</td></tr><tr><td><code>reserve</code></td><td>为数组增加预留空间，即增加预留容量</td></tr><tr><td><code>empty</code></td><td>检测数组是否为空，是返回 <code>true</code> ，否则返回 <code>false</code></td></tr><tr><td><code>shrink_to_fit</code></td><td>请求 <code>vector</code> 对象将其容量缩小到和当前有效数据个数相匹配的大小</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>capacity</code> 的代码在 <code>vs</code> 和 <code>g++</code> 下分别运行会发现，<code>vs</code> 下 <code>capacity</code> 是按 <code>1.5</code> 倍增长的，<code>g++</code> 是按 <code>2</code> 倍增长的。这个问题经常会考察，不要固化的认为，<code>vector</code> 增容都是 <code>2</code> 倍，具体增长多少是根据具体的需求定义的，<code>vs</code> 是 <code>PJ</code> 版本 <code>STL</code> ，<code>g++</code> 是 <code>SGI</code> 版本 <code>STL</code></li><li><code>reserve</code> 只负责开辟空间，如果确定知道需要用多少空间，<code>reserve</code> 可以缓解 <code>vector</code> 增容的代价缺陷问题</li><li><code>resize</code> 在开空间的同时还会进行初始化，影响 <code>size</code></li></ol><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max_size:&quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">15</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;v:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;reserve:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;shrink_to_fit:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/810bbc44dd5546ebb1fc53da3a96b5d9.png" alt="在这里插入图片描述"></p><h1 id="vector类对象的迭代器"><a href="#vector类对象的迭代器" class="headerlink" title="vector类对象的迭代器"></a>vector类对象的迭代器</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5696ac223b2b4d7d97d6ee70cd9daffa.png" alt="在这里插入图片描述"></p><p><code>vector</code> 的迭代器和 <code>string</code> 的基本使用方法一致</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>begin + end</code></td><td>迭代器：<code>begin</code> 获取开头一个数据 + <code>end</code> 获取最后一个数据下一个位置</td></tr><tr><td><code>rbegin + rend</code></td><td>反向迭代器：<code>rbegin</code> 获取最后一个数据 + <code>end</code> 获取开头一个数据上一个位置</td></tr><tr><td><code>cbegin + cend</code></td><td>和 <code>begin</code> + <code>end</code> 一样，但是常量迭代器只读</td></tr><tr><td><code>crbegin + crend</code></td><td>和 <code>rbegin</code> + <code>rend</code> 一样，但是反向常量迭代器只读</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;迭代器:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it1++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反向迭代器:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator it2 = v.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != v.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5fc0fe0515b4433eb1a758f61975968d.png" alt="在这里插入图片描述"></p><h1 id="vector类对象的元素修改"><a href="#vector类对象的元素修改" class="headerlink" title="vector类对象的元素修改"></a>vector类对象的元素修改</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/197c2d0da2924a17a20eb577a399f96a.png" alt="在这里插入图片描述"></p><p><code>vector</code> 相对于 <code>string</code> 增加了 <code>emplace</code>，去除了多余的 <code>append</code></p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>assign</code></td><td>将新的内容赋值给数组</td></tr><tr><td><code>push_back</code></td><td>数组尾插有效数据</td></tr><tr><td><code>pop_back</code></td><td>数组尾删有效数据</td></tr><tr><td><code>insert</code></td><td>在容器的指定位置插入元素</td></tr><tr><td><code>erase</code></td><td>从容器里移除指定的元素或元素范围</td></tr><tr><td><code>swap</code></td><td>交换两个 <code>vector</code> 对象的内容</td></tr><tr><td><code>clear</code></td><td>移除 <code>vector</code> 对象中存储的所有字符</td></tr><tr><td><code>emplace</code></td><td>在容器的指定位置直接构造元素</td></tr><tr><td><code>emplace_back</code></td><td>在容器的末尾直接构造一个新元素</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it1++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;assign:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it3 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it3 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it3 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it3++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop_back:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it4 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it4 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it4 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it4++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;insert:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it5 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it5 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it5 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it5++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">begin</span>() + <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;erase:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it6 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it6 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it6 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it6++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vv&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vv:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it7 = vv.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it7 != vv.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it7 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it7++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(v, vv);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap:&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;v:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it8 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it8 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it8 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it8++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;vv:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it9 = vv.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it9 != vv.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it9 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it9++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">emplace</span>(v.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;emplace:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it10 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it10 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it10 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it10++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it11 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it11 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it11 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it11++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;clear:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it12 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it12 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it12 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it12++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3e826f4851854d79a318a022896b92d2.png" alt="在这里插入图片描述"></p><h1 id="vector类对象的元素访问"><a href="#vector类对象的元素访问" class="headerlink" title="vector类对象的元素访问"></a>vector类对象的元素访问</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d9a71c46d4c34f22a26fdc47f4834b8a.png" alt="在这里插入图片描述"></p><p><code>vector</code>的本质是数组，固然是要<code>[]运算符重载</code></p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>operator[ ]</code></td><td>像数组一样，使用方括号语法来访问其内部数据</td></tr><tr><td><code>at</code></td><td>访问指定位置元素</td></tr><tr><td><code>back</code></td><td>返回容器中最后一个元素的引用</td></tr><tr><td><code>front</code></td><td>返回容器中第一个元素的引用</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator[ ]:&quot;</span> &lt;&lt; v[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at:&quot;</span> &lt;&lt; v.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; (v.<span class="built_in">back</span>() = <span class="number">10</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;v:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it1 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">++it1;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; (v.<span class="built_in">front</span>() = <span class="number">-1</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;v:&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it2 = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">++it2;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83b3a9b0e9dc42c997a7d73ab3e7a023.png" alt="在这里插入图片描述"></p><h1 id="vector迭代器失效问题"><a href="#vector迭代器失效问题" class="headerlink" title="vector迭代器失效问题"></a>vector迭代器失效问题</h1><blockquote><p><code>迭代器的主要作用就是让算法能够不用关心底层数据结构</code>，其底层实际就是一个指针，或者是对指针进行了封装，比如：<code>vector</code> 的迭代器就是原生态指针 <code>T*</code> 。因此迭代器失效，实际就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃(即如果继续使用已经失效的迭代器，程序可能会崩溃)</p></blockquote><p>🚩<strong>会引起其底层空间改变的操作，都有可能是迭代器失效</strong>，比如：<code>resize</code>、<code>reserve</code>、<code>insert</code>、<code>assign</code>、<code>push_back</code>等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 将有效元素个数增加到100个，多出的位置使用8填充，操作期间底层会扩容</span></span><br><span class="line"> <span class="comment">// v.resize(100, 8);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// reserve的作用就是改变扩容大小但不改变有效元素个数，操作期间可能会引起底层容量改变</span></span><br><span class="line"> <span class="comment">// v.reserve(100);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 插入元素期间，可能会引起扩容，而导致原空间被释放</span></span><br><span class="line"> <span class="comment">// v.insert(v.begin(), 0);</span></span><br><span class="line"> <span class="comment">// v.push_back(8);</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 给vector重新赋值，可能会引起底层容量改变</span></span><br><span class="line"> v.<span class="built_in">assign</span>(<span class="number">100</span>, <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 出错原因：以上操作，都有可能会导致vector扩容，也就是说vector底层原理旧空间被释放掉，</span></span><br><span class="line"><span class="comment">而在打印时，it还使用的是释放之间的旧空间，在对it迭代器操作时，实际操作的是一块已经被释放的</span></span><br><span class="line"><span class="comment">空间，而引起代码运行时崩溃。</span></span><br><span class="line"><span class="comment"> 解决方式：在以上操作完成之后，如果想要继续通过迭代器操作vector中的元素，只需给it重新</span></span><br><span class="line"><span class="comment">赋值即可。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">while</span>(it != v.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line"> ++it;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>指定位置元素的删除操作</strong>–<code>erase</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line"> <span class="comment">// 使用find查找3所在位置的iterator</span></span><br><span class="line"> vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"> <span class="comment">// 删除pos位置的数据，导致pos迭代器失效。</span></span><br><span class="line"> v.<span class="built_in">erase</span>(pos);</span><br><span class="line"> cout &lt;&lt; *pos &lt;&lt; endl; <span class="comment">// 此处会导致非法访问</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>erase</code> 删除 <code>pos</code> 位置元素后，<code>pos</code> 位置之后的元素会往前搬移，没有导致底层空间的改变，理论上讲迭代器不应该会失效，但是：如果 <code>pos</code> 刚好是最后一个元素，删完之后 <code>pos</code> 刚好是 <code>end</code> 的位置，而 <code>end</code> 位置是没有元素的，那么 <code>pos</code> 就失效了。因此删除<code>     vector</code> 中任意位置上元素时，<code>vs</code> 就认为该位置迭代器失效了</p><p><strong>以下代码的功能是删除vector中所有的偶数，请问那个代码是正确的，为什么？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">v.<span class="built_in">erase</span>(it);</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">it = v.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然<code>第二个是正确的</code></p><p>使用 <code>v.erase(it)</code> 删除元素后，迭代器 <code>it</code> 会失效，<code>v.erase(it)</code> 删除元素时，<code>erase</code> 函数会返回一个指向被删除元素之后元素的迭代器，这意味着在调用 <code>v.erase(it)</code> 之后，<code>it</code> 不再指向原来的迭代器，所以需要将这个返回值赋给 <code>it</code>，可以保证 <code>it</code> 始终指向一个有效的元素，从而避免了迭代器失效的问题</p><p>🚩<strong>Linux下，g++编译器对迭代器失效的检测并不是非常严格，处理也没有vs下极端</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 扩容之后，迭代器已经失效了，程序虽然可以运行，但是运行结果已经不对了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;扩容之前，vector的容量为: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过reserve将底层空间设置为100，目的是为了让vector的迭代器失效 </span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;扩容之后，vector的容量为: &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经过上述reserve之后，it迭代器肯定会失效，在vs下程序就直接崩溃了，但是linux下不会</span></span><br><span class="line"><span class="comment">// 虽然可能运行，但是输出的结果是不对的</span></span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">扩容之前，vector的容量为: <span class="number">5</span></span><br><span class="line">扩容之后，vector的容量为 : <span class="number">100</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">409</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">// 2. erase删除任意位置代码后，linux下迭代器并没有失效</span></span><br><span class="line"><span class="comment">// 因为空间还是原来的空间，后序元素往前搬移了，it的位置还是有效的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">erase</span>(it);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序可以正常运行，并打印：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3: erase删除的迭代器如果是最后一个元素，删除之后it已经超过end</span></span><br><span class="line"><span class="comment">// 此时迭代器是无效的，++it导致程序崩溃</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">// vector&lt;int&gt; v&#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">v.<span class="built_in">erase</span>(it);</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : v)</span><br><span class="line">cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">========================================================</span><br><span class="line"><span class="comment">// 使用第一组数据时，程序可以运行</span></span><br><span class="line">[sly@VM - <span class="number">0</span> - <span class="number">3</span> - centos <span class="number">20220114</span>]$ g++ testVector.cpp - std = c+<span class="number">+11</span></span><br><span class="line">[sly@VM - <span class="number">0</span> - <span class="number">3</span> - centos <span class="number">20220114</span>]$ . / a.out</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">======================================================== =</span><br><span class="line"><span class="comment">// 使用第二组数据时，程序最终会崩溃</span></span><br><span class="line">[sly@VM - <span class="number">0</span> - <span class="number">3</span> - centos <span class="number">20220114</span>]$ vim testVector.cpp</span><br><span class="line">[sly@VM - <span class="number">0</span> - <span class="number">3</span> - centos <span class="number">20220114</span>]$ g++ testVector.cpp - std = c+<span class="number">+11</span></span><br><span class="line">[sly@VM - <span class="number">0</span> - <span class="number">3</span> - centos <span class="number">20220114</span>]$ . / a.out</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>从上述三个例子中可以看到：<code>SGI STL</code>中，迭代器失效后，代码并不一定会崩溃，但是运行结果肯定不对，如果 <code>it</code> 不在 <code>begin</code> 和 <code>end</code> 范围内，肯定会崩溃的</p><p><strong>与vector类似，string在插入+扩容操作+erase之后，迭代器也会失效</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 放开之后代码会崩溃，因为resize到20会string会进行扩容</span></span><br><span class="line"><span class="comment">// 扩容之后，it指向之前旧空间已经被释放了，该迭代器就失效了</span></span><br><span class="line"><span class="comment">// 后序打印时，再访问it指向的空间程序就会崩溃</span></span><br><span class="line"><span class="comment">//s.resize(20, &#x27;!&#x27;);</span></span><br><span class="line"><span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">it = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">it = s.<span class="built_in">erase</span>(it);</span><br><span class="line"><span class="comment">// 按照下面方式写，运行时程序会崩溃，因为erase(it)之后</span></span><br><span class="line"><span class="comment">// it位置的迭代器就失效了</span></span><br><span class="line"><span class="comment">// s.erase(it); </span></span><br><span class="line">++it;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 在使用新的 <code>iterator</code> 类型的变量前，对迭代器重新赋值即可</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0a11c05ec4f54b7ea1c9cde17b426d40.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】先来后到的秩序：栈和队列</title>
      <link href="/2025/02/17/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2025/02/17/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈的概念及结构"><a href="#栈的概念及结构" class="headerlink" title="栈的概念及结构"></a>栈的概念及结构</h1><blockquote><p>一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作，<strong>进行数据插入和删除操作的一端称为栈顶，另一端称为栈底</strong>，栈中的数据元素遵守<code>后进先出LIFO（Last In First Out）</code>的原则</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/841520e900fc41808f8e0bbd305c590e.png" alt="请添加图片描述"></p><p><strong>数组可以用来实现栈，但这并不意味着栈的本质就是数组</strong>。数组是一种连续存储元素的数据结构，使用数组实现栈时，利用<code>数组的索引来模拟栈的操作</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> STDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* a;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line">&#125;ST;</span><br></pre></td></tr></table></figure><p>栈的实现一般可以使用<strong>数组或者链表实现</strong>，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/33d14f318b234f828ee9be16e934f139.jpeg" alt="请添加图片描述"></p><h1 id="栈接口实现"><a href="#栈接口实现" class="headerlink" title="栈接口实现"></a>栈接口实现</h1><h2 id="栈初始化"><a href="#栈初始化" class="headerlink" title="栈初始化"></a>栈初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">STInit</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line">ps-&gt;a = (STDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(STDataType) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc mail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>; <span class="comment">//top是栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">//ps-&gt;top = 1; //top是栈顶元素位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果 top 为 0</strong>，<code>top</code> 指向的是下一个可以插入元素的位置。入栈操作时，直接将元素放入 <code>top</code> 位置，然后将 <code>top</code> 的值加 <code>1</code>；出栈操作时，先将 <code>top</code> 的值减 <code>1</code>，然后返回 <code>top</code> 位置的元素</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/65d8878bb2384fb28fbcb05463a62d3b.jpeg" alt="请添加图片描述"></p><p><strong>如果 top 为 1</strong>，<code>top</code> 指向的就是插入元素的位置</p><h2 id="栈销毁"><a href="#栈销毁" class="headerlink" title="栈销毁"></a>栈销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">STDestroy</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;a);</span><br><span class="line">ps-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很常规的栈销毁操作，记得<code>指针要释放后置空</code></p><h2 id="栈顶删除"><a href="#栈顶删除" class="headerlink" title="栈顶删除"></a>栈顶删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPop</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">STEmpty</span>(ps));</span><br><span class="line">ps-&gt;top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈顶指针减 <code>1</code>，相当于移除栈顶元素</p><h2 id="栈顶插入"><a href="#栈顶插入" class="headerlink" title="栈顶插入"></a>栈顶插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPush</span><span class="params">(ST* ps, STDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;capacity == ps-&gt;top)</span><br><span class="line">&#123;</span><br><span class="line">STDataType* tmp = (STDataType*)<span class="built_in">realloc</span>(ps-&gt;a, <span class="built_in">sizeof</span>(STDataType) * ps-&gt;capacity * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc mail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps-&gt;a = tmp;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps-&gt;a[ps-&gt;top++] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先检查栈的当前容量是否已满，如果已满则使用 <code>realloc</code> 函数将栈的容量扩大为原来的两倍，之后将新元素压入栈顶，并更新栈顶指针</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4fa6e2dcaa5a4d2ab298fea75f0385d2.jpeg" alt="请添加图片描述"></p><h2 id="栈的个数"><a href="#栈的个数" class="headerlink" title="栈的个数"></a>栈的个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">STSize</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里栈是用数组实现的，<code>top</code> 指的是栈顶的下一个元素，所以索引就是栈的元素个数</p><h2 id="栈的判空"><a href="#栈的判空" class="headerlink" title="栈的判空"></a>栈的判空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">STEmpty</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果为空，就返回 <code>0</code>，那么条件就不会执行；如果不为空，就返回 <code>1</code> ，条件正常执行</p><h2 id="栈顶获取"><a href="#栈顶获取" class="headerlink" title="栈顶获取"></a>栈顶获取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">STDataType <span class="title">STTop</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">STEmpty</span>(ps));</span><br><span class="line"><span class="keyword">return</span> ps-&gt;a[ps-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>top - 1</code> 表示最后一个元素，即栈顶元素</p><h1 id="队列的概念及结构"><a href="#队列的概念及结构" class="headerlink" title="队列的概念及结构"></a>队列的概念及结构</h1><blockquote><p>队列和我们字面上理解一样，先进入队列的元素会先被处理，后进入的元素会在队列尾部等待</p></blockquote><p>🚩<strong>队列：</strong> 只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<code>先进先出FIFO(First In First Out)</code></p><p>🚩<strong>入队列：</strong> 进行插入操作的一端称为<strong>队尾</strong></p><p>🚩<strong>出队列：</strong> 进行删除操作的一端称为<strong>队头</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/68767a4af9c84e66bfcf273081fb4138.gif" alt="请添加图片描述"></p><p>队列也可以<strong>数组和链表的结构实现</strong>，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a3769b0600142fda57d04a3aaf2cb62.png" alt="请添加图片描述"></p><p>由于是链式结构，所以每个元素还是以节点的形式体现，<code>指向队列头部节点的指针 head</code>、<code>指向队列尾部节点的指针 tail</code> 以及记录<code>队列中元素数量的 size</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span>* next;</span><br><span class="line">QDataType data;</span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line">QNode* head;</span><br><span class="line">QNode* tail;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h1 id="队列接口实现"><a href="#队列接口实现" class="headerlink" title="队列接口实现"></a>队列接口实现</h1><h2 id="队列初始化"><a href="#队列初始化" class="headerlink" title="队列初始化"></a>队列初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的头部指针 <code>head</code> 和尾部指针 <code>tail</code> 都设置为 <code>NULL</code>，表示队列为空，同时将队列的元素数量 <code>size</code> 初始化为 <code>0</code></p><h2 id="队列销毁"><a href="#队列销毁" class="headerlink" title="队列销毁"></a>队列销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueDestroy</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line">QNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">QNode* next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每个节点都存储了指向下一个节点的指针，所以需要<code>先存储节点</code>，<code>再释放节点</code></p><h2 id="队列插入"><a href="#队列插入" class="headerlink" title="队列插入"></a>队列插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line">QNode* newnode = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq-&gt;tail == <span class="literal">NULL</span>);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>入列只能从尾入</code></p><p><strong>队列为空：</strong><br><code>if (pq-&gt;head == NULL)</code>：判断队列是否为空<br><code>assert(pq-&gt;tail == NULL)</code>：若队列为空，断言队尾指针也为空，确保队列状态的一致性<br><code>pq-&gt;head = pq-&gt;tail = newnode</code>：将队列的头指针和尾指针都指向新节点，此时队列中只有一个元素<br><strong>队列非空：</strong><br><code>pq-&gt;tail-&gt;next = newnode</code>：将新节点连接到队尾节点的后面<br><code>pq-&gt;tail = newnode</code>：更新队尾指针，使其指向新节点</p><p>注意要先链接，后移动尾指针，否则找不到链接的节点 <code>next</code> 指针</p><h2 id="队列删除"><a href="#队列删除" class="headerlink" title="队列删除"></a>队列删除</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(pq-&gt;head != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">QNode* next = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>出列只能从头出</code>，保存队列头部节点的下一个节点指针，释放队列头部节点的内存，将队列头部指针更新为原头部节点的下一个节点</p><h2 id="队列元素个数"><a href="#队列元素个数" class="headerlink" title="队列元素个数"></a>队列元素个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列判空"><a href="#队列判空" class="headerlink" title="队列判空"></a>队列判空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;size == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果为空，就返回 <code>0</code>，那么条件就不会执行；如果不为空，就返回 <code>1</code> ，条件正常执行</p><h2 id="队头获取"><a href="#队头获取" class="headerlink" title="队头获取"></a>队头获取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">QueueEmpty</span>(pq));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队尾获取"><a href="#队尾获取" class="headerlink" title="队尾获取"></a>队尾获取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">QueueEmpty</span>(pq));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/449c67d413b94f78b22622bdd5592ff4.jpeg" alt="请添加图片描述"></p><p>实际中我们有时还会使用一种队列叫<code>循环队列</code>。如操作系统讲解生产者消费者模型时可以就会使用循环队列。环形队列可以使用<code>数组</code>实现，也可以使用循环链表实现</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a1937ce5ef7a463980021ecf5b6646d0.jpeg" alt="请添加图片描述"></p><h1 id="栈和队列习题"><a href="#栈和队列习题" class="headerlink" title="栈和队列习题"></a>栈和队列习题</h1><p><strong>选择题</strong></p><blockquote><p><strong>1.一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则元素出栈的顺序是（ <code>B</code> ）</strong><br>A 12345ABCDE<br>B EDCBA54321<br>C ABCDE12345<br>D 54321EDCBA<br><strong>2.若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（ <code>C</code> ）</strong><br>A 1,4,3,2<br>B 2,3,4,1<br>C 3,1,4,2<br>D 3,4,2,1<br><strong>3.循环队列的存储空间为 Q(1:100) ，初始状态为 front&#x3D;rear&#x3D;100 。经过一系列正常的入队与退队操作后， front&#x3D;rear&#x3D;99 ，则循环队列中的元素个数为（ <code>D</code> ）</strong><br>A 1<br>B 2<br>C 99<br>D 0或者100<br><strong>4.以下( <code>B</code> )不是队列的基本运算？</strong><br>A 从队尾插入一个新元素<br>B 从队列中删除第i个元素<br>C 判断一个队列是否为空<br>D 读取队头元素的值<br><strong>5.现有一循环队列，其队头指针为front，队尾指针为rear；循环队列长度为N。其队内有效长度为？(假设队头不存放数据)( <code>B</code> )</strong><br>A (rear - front + N) % N + 1<br>B (rear - front + N) % N<br>C (rear - front) % (N + 1)<br>D (rear - front + N) % (N - 1)</p></blockquote><p><strong>解析</strong></p><ol><li><p>栈是一种<code>后进先出（LIFO）</code>的数据结构。元素依次入栈后，最后入栈的元素会最先出栈。这里元素 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>、<code>5</code>、<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>E</code> 依次入栈，那么出栈顺序就应该是 <code>E</code> 最先出栈，接着是 <code>D</code>、<code>C</code>、<code>B</code>、<code>A</code>、<code>5</code>、<code>4</code>、<code>3</code>、<code>2</code>、<code>1</code>，所以答案是 <code>B</code></p></li><li><p><code>A</code> 选项 <code>1</code>,<code>4</code>,<code>3</code>,<code>2</code>：<code>1</code> 进栈，<code>1</code> 出栈；<code>2</code>、<code>3</code>、<code>4</code> 依次进栈，然后 <code>4</code>、<code>3</code>、<code>2</code> 依次出栈，该出栈序列是可能的<br><code>B</code> 选项 <code>2</code>,<code>3</code>,<code>4</code>,<code>1</code>：<code>1</code>、<code>2</code> 进栈，<code>2</code> 出栈；<code>3</code> 进栈，<code>3</code> 出栈；<code>4</code> 进栈，<code>4</code> 出栈；最后 <code>1</code> 出栈，该出栈序列是可能的<br><code>C</code> 选项 <code>3</code>,<code>1</code>,<code>4</code>,<code>2</code>：<code>3</code> 要先出栈，那么 <code>1</code>、<code>2</code>、<code>3</code> 必须先依次进栈，<code>3</code> 出栈后，栈顶元素是 <code>2</code>，此时只能 <code>2</code> 出栈，而不能 <code>1</code> 出栈，所以该出栈序列不可能<br><code>D</code> 选项 <code>3</code>,<code>4</code>,<code>2</code>,<code>1</code>：<code>1</code>、<code>2</code>、<code>3</code> 进栈，<code>3</code> 出栈；<code>4</code> 进栈，<code>4</code> 出栈；然后 <code>2</code>、<code>1</code> 依次出栈，该出栈序列是可能的</p></li><li><p>在循环队列中，当 <code>front = rear</code> 时，有两种情况：<br><strong>队列为空：</strong> 初始状态 <code>front = rear</code> 表示队列是空的。经过一系列操作后又出现 <code>front = rear</code>，有可能队列又变回了空的状态<br><strong>队列为满：</strong> 循环队列中，当队列满时也会出现 <code>front = rear</code> 的情况。对于长度为 <code>100</code> 的循环队列，当入队和出队操作使得队列刚好满一圈时，也会出现 <code>front = rear</code>。所以元素个数可能是 <code>0</code> 或者 <code>100</code>，答案选 <code>D</code></p></li><li><p>队列是一种<code>先进先出（FIFO）</code>的数据结构，其基本运算有：<br><strong>入队：</strong> 从队尾插入一个新元素，对应选项 <code>A</code><br><strong>出队：</strong> 从队头删除元素，而不是删除第 <code>i</code> 个元素，选项 <code>B</code> 不符合队列的基本运算规则<br>判断队列是否为空，对应选项 <code>C</code><br>读取队头元素的值，对应选项 <code>D</code>，所以答案是 <code>B</code></p></li><li><p>计算循环队列中元素的有效长度需要考虑 <code>rear</code> 和 <code>front</code> 的相对位置<br><strong>当 rear &gt;&#x3D; front 时</strong>，队列中元素的个数为 <code>rear - front</code><br><strong>当 rear &lt; front 时</strong>，队列中元素的个数为 <code>rear - front + N</code>（因为是循环队列，需要加上队列的长度 <code>N</code> 来计算实际元素个数）<br>综合这两种情况，可以使用 <code>(rear - front + N) % N</code> 来统一计算队列中元素的有效长度。因为取模运算可以处理 <code>rear</code> 和 <code>front</code> 的各种相对位置关系，所以答案选 <code>B</code></p></li></ol><p><strong>编程OJ题</strong></p><blockquote><ol><li>括号匹配问题。<a href="https://leetcode-cn.com/problems/valid-parentheses/">OJ链接</a></li><li>用队列实现栈。<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">OJ链接</a></li><li>用栈实现队列。<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">OJ链接</a></li><li>设计循环队列。<a href="https://leetcode-cn.com/problems/design-circular-queue/">OJ链接</a></li></ol></blockquote><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/master/%E6%A0%88/%E6%A0%88">Gitee栈代码</a></p></blockquote><h3 id="Stack-h"><a href="#Stack-h" class="headerlink" title="Stack.h"></a>Stack.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define N 10</span></span><br><span class="line"><span class="comment">//struct Stack</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//int a[N];</span></span><br><span class="line"><span class="comment">//int top;</span></span><br><span class="line"><span class="comment">//int capacity;</span></span><br><span class="line"><span class="comment">//&#125;ST;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> STDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* a;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> capacity;</span><br><span class="line">&#125;ST;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STInit</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STDestroy</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPop</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPush</span><span class="params">(ST* ps, STDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">STSize</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">STEmpty</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">STDataType <span class="title">STTop</span><span class="params">(ST* ps)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-2-Stack-c"><a href="#7-1-2-Stack-c" class="headerlink" title="7.1.2 Stack.c"></a>7.1.2 Stack.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STInit</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line">ps-&gt;a = (STDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(STDataType) * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc mail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity = <span class="number">4</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>; <span class="comment">//top是栈顶元素的下一个位置</span></span><br><span class="line"><span class="comment">//ps-&gt;top = 1; //top是栈顶元素位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STDestroy</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;a);</span><br><span class="line">ps-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">ps-&gt;top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPop</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">STEmpty</span>(ps));</span><br><span class="line">ps-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">STPush</span><span class="params">(ST* ps, STDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;capacity == ps-&gt;top)</span><br><span class="line">&#123;</span><br><span class="line">STDataType* tmp = (STDataType*)<span class="built_in">realloc</span>(ps-&gt;a, <span class="built_in">sizeof</span>(STDataType) * ps-&gt;capacity * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc mail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps-&gt;a = tmp;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ps-&gt;a[ps-&gt;top++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">STSize</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">STEmpty</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;top == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">STDataType <span class="title">STTop</span><span class="params">(ST* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">STEmpty</span>(ps));</span><br><span class="line"><span class="keyword">return</span> ps-&gt;a[ps-&gt;top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/master/%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97">Gitee队列代码</a></p></blockquote><h3 id="Queue-h"><a href="#Queue-h" class="headerlink" title="Queue.h"></a>Queue.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span>* QDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">QueueNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueNode</span>* next;</span><br><span class="line">QDataType data;</span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Queue</span></span><br><span class="line">&#123;</span><br><span class="line">QNode* head;</span><br><span class="line">QNode* tail;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueInit</span><span class="params">(QNode* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueDestroy</span><span class="params">(QNode* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePush</span><span class="params">(QNode* pq, QDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePop</span><span class="params">(QNode* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueSize</span><span class="params">(QNode* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Queue-c"><a href="#Queue-c" class="headerlink" title="Queue.c"></a>Queue.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueInit</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"></span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueDestroy</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line">QNode* cur = pq-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">QNode* next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePush</span><span class="params">(Queue* pq, QDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line">QNode* newnode = (QNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq-&gt;tail == <span class="literal">NULL</span>);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pq-&gt;tail-&gt;next = newnode;</span><br><span class="line">pq-&gt;tail = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueuePop</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(pq-&gt;head != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pq-&gt;head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = pq-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">QNode* next = pq-&gt;head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">pq-&gt;head = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pq-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueueSize</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueEmpty</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="keyword">return</span> pq-&gt;size == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QDataType <span class="title">QueueFront</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">QueueEmpty</span>(pq));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;head-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QDataType <span class="title">QueueBack</span><span class="params">(Queue* pq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pq);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">QueueEmpty</span>(pq));</span><br><span class="line"><span class="keyword">return</span> pq-&gt;tail-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f7fe2ce370ec405eb20d7c7b3f5db09d.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：string底层剖析</title>
      <link href="/2025/02/15/CPP%E5%88%9D%E9%98%B6/string%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
      <url>/2025/02/15/CPP%E5%88%9D%E9%98%B6/string%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>在学习本专题前，请详细学习有关 string 的使用</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/145412842?spm=1001.2014.3001.5502">C++效率掌握之STL库：string函数全解</a></p></blockquote><h1 id="学习string底层的必要性"><a href="#学习string底层的必要性" class="headerlink" title="学习string底层的必要性"></a>学习string底层的必要性</h1><blockquote><p>在 C++ 中，知道 string 是如何以字符数组的形式存储，以及字符串连接、查找等操作的时间复杂度，就可以避免在循环中频繁进行字符串连接操作，因为这可能会导致多次内存重新分配和数据复制，从而影响性能，而是选择更高效的方式，如预先分配足够的空间。同时，理解 string 底层对内存的管理方式，有助于优化内存使用，避免空指针和越界的情况出现</p></blockquote><h1 id="string类对象基本函数实现"><a href="#string类对象基本函数实现" class="headerlink" title="string类对象基本函数实现"></a>string类对象基本函数实现</h1><p>实现一个类首先先从其基本函数开始，包括<code>构造函数</code>、<code>析构函数</code>、<code>内存管理</code>等</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83a0102887cdff292fe5edc21020ddd.png" alt="请添加图片描述"></p><p>简单实现一个<code>空构造</code>和<code>字符串构造</code>，因为还没写 <code>string</code> 流输出的运算符重载，先将 <code>string</code> 类转成 <code>C</code> 语言风格来输出</p><p>🔥<strong>值得注意的是：</strong> 注意<code>变量声明的顺序</code>要和<code>初始化列表</code>一致，也要注意<code>变量初始化顺序对另一个变量的影响</code>；<code>=运算符重载</code>：自我赋值是指对象在赋值时被赋值给自己，例如 <code>s1 = s1</code>，在这种情况下，如果我们没有进行检查，就会先删除对象的内存，然后再试图复制同一个对象的内容，这样会导致程序崩溃。因此，重载赋值运算符时，自我赋值检查是非常必要的</p><h1 id="string类对象的遍历"><a href="#string类对象的遍历" class="headerlink" title="string类对象的遍历"></a>string类对象的遍历</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span><span class="comment">//加const保证const和普通string都能调用</span></span></span><br><span class="line"><span class="function"></span>&#123;                  <span class="comment">//增加普遍性，涉及权限的缩小</span></span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)<span class="comment">//可读写</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"><span class="keyword">return</span> _str[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span><span class="comment">//只读</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"><span class="keyword">return</span> _str[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _str + _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要遍历一个字符串，首先就要知道<code>大小</code>，然后需要用<code>方括号</code>来获取索引，或者用迭代器遍历，<code>迭代器</code>的本质其实就是一个<code>字符数组</code></p><p>🔥<strong>值得注意的是：</strong> </p><ol><li>注意 <code>size</code> 函数和 <code>c_str</code> 函数要具有普遍性，所以要包括 <code>const</code> 变量的情况，，即使是<code>普通类型调用</code>也是<code>权限的缩小</code>，两种情况共用一个函数</li><li><code>operator[]</code> 分为加 <code>const</code> 和不加 <code>const</code> ，分别代表<code>只读</code>和<code>可读写</code></li><li>同样迭代器也分为 <code>iterator</code> 和 <code>const_iterator</code></li><li><code>begin()</code> 指向第一个有效字符，<code>end()</code> 指向最后一个有效字符的后一位</li></ol><h1 id="string类对象的扩容追加"><a href="#string类对象的扩容追加" class="headerlink" title="string类对象的扩容追加"></a>string类对象的扩容追加</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 检查请求的内存大小 n 是否大于当前的容量 _capacity</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若 n 大于 _capacity，则分配 n + 1 个字符的内存空间</span></span><br><span class="line"><span class="comment">// 多分配一个字符是为了存储字符串的结束符 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span>* tmp = <span class="keyword">new</span> <span class="type">char</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原字符串 _str 复制到新分配的内存区域 tmp 中</span></span><br><span class="line"><span class="built_in">strcpy</span>(tmp, _str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放原字符串 _str 所占用的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 _str 指针指向新分配的内存区域 tmp</span></span><br><span class="line">_str = tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新当前字符串的容量为 n</span></span><br><span class="line">_capacity = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 检查当前字符串的实际字符数量 _size 是否等于其容量 _capacity</span></span><br><span class="line"><span class="keyword">if</span> (_size == _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果容量为 0，将容量扩展为 4；否则将容量扩大为原来的 2 倍</span></span><br><span class="line"><span class="built_in">reserve</span>(_capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串的末尾（即 _size 位置）添加新字符 ch</span></span><br><span class="line">_str[_size] = ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际字符数量加 1</span></span><br><span class="line">++_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在新的字符串末尾添加字符串结束符 &#x27;\0&#x27;</span></span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 计算要追加的字符串的长度</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前字符串的实际长度 _size 加上要追加的字符串长度 len 是否超过当前容量 _capacity</span></span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果超过容量，调用 reserve 函数进行扩容，扩容后的容量至少为 _size + len</span></span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将追加的字符串 str 复制到当前字符串 _str 的末尾位置（_str + _size）</span></span><br><span class="line"><span class="built_in">strcpy</span>(_str + _size, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新当前字符串的实际长度，加上要追加的字符串的长度</span></span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">append</span>(str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或许扩容添加的函数看起来操作简单，但其实其底层有许多细节</p><p>🔥<strong>值得注意的是：</strong> </p><ol><li><code>reserve</code> 传入的参数 <code>n</code> 指的是有效字符，<code>new</code> 一个新空间时 <code>+1</code> 是为了给 <code>&#39;\0&#39;</code> 留位置，<code>capacity</code> 也表示的是有效字符的容量，同时要记得释放原来指向的不使用的空间</li><li><code>push_back</code> 函数 <code>reserve</code> 时要判断下是因为扩容是 <code>*2</code> ，避免空间为 <code>0</code> 时扩容 <code>*2</code> 导致出错</li><li><code>push_back</code> 通常只是添加一个字符，不会涉及修改，所以不用传 <code>const</code> 参数；<code>append</code> 的参数可能会被错误修改，所以要传 <code>const</code> 参数，普通的参数可以通过权限缩小正常使用函数</li></ol><h1 id="string类对象的插入、删除"><a href="#string类对象的插入、删除" class="headerlink" title="string类对象的插入、删除"></a>string类对象的插入、删除</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_size + n &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(_size + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end != npos)</span><br><span class="line">&#123;</span><br><span class="line">_str[end + n] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = ch;</span><br><span class="line">&#125;</span><br><span class="line">_size += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">if</span> (_size + len &gt; _capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(_size + len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> end = _size;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos &amp;&amp; end != npos)</span><br><span class="line">&#123;</span><br><span class="line">_str[end + len] = _str[end];</span><br><span class="line">--end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos + i] = len;</span><br><span class="line">&#125;</span><br><span class="line">_size += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len = npos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len == npos || pos + len &gt;= _size)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">_size = pos;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> end = pos + len;</span><br><span class="line"><span class="keyword">while</span> (end &lt;= _size)</span><br><span class="line">&#123;</span><br><span class="line">_str[pos++] = _str[end++];</span><br><span class="line">&#125;</span><br><span class="line">_size -= len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>string</code> 类的插入删除都利用的是移动覆盖的思想，这里就不画图了，在数据结构阶段就已经学习了大致的思路</p><p>🔥<strong>值得注意的是：</strong> </p><ol><li>这里使用 <code>size_t</code> 类型的 <code>end</code> 作为索引来遍历字符串，<code>size_t</code> 是无符号整数类型。当 <code>end</code> 递减到 <code>0</code> 后再进行 <code>--end</code> 操作时，会发生无符号整数溢出，<code>end</code> 的值会变成 <code>size_t</code> 类型所能表示的最大值，这个值恰好和 <code>npos</code>（被初始化为 <code>-1</code> 转换后的 <code>size_t</code> 最大值）相等<br>如果没有 <code>end != npos</code> 这个条件，当 <code>end</code> 溢出后，<code>end &gt;= pos</code> 仍然可能为真（因为溢出后的值很大），这就会导致循环继续执行，从而造成数组越界访问，引发未定义行为。加上 <code>end != npos</code> 这个条件，当 <code>end</code> 溢出变成 <code>npos</code> 时，循环就会终止，避免了越界访问的问题</li><li>注意 <code>capacity</code> 在 <code>reserve</code> 里已经修改过了，所以外面只需要再修改 <code>size</code> 就行了</li></ol><h1 id="string类对象的查找、提取、大小调整"><a href="#string类对象的查找、提取、大小调整" class="headerlink" title="string类对象的查找、提取、大小调整"></a>string类对象的查找、提取、大小调整</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> ch, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; _size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_str[i] == ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = <span class="built_in">strstr</span>(_str + pos, str);</span><br><span class="line"><span class="keyword">if</span> (ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ptr - _str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> npos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> n = len;</span><br><span class="line"><span class="keyword">if</span> (len == npos || len + pos &gt; _size)</span><br><span class="line">&#123;</span><br><span class="line">n = _size - pos;</span><br><span class="line">&#125;</span><br><span class="line">string tmp;</span><br><span class="line">tmp.<span class="built_in">reserve</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = pos; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(_str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> ch = <span class="string">&#x27;\0&#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; _size)</span><br><span class="line">&#123;</span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reserve</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = _size; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_str[i] = ch;</span><br><span class="line">&#125;</span><br><span class="line">_size = n;</span><br><span class="line">_str[_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>string</code> 的查找操作比较简单，提取要注意提取的长度与原字符串长度的关系，调整大小也要注意 <code>&#39;\0&#39;</code> 的位置</p><p>🔥<strong>值得注意的是：</strong> </p><p><code>return ptr - _str</code>：通过指针相减计算子字符串在原字符串中的起始位置索引。因为 <code>ptr</code> 指向子字符串的起始位置，<code>_str</code> 指向原字符串的起始位置，两者相减得到的差值就是子字符串的起始位置索引</p><h1 id="string类对象的流输出、流提取"><a href="#string类对象的流输出、流提取" class="headerlink" title="string类对象的流输出、流提取"></a>string类对象的流输出、流提取</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, string&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 清空字符串 s 原有的内容</span></span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">// 从输入流 in 中读取一个字符并赋值给 ch</span></span><br><span class="line"><span class="type">char</span> ch = in.<span class="built_in">get</span>();</span><br><span class="line"><span class="comment">//处理前缓冲区前面的空格和换行</span></span><br><span class="line"><span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个大小为 128 的字符数组 buff 用于临时存储字符，初始化为全 &#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> buff[<span class="number">128</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// 定义一个索引变量 i 用于记录 buff 数组当前存储字符的位置，初始化为 0</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环处理连续的空格和换行符</span></span><br><span class="line"><span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将当前读取到的空格或换行符存入 buff 数组，并将索引 i 加 1</span></span><br><span class="line">buff[i++] = ch;</span><br><span class="line"><span class="comment">// 检查 buff 数组是否快满（只剩下一个位置用于存储字符串结束符 &#x27;\0&#x27;）</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">127</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在 buff 数组末尾添加字符串结束符 &#x27;\0&#x27;</span></span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">// 将 buff 数组中的内容添加到字符串 s 中</span></span><br><span class="line">s += buff;</span><br><span class="line"><span class="comment">// 重置索引 i 为 0，以便重新使用 buff 数组</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从输入流 in 中读取下一个字符并赋值给 ch</span></span><br><span class="line">ch = in.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 buff 数组中还有剩余字符（即 i 不为 0）</span></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在 buff 数组末尾添加字符串结束符 &#x27;\0&#x27;</span></span><br><span class="line">buff[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">// 将 buff 数组中的剩余内容添加到字符串 s 中</span></span><br><span class="line">s += buff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回输入流 in，以便支持链式输入操作</span></span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> </p><ol><li>当放在自定义的命名空间以外时，需要在参数 <code>string</code> 前加作用域限定，不然默认访问了库里自带的 <code>string</code></li><li>由于不断的 <code>+=</code> 来输入字符要不断的更新空间，效率不高，所以采用开辟数组的方式</li></ol><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc35a4ecf0eb449b84cce95d11e486fc.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++效率掌握之STL库：string函数全解</title>
      <link href="/2025/02/04/CPP%E5%88%9D%E9%98%B6/string%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/"/>
      <url>/2025/02/04/CPP%E5%88%9D%E9%98%B6/string%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学习string？什么是string？"><a href="#为什么要学习string？什么是string？" class="headerlink" title="为什么要学习string？什么是string？"></a>为什么要学习string？什么是string？</h1><blockquote><p>C语言中，字符串是以’\0’结尾的一些字符的集合，为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，<code>不太符合OOP的思想</code>，而且底层空间需要用户自己管理，稍不留神<code>可能还会越界访问</code></p></blockquote><p>因此创建了string类，比STL库还要早出现，所以有一定的缺陷和冗余</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/82eeec0c48824432bfdbdae5cba31ca0.png" alt="在这里插入图片描述"></p><p><a href="https://cplusplus.com/reference/string/string/?kw=string">string</a>的主要特征可总结为：</p><ol><li>字符串是<code>表示字符序列的类</code></li><li>该类的接口与常规容器的接口基本相同，再添加了一些专门用来操作string的常规操作</li><li>string在底层实际是：<code>basic_string</code>模板类的别名<br><code>typedef basic_string&lt;char, char_traits, allocator&gt; string</code></li><li>这个类独立于所使用的编码来处理字节:如果用来处理多字节或变长字符(如UTF-8)的序列，这个类的所有成员(如长度或大小)以及它的迭代器，将仍然<code>按照字节</code>(而<code>不是实际编码的字符</code>)来操作</li></ol><h1 id="string类对象的常见构造"><a href="#string类对象的常见构造" class="headerlink" title="string类对象的常见构造"></a>string类对象的常见构造</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cdde689690a64d17a6f9bb8a55719dd9.png" alt="在这里插入图片描述"></p><p><code>string</code>作为一个类也有<code>构造函数</code>，<code>析构函数</code>，<code>=运算符重载</code>，我们重点介绍<a href="https://legacy.cplusplus.com/reference/string/string/string/">构造函数</a>里的功能</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>string()</code></td><td>构造空的<code>string</code>类对象，即空字符串</td></tr><tr><td><code>string (const char* s)</code></td><td>用<code>C-string</code>来构造<code>string</code>类对象</td></tr><tr><td><code>string (const string&amp; str)</code></td><td>拷贝构造函数</td></tr><tr><td><code>string (const char* s, size_t n)</code></td><td>从 <code>s</code> 指向的字符数组中复制前 <code>n</code> 个字符</td></tr><tr><td><code>string (size_t n, char c)</code></td><td><code>string</code>类对象中包含<code>n</code>个字符<code>c</code></td></tr><tr><td><code>string (const string&amp; str, size_t pos, size_t len = npos)</code></td><td>复制从字符位置 <code>pos</code> 开始并跨越 <code>len</code> 字符的 <code>str</code> 部分（或者直到 <code>str</code> 的末尾，如果 <code>str</code> 太短或 <code>len</code> 为 <code>string::npos）</code></td></tr><tr><td><code>string  (InputIterator first, InputIterator last)</code></td><td>按顺序复制范围 <code>[first，last）</code> 中的字符序列</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s0</span><span class="params">(<span class="string">&quot;Initial string&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string s1;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s0)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s0, <span class="number">8</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;Best wish!&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s6a</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s6b</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;      <span class="comment">// *的ASCII值是42</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(s<span class="number">0.</span>begin(), s<span class="number">0.</span>begin() + <span class="number">7</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\ns2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\ns3: &quot;</span> &lt;&lt; s3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\ns4: &quot;</span> &lt;&lt; s4 &lt;&lt; <span class="string">&quot;\ns5: &quot;</span> &lt;&lt; s5 &lt;&lt; <span class="string">&quot;\ns6a: &quot;</span> &lt;&lt; s6a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\ns6b: &quot;</span> &lt;&lt; s6b &lt;&lt; <span class="string">&quot;\ns7: &quot;</span> &lt;&lt; s7 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/872b27630e3845e38d5f37f45fd47bfa.png" alt="在这里插入图片描述"></p><h1 id="string类对象的容量操作"><a href="#string类对象的容量操作" class="headerlink" title="string类对象的容量操作"></a>string类对象的容量操作</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6e0f757e0ae340ab9b93bfadc79349be.png" alt="在这里插入图片描述"></p><p>通常在C语言阶段，想要知道字符串的长度，或者对其大小容量进行操作，都要自己手撕函数，不仅耗时还费力，所以<code>string提供了现成的函数</code></p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>size</code></td><td>返回字符串有效字符长度</td></tr><tr><td><code>length</code></td><td>返回字符串有效字符长度(不常用)</td></tr><tr><td><code>max_size</code></td><td>返回的是 <code>string</code> 理论上能够容纳的最大字符数</td></tr><tr><td><code>resize</code></td><td>将有效字符的个数增加或减少 <code>n</code> 个，多出的空间用字符 <code>c</code> 或空格填充，少的截断字符串</td></tr><tr><td><code>capacity</code></td><td>返回空间总大小，即容量</td></tr><tr><td><code>reserve</code></td><td>为字符串增加预留空间，即增加预留容量</td></tr><tr><td><code>clear</code></td><td>移除 <code>string</code> 对象中存储的所有字符</td></tr><tr><td><code>empty</code></td><td>检测字符串释放为空串，是返回 <code>true</code> ，否则返回 <code>false</code></td></tr><tr><td><code>shrink_to_fit</code></td><td>请求 <code>string</code> 对象将其容量缩小到和当前字符串长度相匹配的大小</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>size()</code>与<code>length()</code>方法底层实现原理完全相同，引入<code>size()</code>的原因是为了与其他容器的接口保持一致，一般情况下基本都是用<code>size()</code></li><li><code>clear()</code> 只是将 <code>string</code> 中有效字符清空，即大小<code>size</code>缩为 <code>0</code> ，不改变底层空间大小，即容量 <code>capacity</code> 不改变</li><li><code>resize(size_t n)</code> 与 <code>resize(size_t n, char c)</code> 都是将字符串中有效字符个数改变到 <code>n</code> 个，不同的是当字符个数增多时：<code>resize(n)</code> 用空格来填充多出的元素空间，<code>resize(size_t n, char c)</code> 用字符 <code>c</code> 来填充多出的元素空间。注意：<code>resize</code> 在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大小，如果是将元素个数减少，底层空间总大小不变</li><li><code>reserve(size_t res_arg=0)</code>：为 <code>string</code> 预留空间，不改变有效元素个数，当 <code>reserve</code> 的参数小于 <code>string</code> 的底层空间总大小时，<code>reserver</code> 不会改变容量大小</li></ol><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; str.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lenth:&quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;max_size:&quot;</span> &lt;&lt; str.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;reserve:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">resize</span>(<span class="number">17</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;resize:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;shrink_to_fit:&quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;clear:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;empty:&quot;</span> &lt;&lt; str.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/49d54acd2de341cba34fe98090e3fc37.png" alt="在这里插入图片描述"></p><h1 id="string类对象的迭代器"><a href="#string类对象的迭代器" class="headerlink" title="string类对象的迭代器"></a>string类对象的迭代器</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8af2281720245eab2f3dbb6a6a89fd0.png" alt="在这里插入图片描述"></p><p><code>迭代器（Iterator）</code>是一种强大的抽象概念，它提供了一种统一的方式来访问和操作容器（如 <code>string</code>、<code>vector</code> 等）中的元素，简单来说就是提供了另一种<code>遍历修改数据的方法</code></p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>begin + end</code></td><td>迭代器：<code>begin</code> 获取开头一个字符 + <code>end</code> 获取最后一个字符下一个位置</td></tr><tr><td><code>rbegin + rend</code></td><td>反向迭代器：<code>rbegin</code> 获取最后一个字符 + <code>end</code> 获取开头一个字符上一个位置</td></tr><tr><td><code>cbegin + cend</code></td><td>和 <code>begin</code> + <code>end</code> 一样，但是常量迭代器只读</td></tr><tr><td><code>crbegin + crend</code></td><td>和 <code>rbegin</code> + <code>rend</code> 一样，但是反向常量迭代器只读</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong> 定义开头变量前的类型，可以用 <code>auto</code> 代替自动推导，避免了很长的类型，比如后续学习 <code>map</code> 的迭代器类型是这样的 <code>std::map&lt; std::string,std::string &gt;::iterator</code> ，就很有必要用 <code>auto</code></p><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string::iterator it1 = str.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it1 != str.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it1++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string::reverse_iterator it2 = str.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span> (it2 != str.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">it2++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a3aef020e514807ac2569440bc51915.png" alt="在这里插入图片描述"></p><h1 id="string类对象的元素访问"><a href="#string类对象的元素访问" class="headerlink" title="string类对象的元素访问"></a>string类对象的元素访问</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/86b970fa26694fc391d17677603e1024.png" alt="在这里插入图片描述"></p><p><code>string</code> 的元素访问提供了能够像数组那样<code>自由访问字符串中的数组的函数</code>，极大的提高了字符修改的效率</p><p>🔥<strong>值得注意的是：</strong> <code>at</code> 用于访问指定位置元素的成员函数。与 <code>operator[ ]</code> 不同的是，<code>at</code> 会进行边界检查，如果传入的索引超出容器的有效范围，会抛出 <code>std::out_of_range</code> 异常</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>operator[ ]</code></td><td>像数组一样，使用方括号语法来访问其内部数据</td></tr><tr><td><code>at</code></td><td>访问指定位置元素</td></tr><tr><td><code>back</code></td><td>返回容器中最后一个元素的引用</td></tr><tr><td><code>front</code></td><td>返回容器中第一个元素的引用</td></tr></tbody></table><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator[ ]:&quot;</span> &lt;&lt; str[<span class="number">11</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;at:&quot;</span> &lt;&lt; str.<span class="built_in">at</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; (str.<span class="built_in">back</span>() = <span class="string">&#x27;~&#x27;</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; (str.<span class="built_in">front</span>() = <span class="string">&#x27;h&#x27;</span>) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8e8ac46eb151430f9811f82ddebd35c1.png" alt="在这里插入图片描述"></p><h1 id="string类对象的元素修改"><a href="#string类对象的元素修改" class="headerlink" title="string类对象的元素修改"></a>string类对象的元素修改</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a9aba1350fd4c08ae701b3ef2ba2f00.png" alt="在这里插入图片描述"></p><p><code>string</code> 还提供了 一系列像修改链表那样能够修改字符串的函数</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>operator+=</code></td><td>字符串后追加字符串 <code>str</code></td></tr><tr><td><code>append</code></td><td>字符串后追加字符串 <code>str</code></td></tr><tr><td><code>push_back</code></td><td>字符串后尾插字符 <code>c</code></td></tr><tr><td><code>assign</code></td><td>将新的内容赋值给字符串</td></tr><tr><td><code>insert</code></td><td>在容器的指定位置插入元素</td></tr><tr><td><code>erase</code></td><td>从容器里移除指定的元素或元素范围</td></tr><tr><td><code>replace</code></td><td>在容器或字符串中替换特定元素或子串</td></tr><tr><td><code>swap</code></td><td>交换两个 <code>string</code> 对象的内容</td></tr><tr><td><code>pop_back</code></td><td>移除 <code>string</code> 中的最后一个元素</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong> </p><ol><li>在 <code>string</code> 尾部追加字符时，<code>s.push_back(c)</code> &#x2F; <code>s.append(1, c)</code> &#x2F; <code>s += &#39;c&#39;</code> 三种的实现方式差不多，一般情况下 <code>string</code> 类的 <code>+=</code> 操作用的比较多，<code>+=</code> 操作不仅可以连接单个字符，还可以连接字符串</li><li>对 <code>string</code> 操作时，如果能够大概预估到放多少字符，可以先通过 <code>reserve</code> 把空间预留好</li></ol><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator+=:&quot;</span> &lt;&lt; (str += <span class="string">&quot;hello&quot;</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;append:&quot;</span> &lt;&lt; str.<span class="built_in">append</span>(<span class="string">&quot; world&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">assign</span>(<span class="string">&quot;new word&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;assign:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">8</span>, <span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;insert:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;erase:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;fashion&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;replace:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">tmp</span><span class="params">(<span class="string">&quot;happy day!&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(tmp, str);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pop_back:&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/919ae5de0b5348e4b6757aa8882dd045.png" alt="在这里插入图片描述"></p><h1 id="string类对象的查找、提取、对比"><a href="#string类对象的查找、提取、对比" class="headerlink" title="string类对象的查找、提取、对比"></a>string类对象的查找、提取、对比</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0b11d01b76e34a41a0352cd783206da5.png" alt="在这里插入图片描述"></p><p><code>string</code> 也提供了一些<code>查找、提取、对比的函数</code>，<code>分配器(allocator)</code>是标准库中一个重要的组件，它将内存分配和对象构造分离，使得容器的内存管理更加灵活</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>c_str</code></td><td>返回 <code>C</code> 格式字符串</td></tr><tr><td><code>data</code></td><td>返回一个指向字符串内部字符数组的指针</td></tr><tr><td><code>get_allocator</code></td><td>获取容器当前使用的分配器实例</td></tr><tr><td><code>copy</code></td><td>将字符串的一部分复制到一个字符数组中</td></tr><tr><td><code>find</code></td><td>在字符串中查找子字符串或字符第一次出现的位置</td></tr><tr><td><code>rfind</code></td><td>在字符串中从后往前查找指定的子字符串或字符</td></tr><tr><td><code>find_first_of</code></td><td>查找字符串中任意参数在另一个字符串中第一次出现的位置</td></tr><tr><td><code>find_last_of</code></td><td>从后往前查找字符串中任意参数在另一个字符串中第一次出现的位置</td></tr><tr><td><code>find_first_not_of</code></td><td>在字符串中查找第一个不在指定字符集中的字符</td></tr><tr><td><code>find_last_not_of</code></td><td>从后往前在字符串中查找第一个不在指定字符集中的字符</td></tr><tr><td><code>substr</code></td><td>从字符串中提取子字符串</td></tr><tr><td><code>compare</code></td><td>对两个字符串进行比较</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong> </p><ol><li><code>c_str()</code> 返回的是一个 <code>const char*</code> 类型的指针，这意味着不能通过该指针修改其所指向的字符串内容</li><li>从 <code>C++11</code> 开始，<code>string::data()</code> 和 <code>string::c_str()</code> 的行为基本一致，都会返回一个以 <code>&#39;\0&#39;</code> 结尾的字符数组指针</li><li>对于 <code>copy</code>，目标字符数组必须有足够的空间来容纳要复制的字符，并且需要手动添加字符串结束符以形成有效的 <code>C</code> 风格字符串</li><li><code>find</code>系列没找到就返回<code>npos</code></li><li>对于 <code>compare</code>，逐个比较，如果当前字符串小于比较对象，返回一个负整数；如果当前字符串等于比较对象，返回 <code>0</code> ；如果当前字符串大于比较对象，返回一个正整数</li></ol><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str1 = str.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c_str:%s\n&quot;</span>, str1);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str2 = str.<span class="built_in">data</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data:%s\n&quot;</span>, str2);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">str.<span class="built_in">copy</span>(buffer, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">buffer[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;copy:&quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string subStr = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos1 = str.<span class="built_in">find</span>(subStr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find:&quot;</span> &lt;&lt; pos1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos2 = str.<span class="built_in">rfind</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rfind:&quot;</span> &lt;&lt; pos2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos3 = str.<span class="built_in">find_first_of</span>(subStr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find_first_of:&quot;</span> &lt;&lt; pos3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos4 = str.<span class="built_in">find_last_of</span>(subStr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find_last_of:&quot;</span> &lt;&lt; pos4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos5 = str.<span class="built_in">find_first_not_of</span>(subStr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find_first_not_of:&quot;</span> &lt;&lt; pos5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos6 = str.<span class="built_in">find_last_not_of</span>(subStr);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;find_last_not_of:&quot;</span> &lt;&lt; pos6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string Substr = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;substr:&quot;</span> &lt;&lt; Substr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare:&quot;</span> &lt;&lt; str.<span class="built_in">compare</span>(subStr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dd43504b69b74ba1a4695ecdfde6e00b.png" alt="在这里插入图片描述"></p><h1 id="8-string类的非成员函数及npos"><a href="#8-string类的非成员函数及npos" class="headerlink" title="8.string类的非成员函数及npos"></a>8.string类的非成员函数及npos</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0092fffed6514a4aaa53cbc26ba6ab11.png" alt="在这里插入图片描述"></p><p>正是有了非成员函数，才能实现<a href="https://legacy.cplusplus.com/reference/string/string/operators/">大小交换</a>、自定义交换、输出输入等操作，<code>npos</code> 也提供了一种特殊表达方式</p><table><thead><tr><th>函数名</th><th>功能说明</th></tr></thead><tbody><tr><td><code>npos</code></td><td>值为-1，表示查找操作失败或者某个位置不存在</td></tr><tr><td><code>operator+</code></td><td>将两个字符串拼接</td></tr><tr><td><code>relational operators</code></td><td>大小比较</td></tr><tr><td><code>swap</code></td><td>交换两个 <code>string</code> 对象的内容</td></tr><tr><td><code>operator&gt;&gt;</code></td><td>输入运算符重载</td></tr><tr><td><code>operator&lt;&lt;</code></td><td>输出运算符重载</td></tr><tr><td><code>getline</code></td><td>获取一行字符串</td></tr></tbody></table><p>🔥<strong>值得注意的是：</strong> </p><ol><li><code>npos</code> 值为 <code>-1</code> ，被定义为 <code>size_t</code> 类型的最大值。<code>-1</code> 原码为 <code>1000 ... 0001</code> ，补码则为<code>1111 ... 1111</code> ，但赋给 <code>size_t</code> 时，符号位就用不了了，所以整个补码就为 <code>size_t</code> 能表示的最大值表示查找操作失败或者某个位置不存在</li><li><code>string</code> 中 <code>operator+</code> 尽量少用，因为传值返回，导致效率低</li><li>当使用 <code>&gt;&gt;</code> 读取字符串时，它会在遇到空白字符（如空格、制表符、换行符等）时停止读取；<code>getline</code> 函数会读取输入流中的一行文本，直到遇到换行符为止，也就是遇到空格不会停止</li></ol><p>💻<strong>代码测试示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello &quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;npos:&quot;</span> &lt;&lt; str<span class="number">1.</span>npos &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;operator+:&quot;</span> &lt;&lt; (str1 + str2) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;relational operators:&quot;</span> &lt;&lt; (str1 &lt; str2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(str1, str2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;swap:&quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⌨️<strong>代码输出示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c53da2507adb4bb6b460b5bdae22ef6b.png" alt="在这里插入图片描述"></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f56edeb6de6d4a84b85f4905400c65fc.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> stl </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++底层学习预备：模板初阶</title>
      <link href="/2025/02/03/CPP%E5%88%9D%E9%98%B6/%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"/>
      <url>/2025/02/03/CPP%E5%88%9D%E9%98%B6/%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h1><p><code>编程范式</code>指的是我们使用<code>编程的基本风格和方法</code><br><code>常见的方式有以下几种：</code></p><p><strong>面向对象编程（OOP）</strong></p><blockquote><p>将数据和操作数据的方法封装在类中，通过类的实例（对象）来进行交互，强调数据的封装、继承和多态性</p></blockquote><p>定义一个<code>Shape</code>基类，包含计算面积的纯虚函数，再派生出<code>Circle</code>和<code>Rectangle</code>等类，重写计算面积的函数，体现了面向对象的<code>继承</code>和<code>多态</code>特性</p><p><strong>函数式编程</strong></p><blockquote><p>将计算视为函数的组合和应用，强调不可变数据和纯函数，避免副作用，注重函数的输入输出关系</p></blockquote><p>使用<code>std::function</code>和<code>lambda</code>表达式可以方便地进行函数式编程，如用<code>lambda</code>表达式定义一个简单的<code>加法函数</code>，不修改外部状态，只返回计算结果</p><p><strong>过程式编程</strong></p><blockquote><p>以过程（函数）为中心，将程序分解为一系列的步骤和函数调用，数据和操作数据的函数相对独立</p></blockquote><p>传统的<code>C语言</code>风格的编程方式，如编写一个计算阶乘的函数，通过<code>循环</code>和<code>递归</code>来实现计算过程，就是典型的过程式编程</p><p><strong>泛型编程</strong></p><blockquote><p>定义函数、类或其他程序结构时，不指定具体的数据类型，而是使用类型参数来代表未知的数据类型</p></blockquote><p>在<code>algorithm</code>头文件中的<code>swap</code>函数就是一种常见的泛式编程，他不指定任何类型就能实现交换，依靠的就是泛式编程，也是<code>我们接下来要学习的模板</code></p><h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>在还不知道头文件前实现<code>swap函数</code>通常是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; left, <span class="type">double</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">double</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">char</span>&amp; left, <span class="type">char</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">char</span> temp = left;</span><br><span class="line"> left = right;</span><br><span class="line"> right = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>为了符合各个场景下实现参数互换，要对<code>同一个函数实现不同类型的函数重载</code>，这种方式固然可行，但是每个类型都写一遍太过于冗余了</p><ol><li>重载的函数仅仅是<code>类型不同</code>，代码<code>复用率比较低</code>，只要有新类型出现时，就需要用户自己增加对应的函数</li><li>代码的<code>可维护性比较低</code>，一个出错可能所有的重载均出错</li></ol><h2 id="函数模板概念"><a href="#函数模板概念" class="headerlink" title="函数模板概念"></a>函数模板概念</h2><p>我们知道文字的印刷是依靠活字印刷术的模板实现的，<code>那能否告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码呢？</code></p><p>这里用到的模板就是<code>函数模板</code>，<code>其语法形式为：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,......,<span class="keyword">typename</span> Tn&gt;</span><br></pre></td></tr></table></figure><p><code>template</code>就是模板的意思，是用来定义模板参数关键字，也可以使用<code>class</code>，切记：不能使用<code>struct</code>代替<code>class</code>，因为<code>struct</code>和<code>class</code>的默认权限不同，会导致一些混淆和潜在的问题</p><h2 id="函数模板原理"><a href="#函数模板原理" class="headerlink" title="函数模板原理"></a>函数模板原理</h2><p>函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器</p><p><strong>举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个<code>Swap交换函数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7427080bc04640a59934a5fe68b64c46.png" alt="在这里插入图片描述"><br>对两个不同类型的函数进行同一个函数的调用，调试模式下转到反汇编可以发现，<code>两个函数式模板示例化后被调用的</code></p><p><code>这直接说明了调用的不是同一个函数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aa685d0d7dfc4423bfc463c478ceab48.png" alt="在这里插入图片描述"><br><code>在编译器编译阶段</code>，对于模板函数的使用，<code>编译器需要根据传入的实参类型来推演生成对应类型的函数</code>以供调用。</p><p>比如：<code>当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码</code>，这个类型无论是<code>内置类型</code>还是<code>自定义类型</code>都可以</p><h2 id="2-3-函数模板实例化"><a href="#2-3-函数模板实例化" class="headerlink" title="2.3 函数模板实例化"></a>2.3 函数模板实例化</h2><p>用不同类型的参数使用函数模板时，称为<code>函数模板的实例化</code></p><h3 id="2-3-1-隐式实例化"><a href="#2-3-1-隐式实例化" class="headerlink" title="2.3.1 隐式实例化"></a>2.3.1 隐式实例化</h3><blockquote><p><code>让编译器根据实参推演模板参数的实际类型</code>叫作隐式实例化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">10.0</span>, d2 = <span class="number">20.0</span>;</span><br><span class="line"><span class="built_in">Add</span>(a1, a2);</span><br><span class="line"><span class="built_in">Add</span>(d1, d2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下的调用就是<code>隐式实例化</code></p><p>🔥<strong>值得注意的是：</strong> Add函数前加const是因为这里如果像下面例子一样进行强制转化<code>会生成临时变量，具有常性</code></p><p>该知识点在前面有提到过：</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/144049255?spm=1001.2014.3001.5502">C++命运石之门代码抉择：C++入门（中）</a></p></blockquote><h3 id="2-3-2-显式实例化"><a href="#2-3-2-显式实例化" class="headerlink" title="2.3.2 显式实例化"></a>2.3.2 显式实例化</h3><blockquote><p><code>在函数名后的&lt;&gt;中指定模板参数的实际类型</code>叫作显式实例化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>(a1, d1);</span><br></pre></td></tr></table></figure><p>还是上面的例子，如果既调用int，又调用double，到底是<code>用哪种类型编译器无法决定</code>，就需要<code>显式实例化</code></p><p>🚩<strong>用户自己来强制转化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>(a1, (<span class="type">int</span>)d1);</span><br></pre></td></tr></table></figure><p>🚩<strong>使用显式实例化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a1, d1);</span><br></pre></td></tr></table></figure><p><code>指定T的类型为int</code></p><p>这通常不是显式实例化的常用场景，<code>举个例子：</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T* <span class="title">Alloc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> T[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Alloc</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果写成<code>Alloc(5)</code>，编译器不知道你要分配的是<code>int数组</code>、<code>double数组</code>还是其他类型的数组，所以无法自动推导<code>T的类型</code>，这时候就需要显式指定模板参数，像<code>Alloc&lt;int&gt;(5)</code> 这样明确告诉编译器<code>T是int类型</code></p><h2 id="2-4-模板参数的匹配原则"><a href="#2-4-模板参数的匹配原则" class="headerlink" title="2.4 模板参数的匹配原则"></a>2.4 模板参数的匹配原则</h2><p>🚩<strong>一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理int的加法函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非模板函数匹配，编译器不需要特化</span></span><br><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用编译器特化的Add版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专门处理int的加法函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Add</span><span class="params">(T1 left, T2 right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非函数模板类型完全匹配，不需要函数模板实例化</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2.0</span>); <span class="comment">// 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函</span></span><br><span class="line">数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩<strong>模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</strong></p><blockquote><p>这里的自动转化就是上面的实例化中的转化，也要和auto自动推导区分开，不是同一个东西</p></blockquote><h1 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3.类模板"></a>3.类模板</h1><p><code>类模板其实和函数模板是类似的</code></p><p><strong>其语法形式为：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, ..., <span class="keyword">class</span> <span class="title class_">Tn</span>&gt;</span><br></pre></td></tr></table></figure><p>因为类不像函数那样语法上支持自动类型转化，所以<code>类模板调用必须显式实例化</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态顺序表</span></span><br><span class="line"><span class="comment">// 注意：Vector不是具体的类，是编译器根据被实例化的类型生成具体类的模具</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Vector</span>(<span class="type">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">: _pData(<span class="keyword">new</span> T[capacity])</span><br><span class="line">, _size(<span class="number">0</span>)</span><br><span class="line">, _capacity(capacity)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用析构函数演示：在类中声明，在类外定义。</span></span><br><span class="line">~<span class="built_in">Vector</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> T&amp; data)</span>；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopBack</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="comment">// ...</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"><span class="keyword">return</span> _pData[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _pData;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：类模板中函数放在类外进行定义时，需要加模板参数列表</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Vector&lt;T&gt;::~<span class="built_in">Vector</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_pData)</span><br><span class="line"><span class="keyword">delete</span>[] _pData;</span><br><span class="line">_size = _capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Vector类名，Vector&lt;int&gt;才是类型</span></span><br><span class="line">Vector&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">Vector&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在写模板类时<code>尽量不要声明定义分离</code>，原因有些复杂放在模板进阶的时候讲，如果一定分离的话要注意：</p><ol><li>对于<code>普通类</code>，类名和类型一样</li><li>对于<code>模板类</code>，<code>Vector类名</code>，<code>Vector&lt;int&gt;才是类型</code></li></ol><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1288c46375424d1fb731830b3ff2143a.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速高效本地部署DeepseekR1大模型？保姆级教程 无惧隐私威胁</title>
      <link href="/2025/01/31/%E8%AF%9D%E9%A2%98/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Deepseek/"/>
      <url>/2025/01/31/%E8%AF%9D%E9%A2%98/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Deepseek/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要部署本地模型？"><a href="#为什么要部署本地模型？" class="headerlink" title="为什么要部署本地模型？"></a>为什么要部署本地模型？</h1><p><a href="https://chat.deepseek.com/downloads/DeepSeek%20Privacy%20Policy.html">DeepSeek 隐私政策</a>中提到了关于用户输入信息收集的条款，无论你输入什么文本，以及上传什么文件<code>都会被第三方机构所收集</code>，所以如果是在进行相关的<code>项目研究</code>或者<code>实验进展分析</code>的时候，就很有必要<code>对数据进行隐私保护</code>，且本地部署是<code>支持离线的</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0d8819eefc3d4fcca97eb4a206a3dce0.png" alt="在这里插入图片描述"></p><h1 id="Ollama下载"><a href="#Ollama下载" class="headerlink" title="Ollama下载"></a>Ollama下载</h1><p>大模型不是一个双击就可以使用的<code>.exe可执行文件</code>，是需要平台来运行的一个东西，<code>Ollama就是一个支持各种大模型本地部署的一个平台</code> ，用这个平台管理和大模型之间的输出和输入</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aa68fd01039242408a63d03d3ebbe740.png" alt="在这里插入图片描述"></p><p>首先浏览器中输入<code>Ollama.com</code>网址，<code>选择第一个</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/917b0f6aeb8149679f6422bf20db14ed.png" alt="在这里插入图片描述"><br>然后点击这里的<code>下载按钮</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/20022182ac824ae4a97e98a2eff04a37.png" alt="在这里插入图片描述"><br>继续<code>点击下载按钮</code>，根据自己<code>电脑的版本选择</code>，我这里选择的是<code>Windows系统</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/37f90237196a4ba2a9291f12d09ff47c.png" alt="在这里插入图片描述"></p><p>在<code>浏览器右上角下载处</code>等待下载完成</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e0adbc98d6644028a1acbb05f90cf24b.png" alt="在这里插入图片描述"></p><p>下载完后<code>点击打开文件</code>，弹出界面<code>再点击Install下载</code>，然后<code>等待下载完成</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/098e74e9e9fd4e6790bf3a8a61088ce8.png" alt="在这里插入图片描述"></p><p><code>Ollama在桌面上不会生成桌面图标</code>，所以我们<code>win+R</code>打开运行窗口，输入<code>cmd</code>打开命令行</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b9b964d5f0ef40fba5a1a0d95c506630.png" alt="在这里插入图片描述"></p><p>然后输入<code>ollama -v</code>（中间有个空格），回车，会<code>显示出版本号</code>，说明已经安装成功了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9a5c300752494383996f178f913223b8.png" alt="在这里插入图片描述"></p><h1 id="大模型下载部署"><a href="#大模型下载部署" class="headerlink" title="大模型下载部署"></a>大模型下载部署</h1><p>回到<code>Ollama</code>的网站，点击<code>Models</code>板块</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bd5bda5f6519497b9a049c38d756313b.png" alt="在这里插入图片描述"><br>接着点击<code>deepseek-r1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/92d19d496a6d494385bc860f4f0d20fc.png" alt="在这里插入图片描述"></p><p>选择大模型的体积，体积越大使用效果越好，但是<code>磁盘占用的空间就越大</code>，所以根据自己电脑的磁盘空间选择，该模型一般下在<code>C盘</code>（也可以选择打开D盘新建仓库下载），这里建议选择<code>1.5b</code>、<code>8b</code>或者<code>32b</code></p><p><strong>模型和GPU显卡的适配表格以供参考：</strong></p><table><thead><tr><th>模型</th><th>参数 (B)</th><th>VRAM 要求 (GB)</th><th>推荐 GPU</th></tr></thead><tbody><tr><td>DeepSeek - R1 - Zero</td><td>671B</td><td>~1,342 GB</td><td>多 GPU 配置（例如，NVIDIA A100 80GB x16）</td></tr><tr><td>DeepSeek - R1</td><td>671B</td><td>~1,342 GB</td><td>多 GPU 配置（例如，NVIDIA A100 80GB x16）</td></tr><tr><td>DeepSeek - R1 - Distill - Qwen 1.5B</td><td>1.5B</td><td>~0.75 GB</td><td>NVIDIA RTX 3060 12GB 或更高</td></tr><tr><td>DeepSeek - R1 - Distill - Qwen 7B</td><td>7B</td><td>~3.5 GB</td><td>NVIDIA RTX 3060 12GB 或更高</td></tr><tr><td>DeepSeek - R1 - Distill - Llama 8B</td><td>8B</td><td>~4 GB</td><td>NVIDIA RTX 3060 12GB 或更高</td></tr><tr><td>DeepSeek - R1 - Distill - Qwen 14B</td><td>14B</td><td>~7 GB</td><td>NVIDIA RTX 3060 12GB 或更高</td></tr><tr><td>DeepSeek - R1 - Distill - Qwen 32B</td><td>32B</td><td>~16 GB</td><td>NVIDIA RTX 4090 24GB</td></tr><tr><td>DeepSeek - R1 - Distill - Llama 70B</td><td>70B</td><td>~35 GB</td><td>多 GPU 配置（例如，NVIDIA RTX 4090 x2）</td></tr></tbody></table><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/642a5ba2908344439f877edfe1e40895.png" alt="在这里插入图片描述"></p><p><code>复制</code>这里的<code>下载命令</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cff71ebf4a9f4811af35e95c371a0561.png" alt="在这里插入图片描述"></p><p>回到命令行，<code>输入刚才复制的命令</code>，回车，等待下载</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/39f7b34593244b008d68a595039ebf2d.png" alt="在这里插入图片描述"></p><p>下载完成后就可以和Deepseek进行交流了，输入<code>/bye</code>来退出对话，但是每次调用窗口对话实在是太麻烦了</p><h1 id="Chatbox-AI下载"><a href="#Chatbox-AI下载" class="headerlink" title="Chatbox AI下载"></a>Chatbox AI下载</h1><p>我们需要借助另一个软件来实现像手机端那样的界面使用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8896039a443b4c1c86df4ac780117286.png" alt="在这里插入图片描述"></p><p>输入网址<code>chatboxai.app</code>下载该软件，<code>建议用谷歌浏览器</code>，我用微软浏览器有点卡（或者直接用网页版也行）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/864f8daea7d44680a17fe7bb39b32f65.png" alt="在这里插入图片描述"></p><p>下载完之后，打开软件里的设置，选择<code>模型提供方</code>里的<code>Ollama API</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9fe30b535068434a88db379f8749e943.png" alt="在这里插入图片描述"></p><p>勾选你刚才在<code>本地下载的模型</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7d924e4d32b343a59fb43b8b424f5da4.png" alt="在这里插入图片描述"></p><p>然后<code>win+x</code>，点击这里的<code>系统</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/64d5803a5d694b0f95857dcb4f5fe48b.png" alt="在这里插入图片描述"></p><p>这里有个<code>高级系统设置</code>，点进去</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/63c43291254c41d3a3b068eb3f4d3451.png" alt="在这里插入图片描述"></p><p>点击这里的<code>环境变量</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/addca269ce3a4df4b302abe6ea8e5e2f.png" alt="在这里插入图片描述"></p><p>然后新建变量，变量名输入<code>OLLAMA_HOST</code>，变量值输入<code>0.0.0.0</code>，千万不能出错</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/09ca6666539146db97e44c608a2d92d5.png" alt="在这里插入图片描述"></p><p>再新建一个新建变量，变量名输入<code>OLLAMA_ORIGINS</code>，变量值输入<code>*</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f8119e2e8a3b4f968a3722be146da435.png" alt="在这里插入图片描述"></p><p><code>点击确定</code>退出</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/07a071a5ee8f49b68ccabdd9b317e769.png" alt="在这里插入图片描述"></p><p>再<code>点击确定</code>退出</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b497a18b6e214b6b82096044e8f15992.png" alt="在这里插入图片描述"></p><p>然后在<code>windows搜索栏里启动Ollama</code>，要确保已经启动了，不然模型无法运行</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0339bffa08b04da5a8946c060a426728.png" alt="在这里插入图片描述"></p><p>然后就可以回到<code>Chatbox</code>就可以使用<code>Deepseek</code>了</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1>]]></content>
      
      
      <categories>
          
          <category> 话题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> chatgpt </tag>
            
            <tag> 开源软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++传送锚点的内存寻址：内存管理</title>
      <link href="/2025/01/29/CPP%E5%88%9D%E9%98%B6/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2025/01/29/CPP%E5%88%9D%E9%98%B6/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-内存分布回顾"><a href="#C-C-内存分布回顾" class="headerlink" title="C&#x2F;C++内存分布回顾"></a>C&#x2F;C++内存分布回顾</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/451b2e36aeb34bc1a83f041f376d4165.png" alt="在这里插入图片描述"><br>程序中需要存储的数据：<code>局部数据</code>、<code>静态数据和全局数据</code>、<code>常量数据</code>、<code>动态申请数据</code></p><p><strong>常量和可变常量的区别</strong></p><blockquote><p>经常很多人以为加了const的变量就是常量，但其实不是的，这叫<code>可变常量</code>，例如 <code>const int* ptr</code>，其实还是可以修改的，它可以<code>指向不同的常量整数</code>，但<code>不能通过该指针修改所指向的值</code>。</p></blockquote><p>🔥<strong>检查类型存储位置的小tips：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d07bd34c217a4361aacaba0f4c6fea44.png" alt="在这里插入图片描述"></p><p>看地址存放是否相近，<code>相近则存放在同一区域</code>，<code>相差巨大则存放在不同区域</code></p><h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><p>我们直到<code>在堆上动态开辟空间需要使用malloc，realloc等函数</code>，不仅要保证<code>前后类型一致</code>，还要<code>断言空指针</code>，感觉还是太麻烦了，所以<code>在C++使用了更简洁方便的动态开辟函数</code></p><h2 id="内存申请"><a href="#内存申请" class="headerlink" title="内存申请"></a>内存申请</h2><p>通过<code>new</code>和<code>delete</code>操作符进行动态内存管理</p><p>🚩<strong>动态申请1个int类型的空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p2;</span><br></pre></td></tr></table></figure><p>🚩<strong>动态申请存储10个int类型的数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="type">int</span>* p3 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(p3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] p4;</span><br></pre></td></tr></table></figure><p>🚩<strong>动态申请存储1个int类型的空间并初始化为10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p5 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br></pre></td></tr></table></figure><p>🚩<strong>动态申请数组并初始化多个元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p6 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span>[] p6;</span><br></pre></td></tr></table></figure><p>🚩<strong>访问开辟的数组元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; p4[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] p4;</span><br></pre></td></tr></table></figure><p>对于指针 p4，<code>p4[i] 实际上等价于 *(p4 + i)</code>。也就是说，p4[0] 表示访问 p4 所指向的内存位置（即数组的第一个元素）的值</p><p><strong>那么new和delete存在的意义是什么？</strong></p><blockquote><p><code>在C语言中</code>，malloc只完成了纯粹的开空间操作，虽然calloc也能对空间初始化，但是<code>只能将所有元素初始化</code><br><code>在C++中</code>，new能够<code>初始化部分元素</code>，比如在链表里能够调用<code>构造函数</code>来完成初始化操作，<code>省去了写BuyNewnode函数的麻烦</code>。delete相对于free<code>会进行严格的类型检查</code>，<code>确保释放的是new开辟的空间</code>，而且会调用<code>析构函数</code></p></blockquote><p>🔥<strong>值得注意的是：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c20818eb12c74253a083d7f66e5d906b.png" alt="在这里插入图片描述"></p><p>申请和释放<code>单个元素的空间</code>，使用<code>new</code>和<code>delete</code>操作符；申请和释放<code>连续的空间</code>，使用<code>new[]</code>和<code>delete[]</code>，注意要<code>匹配起来使用</code></p><h2 id="operator-new与operator-delete函数"><a href="#operator-new与operator-delete函数" class="headerlink" title="operator new与operator delete函数"></a>operator new与operator delete函数</h2><p>我们知道<code>malloc是开空间</code>，<code>new是通过开空间+构造函数实现的</code>，那么new的开空间可以直接调用malloc吗，答案是<code>不可以的</code></p><p>首先我们要知道<code>面向对象开空间失败喜欢抛异常而不是返回nullptr</code></p><p>🚩<strong>malloc开无限大空间</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f7d6c55263a648279ce41f2bb445b8e9.png" alt="在这里插入图片描述"></p><p>malloc开空间<code>没有显示任何错误难以发现</code></p><p>🚩<strong>new开无限大空间</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b89ae528c98540b9965457b6db42fb12.png" alt="在这里插入图片描述"></p><p>new开空间会在开空间失败后<code>抛出异常</code>，用<code>try...catch...捕获异常显示具体错误</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败，</span></span><br><span class="line"><span class="comment">尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try to allocate size bytes</span></span><br><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// report no memory</span></span><br><span class="line"><span class="comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">_RAISE(nomem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据<code>operator new的底层代码</code>，new的开空间错误是要抛异常的，不能直接调用，而是<code>new先调用operator new</code>，然后<code>operator new再调用malloc开空间</code>。实际上<code>malloc是被封装在了operator new里面的</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5eefe62b44fe42619d63883ec1ce54c7.png" alt="在这里插入图片描述"></p><p>对自定义类型进行操作时，调试状态下转到反汇编可以发现<code>有两条call指令</code>，<code>一条调用operator new</code>，<code>一条调用构造函数</code>，也能证实我们上面的说法，<code>operator delete也是同理</code></p><p>那么又延伸出另一个问题，<strong>operator new和operator delete的调用顺序是怎么样的？</strong></p><p>假设<code>类Stack</code>需要开辟<code>动态数组_arry</code>，<code>容量_capacity</code>，<code>大小_size</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack* p1 = <span class="keyword">new</span> Stack;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/11b28f2ee26c4fc19ab07e3fc5ab22f3.png" alt="在这里插入图片描述"></p><p>p1作为<code>指针变量存放地址</code>，在<code>栈上存储</code>，然后new的空间在<code>堆上开辟</code>，_array又<code>指向开辟的数组</code>。如果按我们正常想的<code>先调用operator delete释放堆空间</code>，那么<code>_array指向的数组即使调用析构函数也找不到</code>，无法释放</p><p>因此我们可以整理出<code>operator new和operator delete的调用顺序</code></p><ol><li>调用<strong>operator new开辟空间</strong></li><li>调用<strong>构造函数</strong></li><li>调用<strong>析构函数</strong></li><li>调用<strong>operator delete释放空间</strong></li></ol><h2 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>)</span><br><span class="line">: _a(a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A():&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~A():&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定位new/replacement new</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// p1现在指向的只不过是与A对象相同大小的一段空间，还不能算是一个对象，因为构造函数没有执行</span></span><br><span class="line">A* p1 = (A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="keyword">new</span>(p1)A; <span class="comment">// 注意：如果A类的构造函数有参数时，此处需要传参</span></span><br><span class="line">p1-&gt;~<span class="built_in">A</span>();</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">A* p2 = (A*)<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line"><span class="keyword">new</span>(p2)<span class="built_in">A</span>(<span class="number">10</span>);</span><br><span class="line">p2-&gt;~<span class="built_in">A</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p2)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位new表达式是<code>在已分配的原始内存空间中调用构造函数初始化一个对象</code>，这里p1，p2只是个自定义类型，无法调用构造函数，所以要用定位new</p><p><strong>其语法形式为：</strong></p><blockquote><p><code>new (place_address) type</code>或者<code>new (place_address) type(initializer-list)</code><br><code>place_address</code>必须是<code>一个指针</code>，<code>initializer-list</code>是<code>类型的初始化列表</code></p></blockquote><p>在实际应用中，<code>定位new一般用于池化技术</code>，也就是向内存申请一块内存池使用，因为频繁的向内存申请堆太麻烦了，所以申请一块内存池用于堆开辟空间</p><p>但是内存池的分配操作仅仅是对内存指针进行移动和管理，它<code>只负责提供一块可用的原始内存</code>，<code>并没有内存初始化的操作</code></p><blockquote><p>当使用 new 操作符来<code>创建对象</code>时，它会完成两个主要步骤：首先<code>分配内存</code>，然后<code>自动调用对象的构造函数对这块内存进行初始化</code>。但内存池的分配操作<code>只是完成了第一步</code>，即提供内存，并<code>没有触发构造函数调用的机制</code>，此时定位new的作用就体现出来了，显式调用构造函数实现初始化操作</p></blockquote><h1 id="关于内存管理的常见知识点"><a href="#关于内存管理的常见知识点" class="headerlink" title="关于内存管理的常见知识点"></a>关于内存管理的常见知识点</h1><h2 id="malloc-free和new-delete的区别"><a href="#malloc-free和new-delete的区别" class="headerlink" title="malloc&#x2F;free和new&#x2F;delete的区别"></a>malloc&#x2F;free和new&#x2F;delete的区别</h2><p><strong>malloc&#x2F;free和new&#x2F;delete的共同点是：</strong></p><p>都是从<code>堆上申请空间</code>，并且需要<code>用户手动释放</code></p><p><strong>不同的地方是：</strong></p><ol><li>malloc和free是<code>函数</code>，new和delete是<code>操作符</code></li><li>malloc申请的空间<code>不会初始化</code>，new可以<code>初始化</code></li><li>malloc申请空间时，需要<code>手动计算空间大小并传递</code>，new只需在<code>其后跟上空间的类型即可</code>， 如果是多个对象，<code>[]中指定对象个数即可</code></li><li>malloc的返回值为void*, 在使用时<code>必须强转</code>，new不需要，因为new后跟的是<code>空间的类型</code></li><li>malloc申请空间失败时，<code>返回的是NULL</code>，因此使用时<code>必须判空</code>，new不需要，但是<code>new需要捕获异常</code></li><li>申请自定义类型对象时，malloc&#x2F;free<code>只会开辟空间</code>，<code>不会调用构造函数与析构函数</code>，而new在<code>申请空间后会调用构造函数完成对象的初始化</code>，delete在<code>释放空间前会调用析构函数完成空间中资源的清理</code></li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>什么是内存泄漏？</strong></p><blockquote><p>内存泄漏指因为疏忽或错误造成<code>程序未能释放已经不再使用的内存的情况</code>。内存泄漏并不是指内存在物理上的消失，而是应用程序分配某段内存后，因为设计错误，<code>失去了对该段内存的控制</code>，<code>因而造成了内存的浪费</code></p></blockquote><p><strong>如何检测内存泄漏?</strong></p><p>在vs下，可以使用windows操作系统提供的<code>_CrtDumpMemoryLeaks() </code>函数进行简单检测，该函数只报出了大概泄漏了多少个字节，没有其他更准确的位置信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 将该函数放在main函数之后，每次程序退出的时候就会检测是否存在内存泄漏</span></span><br><span class="line">_CrtDumpMemoryLeaks();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 程序退出后，在输出窗口中可以检测到泄漏了多少字节，但是没有具体的位置</span></span><br><span class="line">Detected memory leaks!</span><br><span class="line">Dumping objects -&gt;</span><br><span class="line">&#123;<span class="number">79</span>&#125; normal block at <span class="number">0x00EC5FB8</span>, <span class="number">40</span> bytes <span class="type">long</span>.</span><br><span class="line">Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD</span><br><span class="line">Object dump complete.</span><br></pre></td></tr></table></figure><p>因此写代码时一定要小心，尤其是动态内存操作时，一定要记着释放。但有些情况下总是防不胜防，简单的可以<code>采用上述方式快速定位下</code>。如果工程比较大，内存泄漏位置比较多，不太好查时一般都是<code>借助第三方内存泄漏检测工具处理的</code></p><p><strong>在linux下内存泄漏检测：</strong> <a href="https://blog.csdn.net/gatieme/article/details/51959654">linux下几款内存泄漏检测工具</a><br><strong>在windows下使用第三方工具：</strong> <a href="https://blog.csdn.net/GZrhaunt/article/details/56839765">VLD工具说明</a><br><strong>其他工具：</strong> <a href="https://www.cnblogs.com/liangxiaofeng/p/4318499.html">内存泄漏工具比较</a></p><p>内存泄漏非常常见，<code>解决方案分为两种</code>：</p><ol><li><code>事前预防型</code>，如智能指针等</li><li><code>事后查错型</code>，如泄漏检测工具</li></ol><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/db7665f3cdfc4aae9254e598a8ceceef.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++时之律者的代码掌控：日期类计算器万字详解</title>
      <link href="/2025/01/27/CPP%E5%88%9D%E9%98%B6/%E6%97%A5%E6%9C%9F%E7%B1%BB%E8%AE%A1%E7%AE%97%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/01/27/CPP%E5%88%9D%E9%98%B6/%E6%97%A5%E6%9C%9F%E7%B1%BB%E8%AE%A1%E7%AE%97%E5%99%A8%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b7488de18f464697823af9568a17c2f7.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://www.sojson.com/time/jsqnew.html">日期计算器（网页版）</a></p></blockquote><h1 id="基本构造实现"><a href="#基本构造实现" class="headerlink" title="基本构造实现"></a>基本构造实现</h1><h2 id="获取某年某月的天数"><a href="#获取某年某月的天数" class="headerlink" title="获取某年某月的天数"></a>获取某年某月的天数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMonthDay</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> days[<span class="number">13</span>] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>,<span class="number">31</span> &#125;;</span><br><span class="line"><span class="type">int</span> day = days[month];</span><br><span class="line"><span class="keyword">if</span> (month == <span class="number">2</span> &amp;&amp; ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)))</span><br><span class="line">&#123;</span><br><span class="line">day += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>口诀:（<code>四年一润，百年不润</code>） 或者 <code>四百年一润</code></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>用于<code>初始化创建的每一个实例</code></p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">_year = d._year;</span><br><span class="line">_month = d._month;</span><br><span class="line">_day = d._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常<code>拷贝构造函数</code>用于<code>用一个已经存在的对象初始化另一个对象</code>，如<code>Date d3(d1)</code>，等价于<code>Date d3 = d1</code></p><p>但是像<code>d1 = d2</code>是<code>两个已经存在的对象之间的复制</code>，调用的是<code>=的运算符重载</code>，而不是拷贝构造</p><p>具体实现解析可以看往期博客：</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/144340464">C++天使的灵动心跳代码：类和对象（中下）</a></p></blockquote><h2 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _month &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于<code>打印日期类</code></p><h1 id="运算符重载接口实现"><a href="#运算符重载接口实现" class="headerlink" title="运算符重载接口实现"></a>运算符重载接口实现</h1><h2 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h2><h3 id=""><a href="#" class="headerlink" title="&lt;运算符重载"></a>&lt;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &lt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &lt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>日期小于的比较</code>，我们要先思考日期的比较需要<code>分别比较年月日</code>，从年开始依次比较，一旦成立则说明小于成立；反之应该是大于，小于不成立</p><p>🔥<strong>值得注意的是：</strong></p><ol><li>传参时要特别注意，<code>运算符有几个操作数，就传几个参数</code>，<code>this指针也算在参数中</code>，<br>所以这里<code>默认&lt;左边的对象是用this指针</code>传过去了，<code>右边的对象引用传参</code>（加const避免被传的数值被修改，引用传参提高效率）</li><li>这里的运算符重载函数是<code>成员函数</code></li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f48dd5ff42ed4ec4b0765a28ec7ae72e.png" alt="在这里插入图片描述"></p><p>调试状态下，转到反汇编比较可以观察到，两种写法的底层代码是一样的，说明了<code>d1 &lt; d2</code>会转换成<code>d1.operator&lt;(d2)</code></p><p><strong>如果是非成员函数的情况下呢？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &lt; (<span class="type">const</span> Date&amp; x1, <span class="type">const</span> Date&amp; x2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x<span class="number">1.</span>_year &lt; x<span class="number">2.</span>_year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x<span class="number">1.</span>_year == x<span class="number">2.</span>_year &amp;&amp; x<span class="number">1.</span>_month &lt; x<span class="number">2.</span>_month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x<span class="number">1.</span>_year == x<span class="number">2.</span>_year &amp;&amp; x<span class="number">1.</span>_month == x<span class="number">2.</span>_month &amp;&amp; x<span class="number">1.</span>_year &lt; x<span class="number">2.</span>_year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在<code>类内要添加友元的声明</code>，在<code>类外定义</code>运算符重载函数时，要<code>传两个参数</code>，原因在于<code>非成员函数没有隐含的 this 指针来指向调用对象</code>。不像成员函数，通过 this 指针隐式获取左侧对象，只需要显式接收右侧对象作为参数</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b1c1f9e13f404849a143a54a78adcaff.png" alt="在这里插入图片描述"><br>同样转到反汇编比较，可以观察到<code>非成员函数</code>下，<code>d1 &lt; d2</code>会转换成<code>operator&lt;(d1, d2)</code>，底层代码也清晰的指出要传几个参数</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="&#x3D;&#x3D;运算符重载"></a>&#x3D;&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _year == x._year</span><br><span class="line">&amp;&amp; _month == x._month</span><br><span class="line">&amp;&amp; _day == x._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>==的运算符重载</code>很简单，直接返回即可，如果<code>相等返回true</code>；<code>反之则为false</code></p><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;&#x3D;运算符重载"></a>&lt;&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; x || *<span class="keyword">this</span> == x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，注意<code>左边的数是由this指针隐式传递</code>，满足<code>小于或等于</code>都能成立</p><h3 id="运算符重载-1"><a href="#运算符重载-1" class="headerlink" title="&gt;运算符重载"></a>&gt;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &gt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &gt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &gt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _year &gt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>大于的运算符重载</code>和小于的同理，修改符号即可</p><p>但是这样写实在是太麻烦了，根据上面写的<code>==的运算符重载</code>，<code>&gt;=运算符重载</code>和<code>&lt;运算符重载</code>，可以极大的简化和<code>日期类比较</code>有关的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &gt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;=</code>的反面就是<code>&gt;</code>，借助这一点能够<code>减少很多不必要的代码</code></p><h3 id="运算符重载-2"><a href="#运算符重载-2" class="headerlink" title="&gt;&#x3D;运算符重载"></a>&gt;&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，借助刚写完的<code>&gt;运算符重载</code>也能简单的写出<code>&gt;=运算符重载函数</code></p><h3 id="运算符重载-3"><a href="#运算符重载-3" class="headerlink" title="!&#x3D;运算符重载"></a>!&#x3D;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>!=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>==运算符重载</code>取反即可</p><h2 id="日期与天数的计算"><a href="#日期与天数的计算" class="headerlink" title="日期与天数的计算"></a>日期与天数的计算</h2><h3 id="日期-天数"><a href="#日期-天数" class="headerlink" title="日期+&#x3D;天数"></a>日期+&#x3D;天数</h3><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c182e7babc3d456c90999dc47c1e6db5.png" alt="在这里插入图片描述"><br>首先我们要明白<code>日期+天数</code>如何计算，那么经过举例演算可以发现，用<code>进位的方式</code>实现日期+天数，简单来说就是<code>天满了往月进，月满了往年进</code>，依赖于<code>GetMonthDay函数处理每个月的天数</code>，不断减掉天数直到<code>合法为止</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> -= -day;</span><br><span class="line">&#125;</span><br><span class="line">_day += day;</span><br><span class="line"><span class="keyword">while</span> (_day &gt; <span class="built_in">GetMonthDay</span>(_year, _month))</span><br><span class="line">&#123;</span><br><span class="line">_day -= <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">++_month;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">++_year;</span><br><span class="line">_month = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们是在<code>原本的日期</code>上操作，所以是<code>+=</code>且<code>引用返回</code>，而不是<code>+</code>，注意<code>加上负数等同于减去正数</code>，也可以<code>用abs取绝对值</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + day;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+=</code>还可以利用下面实现的<code>日期+天数</code>的运算来写</p><h3 id="2-2-2-日期-天数"><a href="#2-2-2-日期-天数" class="headerlink" title="2.2.2 日期+天数"></a>2.2.2 日期+天数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Date Date::<span class="keyword">operator</span>+(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">tmp._day += day;</span><br><span class="line"><span class="keyword">while</span> (tmp._day &gt; <span class="built_in">GetMonthDay</span>(tmp._year, tmp._month))</span><br><span class="line">&#123;</span><br><span class="line">tmp._day -= <span class="built_in">GetMonthDay</span>(tmp._year, tmp._month);</span><br><span class="line">++tmp._month;</span><br><span class="line"><span class="keyword">if</span> (tmp._month == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">++_year;</span><br><span class="line">tmp._month = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么真正的<code>日期+天数</code>，应该是<code>不会修改原来的日期的</code>，而是<code>以另一个变量返回</code>，所以这里就可以<code>利用拷贝构造</code>，将一个新的日期返回，注意<code>不能引用返回</code>，因为<code>tmp是局部变量</code>，出了作用域就被销毁了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date Date::<span class="keyword">operator</span>+(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">tmp += day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理<code>+</code>也可以利用<code>日期+=天数</code>来运算，但是这两种简洁的写法不可能同时存在，因为<code>至少要有一种是完整实现了的</code>，那么就可以对<code>两种组合进行比对</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8afbaf0d2d4c4c9f88c19903e9256397.png" alt="在这里插入图片描述"><br>考虑到变量的拷贝以及创建，明显是<code>创建完整的+=运算，然后据此写+运算</code>更优，因为这个组合<code>创建的对象更少</code>，<code>减少对拷贝构造的调用</code></p><h3 id="日期−-天数"><a href="#日期−-天数" class="headerlink" title="日期−&#x3D;天数"></a>日期−&#x3D;天数</h3><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0d62551057e1401898d63ee0fdcb9c68.png" alt="在这里插入图片描述"><br>举一反三，既然<code>日期+天数是进位</code>，那么<code>日期-天数就是借位</code>，每当<code>被减成负数</code>的时候，要注意是<code>向上个月借天数</code>，<code>不是本月的天数</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; Date::<span class="keyword">operator</span>-=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += -day;</span><br><span class="line">&#125;</span><br><span class="line">_day -= day;</span><br><span class="line"><span class="keyword">while</span> (_day &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">--_month;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_month = <span class="number">12</span>;</span><br><span class="line">--_year;</span><br><span class="line">&#125;</span><br><span class="line">_day += <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>+=</code>的写法其实大差不差，注意<code>减去负数就是加上正数</code></p><h3 id="日期−天数"><a href="#日期−天数" class="headerlink" title="日期−天数"></a>日期−天数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date Date::<span class="keyword">operator</span>-(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">*<span class="keyword">this</span> -= day;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>-=运算减少不必要的算法</code>，记得保存原先的日期</p><h2 id="日期的自增自减"><a href="#日期的自增自减" class="headerlink" title="日期的自增自减"></a>日期的自增自减</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置++"></a>前置++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; Date::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>+=运算</code>的前提下，日期也是能实现自增的，所以<code>不用担心自增后会不会越过当月的天数</code>，在+&#x3D;已经处理好了</p><h3 id="后置"><a href="#后置" class="headerlink" title="后置++"></a>后置++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date Date::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置++需要<code>提前保存值</code>，因为是<code>先使用再++</code></p><p>🔥<strong>值得注意的是：</strong></p><ol><li><code>前置++</code>和<code>后置++</code>虽然是<code>运算符重载</code>，但是形式上也构成<code>函数重载</code></li><li><code>后置++</code>增加这个int参数<code>不是为了接受具体的值</code>，<code>仅仅是占位</code>，跟<code>前置++</code>构成重载</li><li>int这个位置<code>传任何值都可以</code>，实际调用的时候<code>前置++</code>和<code>后置++</code>可能分别为<code>d1.operator++()</code>和<code>d1.operator++(0)</code>，<code>括号内的值是随机的</code></li></ol><h3 id="前置−−"><a href="#前置−−" class="headerlink" title="前置−−"></a>前置−−</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date&amp; Date::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>−−的操作和++几乎是一样的</code>，这里就不过多赘述了</p><h3 id="后置−−"><a href="#后置−−" class="headerlink" title="后置−−"></a>后置−−</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date Date::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期-日期"><a href="#日期-日期" class="headerlink" title="日期-日期"></a>日期-日期</h2><p>通常日期的计算我们一般是用来<code>计算两个日期之前相差多少天</code>，因此我们的<code>运算符重载是否有意义决定了是否要创建这个重载</code>，所以<code>只考虑日期-日期</code>，<code>日期+日期是没有意义的</code><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3fab21dfd5a949cf99092378c3be9d54.png" alt="在这里插入图片描述"><br>根据前面的算法，我们也能很容易总结出计算方法，把<code>年份大的的日期的月份天数</code>，<code>假设成和一样的年份小的一样</code>，然后两者<code>作天数差的计算</code>即可</p><p>其实还有更简单的思路，就是让<code>年份小的日期一天一天去++</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Date::<span class="keyword">operator</span>-(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">Date max = *<span class="keyword">this</span>;</span><br><span class="line">Date min = d;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">max = d;</span><br><span class="line">min = *<span class="keyword">this</span>;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (min != max)</span><br><span class="line">&#123;</span><br><span class="line">++min;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最妙的是这个flag，能够刚好<code>体现出计算的正负</code>，虽然这种方式没有上面那种来的快，但是这种程度的差距对于计算机来说其实是可以忽略不计的</p><h2 id="日期的输入输出"><a href="#日期的输入输出" class="headerlink" title="日期的输入输出"></a>日期的输入输出</h2><p>基本数据类型<code>基于cout和cin的使用</code>能够很方便的进行输入输出的操作，那么日期依托于<code>运算符重载</code>也能达到此类效果，<code>cout</code>和<code>cin</code>分别属于<code>iostram库</code>里的<code>ostream</code>和<code>istream</code></p><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;&lt;运算符重载"></a>&lt;&lt;运算符重载</h3><p>根据前面的经验，我们依旧把<code>&lt;&lt;运算符重载放在成员函数里</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Date::<span class="keyword">operator</span>&lt;&lt;(ostream&amp; out)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; d._year &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; d._month &lt;&lt; <span class="string">&quot;月&quot;</span> &lt;&lt; d._day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是当我们输出的时候就报错了，这是因为正常情况下<code>cout&lt;&lt;d1</code>会转化成<code>d1.operator&lt;&lt;cout</code>，<code>Date对象默认占用第一个参数，也就是做了左操作数</code>，所以正确的写法应该是<code>d1&lt;&lt;cout</code>才能正常输出，但是这样太奇怪了，完全<code>不符合我们的使用习惯</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; d._year &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; d._month &lt;&lt; <span class="string">&quot;月&quot;</span> &lt;&lt; d._day;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然不能写成成员函数，那就在<code>类外写成非成员函数</code>，就可以带入两个参数，<code>cout&lt;&lt;d1</code>就会转化成<code>operator&lt;&lt;(cout,d1)</code>，符合书写情况</p><p>🔥<strong>值得注意的是：</strong></p><ol><li>cout<code>从左往右</code>连续输出，所以要<code>返回ostream类型才能连续输出</code></li><li>类外访问私有变量使用<code>友元函数</code>就能解决</li><li><code>ostream&amp; out</code>前<code>不能加const</code>，因为流插入就是<code>不断改变cout</code>的过程</li></ol><h3 id="运算符重载-4"><a href="#运算符重载-4" class="headerlink" title="&gt;&gt;运算符重载"></a>&gt;&gt;运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，<code>流输入也是同样的格式</code></p><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><h2 id="Date-h"><a href="#Date-h" class="headerlink" title="Date.h"></a>Date.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdbool&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; d);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; out, <span class="type">const</span> Date&amp; d);</span><br><span class="line"><span class="comment">// 计算每个月的天数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMonthDay</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> days[<span class="number">13</span>] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>,<span class="number">31</span> &#125;;</span><br><span class="line"><span class="type">int</span> day = days[month];</span><br><span class="line"><span class="keyword">if</span> (month == <span class="number">2</span> &amp;&amp; ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)))</span><br><span class="line">&#123;</span><br><span class="line">day += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全缺省的构造函数</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">_year = d._year;</span><br><span class="line">_month = d._month;</span><br><span class="line">_day = d._day;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// d2(d1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印日期</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _year &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _month &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Date&amp; x);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> Date&amp; x);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> Date&amp; x);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> Date&amp; x);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; x);</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Date&amp; x);</span><br><span class="line">Date&amp; <span class="keyword">operator</span>+=(<span class="type">int</span> day);</span><br><span class="line">Date <span class="keyword">operator</span>+(<span class="type">int</span> day);</span><br><span class="line">Date&amp; <span class="keyword">operator</span>-=(<span class="type">int</span> day);</span><br><span class="line">Date <span class="keyword">operator</span>-(<span class="type">int</span> day);</span><br><span class="line">Date&amp; <span class="keyword">operator</span>++();</span><br><span class="line">Date <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">Date&amp; <span class="keyword">operator</span>--();</span><br><span class="line">Date <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> Date&amp; d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Date-c"><a href="#Date-c" class="headerlink" title="Date.c"></a>Date.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.&lt;运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &lt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &lt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _year &lt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.&gt;的运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &gt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_year &gt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month &gt; x._month)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_year == x._year &amp;&amp; _month == x._month &amp;&amp; _year &gt; x._year)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span> &gt; (<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt;= x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.=的运算符重载</span></span><br><span class="line"><span class="comment">///*void operator=(const Date&amp; d)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//_year = d._year;</span></span><br><span class="line"><span class="comment">//_month = d._month;</span></span><br><span class="line"><span class="comment">//_day = d._month;</span></span><br><span class="line"><span class="comment">//&#125;*/</span></span><br><span class="line"><span class="comment">//Date&amp; Date::operator=(const Date&amp; d)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//if (this != &amp;d)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//_year = d._year;</span></span><br><span class="line"><span class="comment">//_month = d._month;</span></span><br><span class="line"><span class="comment">//_day = d._day;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.==的运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _year == x._year</span><br><span class="line">&amp;&amp; _month == x._month</span><br><span class="line">&amp;&amp; _day == x._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.&lt;=的运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span> &lt; x || *<span class="keyword">this</span> == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.&gt;=的运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.!=的运算符重载</span></span><br><span class="line"><span class="type">bool</span> Date::<span class="keyword">operator</span>!=(<span class="type">const</span> Date&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(*<span class="keyword">this</span> == x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.+=的运算符重载</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>+=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> -= -day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//*this = *this + day;</span></span><br><span class="line"><span class="comment">//return *this;</span></span><br><span class="line">_day += day;</span><br><span class="line"><span class="keyword">while</span> (_day &gt; <span class="built_in">GetMonthDay</span>(_year, _month))</span><br><span class="line">&#123;</span><br><span class="line">_day -= <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">++_month;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">++_year;</span><br><span class="line">_month = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.+的运算符重载</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>+(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">tmp += day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tmp._day += day;</span></span><br><span class="line"><span class="comment">while (tmp._day &gt; GetMonthDay(tmp._year, tmp._month))</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">tmp._day -= GetMonthDay(tmp._year, tmp._month);</span></span><br><span class="line"><span class="comment">++tmp._month;</span></span><br><span class="line"><span class="comment">if (tmp._month == 13)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">++_year;</span></span><br><span class="line"><span class="comment">tmp._month = 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return tmp;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.前置++</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11.后置++</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12.-=的运算符重载</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>-=(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (day &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> += -day;</span><br><span class="line">&#125;</span><br><span class="line">_day -= day;</span><br><span class="line"><span class="keyword">while</span> (_day &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">--_month;</span><br><span class="line"><span class="keyword">if</span> (_month == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_month = <span class="number">12</span>;</span><br><span class="line">--_year;</span><br><span class="line">&#125;</span><br><span class="line">_day += <span class="built_in">GetMonthDay</span>(_year, _month);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//13.-的运算符重载</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>-(<span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Date <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">*<span class="keyword">this</span> -= day;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14.前置--</span></span><br><span class="line">Date&amp; Date::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//15.后置--</span></span><br><span class="line">Date Date::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Date tmp = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16.日期-日期</span></span><br><span class="line"><span class="type">int</span> Date::<span class="keyword">operator</span>-(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">Date max = *<span class="keyword">this</span>;</span><br><span class="line">Date min = d;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span> &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">max = d;</span><br><span class="line">min = *<span class="keyword">this</span>;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (min != max)</span><br><span class="line">&#123;</span><br><span class="line">++min;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n * flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//17.输出日期</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; d._year &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; d._month &lt;&lt; <span class="string">&quot;月&quot;</span> &lt;&lt; d._day;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//18.输入日期</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">in &gt;&gt; d._year &gt;&gt; d._month &gt;&gt; d._day;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f89a1db7800b4f91b564a3756d249ec5.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 类和对象 </tag>
            
            <tag> 运算符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】逆流的回环链桥：双链表</title>
      <link href="/2025/01/22/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/01/22/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双链表接口实现"><a href="#双链表接口实现" class="headerlink" title="双链表接口实现"></a>双链表接口实现</h1><p>这次我们实现的是<code>带头双向循环的链表</code>，不仅有指向前一个节点的prev指针，还有指向下一个节点的next指针，<code>最后一个节点有指向开头的指针next，开头的节点有指向结尾的指针prev，形成循环</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/21f6c25635df48698a09a0039637c636.png" alt="在这里插入图片描述"></p><p><strong>双链表定义：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* prev;</span><br><span class="line">LTDataType data;</span><br><span class="line">&#125;LTNode;</span><br></pre></td></tr></table></figure><p>有人问为什么每次都要重新定义数据类型，因为每次的节点数据类型不一定是一样的，<code>定义一下方便修改所有地方的数据类型</code></p><h2 id="双链表节点创建"><a href="#双链表节点创建" class="headerlink" title="双链表节点创建"></a>双链表节点创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LTNode* <span class="title">BuyListNode</span><span class="params">(LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LTNode* newnode = (LTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LTNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是和之前的链表节点创建一样，这里不过多叙述</p><h2 id="双链表初始化"><a href="#双链表初始化" class="headerlink" title="双链表初始化"></a>双链表初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LTNode* <span class="title">LTInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LTNode* phead = <span class="built_in">BuyListNode</span>(<span class="number">-1</span>);</span><br><span class="line">phead-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = phead;</span><br><span class="line"><span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会在主函数创建一个指针接收一个初始化指针，<code>prev和next都指向自己形成循环</code>，也就是一个哨兵位，也<code>间接规避了链表为空的情况</code>，直接可以PushBack节点</p><h2 id="双链表销毁"><a href="#双链表销毁" class="headerlink" title="双链表销毁"></a>双链表销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTDestroy</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">LTNode* next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(phead);</span><br><span class="line">phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>head是哨兵位需要开始时被访问，所以<code>从phead-&gt;next开始</code>，先保存下一个节点的指针，然后释放当前移动指针指向的节点，再把保存过的节点赋值给移动指针实现移动<code>遍历节点</code>，最后再释放哨兵位head</p><h2 id="双链表打印"><a href="#双链表打印" class="headerlink" title="双链表打印"></a>双链表打印</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPrint</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;= head =&gt;&quot;</span>);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %d =&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要根据双链表的特性来，双链表有哨兵位，所以<code>打印要从哨兵位的下一个节点开始打印</code>，直到遇到的节点的<code>next指针指向哨兵位</code></p><h2 id="双链表检查是否为空"><a href="#双链表检查是否为空" class="headerlink" title="双链表检查是否为空"></a>双链表检查是否为空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTEmpty</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="keyword">return</span> phead-&gt;next == phead ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了<code>方便在增删查改中避免链表为空的情况</code>，and<code>多处需使用到</code>，所以特别写一个判空函数，因为是循环链表，所以<code>指向自己表明链表只有一个哨兵位</code>，则返回0，反则返回1</p><h2 id="双链表尾插"><a href="#双链表尾插" class="headerlink" title="双链表尾插"></a>双链表尾插</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushBack</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">phead-&gt;prev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead-&gt;prev;</span><br><span class="line">newnode-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于是带头循环，所以每个节点都有4条逻辑线连接着，<code>通常先修改两个节点间的链接，再修改循环的链接</code></p><h2 id="双链表头插"><a href="#双链表头插" class="headerlink" title="双链表头插"></a>双链表头插</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushFront</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">newnode-&gt;next = phead-&gt;next;</span><br><span class="line">phead-&gt;next-&gt;prev = newnode;</span><br><span class="line">phead-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是什么情况下，都要<code>注意连接的顺序是否会影响到其他步骤的正常赋值</code>，所以头插就需要先链接newnode的next指针，即<code>通常先链接后面的节点</code></p><h2 id="双链表尾删"><a href="#双链表尾删" class="headerlink" title="双链表尾删"></a>双链表尾删</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopBack</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line"></span><br><span class="line">LTNode* tail = phead-&gt;prev;</span><br><span class="line">LTNode* tailPrev = tail-&gt;prev;</span><br><span class="line"></span><br><span class="line">tailPrev-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = tailPrev;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先遇到删除就要注意是不是空链表，存不存在节点来删除，然后要<code>分别存储最后一个节点和倒数第二个节点</code>，方便进行链接释放的操作</p><h2 id="双链表头删"><a href="#双链表头删" class="headerlink" title="双链表头删"></a>双链表头删</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopFront</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line"></span><br><span class="line">LTNode* first = phead-&gt;next;</span><br><span class="line">phead-&gt;next = first-&gt;next;</span><br><span class="line">first-&gt;next-&gt;prev = phead;</span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相同的操作，无论是删除还是销毁，都要<code>记得存储需要释放的节点相关指针</code>，因为需要在删除之后将其连接的的节点连接起来</p><h2 id="双链表查找"><a href="#双链表查找" class="headerlink" title="双链表查找"></a>双链表查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LTNode* <span class="title">LTFind</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在查找时肯定是查找有效的数据，所以我们查找是从哨兵位后一个节点开始的，查找方法也很简单，遍历整个双链表，看看能否找到相应的数据，找得到就返回对应节点，找不到就返回空</p><h2 id="双链表在pos位置插入x"><a href="#双链表在pos位置插入x" class="headerlink" title="双链表在pos位置插入x"></a>双链表在pos位置插入x</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTInsert</span><span class="params">(LTNode* pos, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">pos-&gt;prev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = pos-&gt;prev;</span><br><span class="line">pos-&gt;prev = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为双向链表有prev，就<code>不用在意是pos前还是pos后插入</code>，这里用的是pos前插入</p><h2 id="双链表在pos位置删除x"><a href="#双链表在pos位置删除x" class="headerlink" title="双链表在pos位置删除x"></a>双链表在pos位置删除x</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTErase</span><span class="params">(LTNode* phead, LTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line">pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实和头删尾删的原理是一样的，直接删除，然后将剩余两个断开的节点链接就行了</p><h1 id="顺序表和链表对比"><a href="#顺序表和链表对比" class="headerlink" title="顺序表和链表对比"></a>顺序表和链表对比</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d1ff28fec35f4045959cca47774fe662.png" alt="在这里插入图片描述"></p><p>顺序表和链表各有各的好处</p><p>🚩<strong>顺序表：</strong> 适用于对<code>随机访问性能要求高</code>，元素数量<code>可预估</code>，且不需要频繁进行插入和删除操作的场景</p><p>🚩<strong>链表：</strong> 适用于<code>需要频繁插入和删除元素</code>，元素数量<code>动态变化</code>，难以预估元素数量的场景</p><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/master/%E5%8F%8C%E9%93%BE%E8%A1%A8/%E5%8F%8C%E9%93%BE%E8%A1%A8">Gitee双链表代码</a></p></blockquote><h2 id="List-h"><a href="#List-h" class="headerlink" title="List.h"></a>List.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> LTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* next;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>* prev;</span><br><span class="line">LTDataType data;</span><br><span class="line">&#125;LTNode;</span><br><span class="line"></span><br><span class="line"><span class="function">LTNode* <span class="title">LTInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTDestroy</span><span class="params">(LTNode** pphead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPrint</span><span class="params">(LTNode* phead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LTNode* <span class="title">BuyListNode</span><span class="params">(LTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTEmpty</span><span class="params">(LTNode* phead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushBack</span><span class="params">(LTNode* phead, LTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopBack</span><span class="params">(LTNode* phead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushFront</span><span class="params">(LTNode* phead, LTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopFront</span><span class="params">(LTNode* phead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LTNode* <span class="title">LTFind</span><span class="params">(LTNode* phead, LTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTInsert</span><span class="params">(LTNode* pos, LTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTErase</span><span class="params">(LTNode* pos)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="List-c"><a href="#List-c" class="headerlink" title="List.c"></a>List.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;List.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">LTNode* <span class="title">LTInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LTNode* phead = <span class="built_in">BuyListNode</span>(<span class="number">-1</span>);</span><br><span class="line">phead-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = phead;</span><br><span class="line"><span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTDestroy</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line">LTNode* next = cur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(cur);</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(phead);</span><br><span class="line">phead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPrint</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&lt;= head =&gt;&quot;</span>);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %d =&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">LTNode* <span class="title">BuyListNode</span><span class="params">(LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LTNode* newnode = (LTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LTNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTEmpty</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="keyword">return</span> phead-&gt;next == phead ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushBack</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">LTNode* tail = phead-&gt;prev;</span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = tail;</span><br><span class="line">newnode-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopBack</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line"></span><br><span class="line">LTNode* tail = phead-&gt;prev;</span><br><span class="line">LTNode* tailPrev = tail-&gt;prev;</span><br><span class="line"></span><br><span class="line">tailPrev-&gt;next = phead;</span><br><span class="line">phead-&gt;prev = tailPrev;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPushFront</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">newnode-&gt;next = phead-&gt;next;</span><br><span class="line">phead-&gt;next-&gt;prev = newnode;</span><br><span class="line">phead-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTPopFront</span><span class="params">(LTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line"></span><br><span class="line">LTNode* first = phead-&gt;next;</span><br><span class="line">phead-&gt;next = first-&gt;next;</span><br><span class="line">first-&gt;next-&gt;prev = phead;</span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">LTNode* <span class="title">LTFind</span><span class="params">(LTNode* phead, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(phead);</span><br><span class="line">LTNode* cur = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (cur != phead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pos处插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTInsert</span><span class="params">(LTNode* pos, LTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"></span><br><span class="line">LTNode* newnode = <span class="built_in">BuyListNode</span>(x);</span><br><span class="line">pos-&gt;prev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;prev = pos-&gt;prev;</span><br><span class="line">pos-&gt;prev = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在pos处删除x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LTErase</span><span class="params">(LTNode* phead, LTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">LTEmpty</span>(phead));</span><br><span class="line">pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4ed7b9c03d5a455098f76bf91a0be8f7.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】探索数据的多米诺链：单链表</title>
      <link href="/2025/01/20/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/01/20/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="概念及结构"><a href="#概念及结构" class="headerlink" title="概念及结构"></a>概念及结构</h2><blockquote><p><code>链表</code>是一种<code>物理存储结构上非连续</code>、非顺序的存储结构，数据元素的<code>逻辑顺序</code>是通过链表中的<code>指针链接</code>次序实现的</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ba64440e5cc49e6b5e3d077d931a7b8.png" alt="请添加图片描述"><br>链式结构的<code>逻辑一般是连续的</code>，但是在<code>物理存储上不一定是连续的</code>，因为每个节点<code>都是从堆上申请来的</code>，从堆上申请的空间要根据实际情况分配空间，<code>两次申请可能是连续的也有可能不是连续的</code></p><p>简单来说，每个节点都存储了<code>下一个节点的地址</code>，即能找到下一个节点，就形成了链表</p><p>我们还需要了解几个概念：</p><p>🚩<strong>头结点</strong></p><blockquote><p>图中的<code>plist就是头结点</code>，位于链表的起始位置，但<code>不存储实际的有效数据</code>(有效数据指的是结构体的内的数据，而不是结构体地址)，主要作用是<code>作为链表的入口</code>，通过它的指针域来<code>指向链表中的第一个实际存储数据的节点</code></p></blockquote><p>🚩<strong>首节点</strong></p><blockquote><p>首节点就是跟在<code>头节点后的链表中第一个存储实际有效数据的节点</code></p></blockquote><p>🚩<strong>哨兵位</strong></p><blockquote><p>哨兵位和头结点类似，通常<code>不存储实际数据</code>，存储地址，哨兵位可以<code>看成一个灵活的节点</code>，可以在链表任何位置方便进行增删查改操作</p></blockquote><p><strong>每个节点的结构体：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SListNode</span></span><br><span class="line">&#123;</span><br><span class="line">SLTDataType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SListNode</span>* next;</span><br><span class="line">&#125;SLTNode;</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>链表有<code>三种</code>分类方式<br>🚩<strong>⑴单向或双向</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4c3a1af84728485292053ff34866e122.png" alt="请添加图片描述"></p><p>🚩<strong>⑵带头或不带头</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/38fd2c14173c4269b55d8e1b40a5d186.png" alt="请添加图片描述"></p><p>🚩<strong>⑶循环或者非循环</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2cd5ad5ec70f422ebe605ea447adae45.png" alt="请添加图片描述"></p><p>这三种情况能组合出<code>8种链表</code>，这里我们只介绍<code>两种常用的链表</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6774ce53a888452ea14fe05357172c3c.png" alt="请添加图片描述"><br><strong>无头单向非循环链表：</strong> 结构简单，实现麻烦，通常在<code>面试笔试中以题目形式出现比较多</code>(因为其他出成题目太难了)，单链表也更多的作为底层结构来进行算法应用</p><p><strong>带头双向循环链表：</strong> 结构复杂，实现简单，这个结构虽然结构复杂，但是<code>使用代码实现以后会发现结构会带来很多优势</code>，实现反而简单了</p><h1 id="单链表接口实现"><a href="#单链表接口实现" class="headerlink" title="单链表接口实现"></a>单链表接口实现</h1><h2 id="单链表节点创建"><a href="#单链表节点创建" class="headerlink" title="单链表节点创建"></a>单链表节点创建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SLTNode* <span class="title">BuySLTNode</span><span class="params">(SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* newnode = (SLTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SLTNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表中我们空间不够时需要不断扩容，链表中的节点申请函数就是这种类似的效果，但是顺序表是对它底层的数组进行二倍扩容，而<code>节点申请函数一次性只能申请一个节点</code>，用一个给一个，间接<code>避免了空间浪费</code>，注意<code>返回的是新节点的地址</code></p><h2 id="单链表打印"><a href="#单链表打印" class="headerlink" title="单链表打印"></a>单链表打印</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPrint</span><span class="params">(SLTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="comment">//while(cur-&gt;next != NULL)会遗漏最后一个数据</span></span><br><span class="line"><span class="comment">//while(cur != NULL)也可以这样写</span></span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line"><span class="comment">//cur++只有数组才这么写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先传入头结点，然后我们需要一个<code>cur指针作为移动指针</code>来遍历单链表中的数据，每个节点的<code>next都存储了下一个节点的地址</code>，所以循环赋值就可以实现<code>单链表的移动</code>，最后一个节点指向的是空指针</p><p>🔥<strong>值得注意的是：</strong> <code>顺序表的打印</code>需要断言传入的结构体指针是因为该<code>指针涉及到访问</code>，万一传入的<code>空指针</code>，会造成<code>非法访问</code>；<code>链表的打印</code>有可能该<code>链表本来就是空的</code>，<code>空链表也是能打印的</code>，而且也<code>不涉及指针访问</code>，所以加断言反而不合理</p><h2 id="单链表尾插"><a href="#单链表尾插" class="headerlink" title="单链表尾插"></a>单链表尾插</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushBack</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分没有节点，和有节点的情况</span></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凡是涉及增加删除节点的操作，都要考虑是否为空的情况要不要特别考虑，因此这里<code>为空时</code>直接将<code>头指针和新节点链接即可</code>；<code>不为空时</code>循环遍历找到最后一个节点，将<code>最后一个节点和新节点连接</code></p><p>🔥<strong>值得注意的是：</strong> 循环判断条件为<code>tail-&gt;next != NULL</code>，因为为空时可能要修改头指针存的地址，所以应该传二级指针</p><h2 id="单链表头插"><a href="#单链表头插" class="headerlink" title="单链表头插"></a>单链表头插</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushFront</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">newnode-&gt;next = *pphead;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头指针中存储的是第一个节点的地址，所以<code>newnode-&gt;next = *pphead</code>，然后newnode就成了第一个节点，那么<code>当前头指针存的就是当前第一个节点newnode的地址</code></p><h2 id="单链表尾删"><a href="#单链表尾删" class="headerlink" title="单链表尾删"></a>单链表尾删</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopBack</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line"><span class="built_in">assert</span>(*pphead);<span class="comment">//*phead要指针访问所以要断言</span></span><br><span class="line"><span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>)<span class="comment">//分没有节点，和有节点的情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找最后一个节点的前一个节点</span></span><br><span class="line">SLTNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev = tail;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">prev-&gt;next = <span class="literal">NULL</span>;<span class="comment">//free之后可以赋值但不能指针访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>当没有节点时</code>，删除的就是头指针，直接释放即可；<code>当有节点时</code>，我们要给最后一个节点和倒数第二个节点做标记，因为<code>最后一个节点要释放</code>，<code>倒数第二个节点需要把他的next置为NULL</code></p><h2 id="单链表头删"><a href="#单链表头删" class="headerlink" title="单链表头删"></a>单链表头删</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopFront</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line"><span class="built_in">assert</span>(*pphead);</span><br><span class="line">SLTNode* first = *pphead;</span><br><span class="line">*pphead = first-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先存储首节点的地址，便于把<code>首节点的下一个节点传给头节点</code>，注意不要先释放节点，避免非法访问</p><h2 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SLTNode* <span class="title">SListFind</span><span class="params">(SLTNode* phead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和顺序表一样，通过简单的<code>遍历链表</code> 一 一 对比值即可</p><h2 id="单链表在pos位置插入x"><a href="#单链表在pos位置插入x" class="headerlink" title="单链表在pos位置插入x"></a>单链表在pos位置插入x</h2><h3 id="pos前"><a href="#pos前" class="headerlink" title="pos前"></a>pos前</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SLTPushFront</span>(pphead, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (prev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">prev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样是分为链表为空和链表不为空的情况，<code>当链表为空时</code>，相当于<code>头插</code>；<code>当链表不为空时</code>，<code>prev找到pos的前一个位置</code>，然后进行链接操作即可</p><h3 id="pos后"><a href="#pos后" class="headerlink" title="pos后"></a>pos后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertAfter</span><span class="params">(SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">newnode-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next = newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码形式上来看，<code>pos后</code>的插入明显是比<code>pos前插入更简单的</code>，pos前需要<code>多传一个头指针参数</code>，找到pos前一个数的位置；pos后只需要在pos后<code>直接链接</code>即可</p><h2 id="单链表在pos位置删除x"><a href="#单链表在pos位置删除x" class="headerlink" title="单链表在pos位置删除x"></a>单链表在pos位置删除x</h2><h3 id="pos前-1"><a href="#pos前-1" class="headerlink" title="pos前"></a>pos前</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*pphead == pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SLTPopFront</span>(pphead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (prev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">prev-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line"><span class="comment">//pos = NULL;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和在pos位置删除其实是一样的，分为<code>空和不空的链表</code>，但是一般我们<code>不在函数内将要删除的节点置为空</code>，习惯性在函数外进行此操作</p><h3 id="pos后-1"><a href="#pos后-1" class="headerlink" title="pos后"></a>pos后</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseAfter</span><span class="params">(SLTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(pos-&gt;next);</span><br><span class="line">SLTNode* del = pos-&gt;next;</span><br><span class="line">pos-&gt;next = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line"><span class="comment">//del = NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接释放pos位置之后的节点即可，但是要注意需要<code>断言pos-&gt;next</code>，<code>万一是最后一个节点的话</code>，在其后删除会报错</p><h2 id="单链表销毁"><a href="#单链表销毁" class="headerlink" title="单链表销毁"></a>单链表销毁</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTDestroy</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* pcur = *pphead;</span><br><span class="line"><span class="keyword">while</span> (pcur)</span><br><span class="line">&#123;</span><br><span class="line">SLTNode* del = pcur;</span><br><span class="line">pcur = pcur-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">&#125;</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>销毁的方法也不难，就是遍历链表，只要链表不为空就循环释放节点，关键是我们在释放前要把下一个节点记录下来，如果直接释放了当前节点，那么就找不到下一个节点了，<code>所以我们要把下一个节点保存下来才释放当前节点</code></p><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/master/%E5%8D%95%E9%93%BE%E8%A1%A8">Gitee单链表代码</a></p></blockquote><h2 id="SList-h"><a href="#SList-h" class="headerlink" title="SList.h"></a>SList.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLTDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SListNode</span></span><br><span class="line">&#123;</span><br><span class="line">SLTDataType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SListNode</span>* next;</span><br><span class="line">&#125;SLTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPrint</span><span class="params">(SLTNode* phead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SLTNode* <span class="title">BuySLTNode</span><span class="params">(SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushBack</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushFront</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopBack</span><span class="params">(SLTNode** pphead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopFront</span><span class="params">(SLTNode** pphead)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SLTNode* <span class="title">SListFind</span><span class="params">(SLTNode* phead, SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos, SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertAfter</span><span class="params">(SLTNode* pos, SLTDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseAfter</span><span class="params">(SLTNode* pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTDestroy</span><span class="params">(SLTNode** pphead)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="SList-c"><a href="#SList-c" class="headerlink" title="SList.c"></a>SList.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPrint</span><span class="params">(SLTNode* phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, cur-&gt;data);</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">SLTNode* <span class="title">BuySLTNode</span><span class="params">(SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* newnode = (SLTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SLTNode));</span><br><span class="line"><span class="keyword">if</span> (newnode == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushBack</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*pphead == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail-&gt;next = newnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPushFront</span><span class="params">(SLTNode** pphead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">newnode-&gt;next = *pphead;</span><br><span class="line">*pphead = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopBack</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line"><span class="built_in">assert</span>(*pphead);</span><br><span class="line"><span class="keyword">if</span> ((*pphead)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(*pphead);</span><br><span class="line">*pphead = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">SLTNode* tail = *pphead;</span><br><span class="line"><span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev = tail;</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tail);</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br><span class="line">prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTPopFront</span><span class="params">(SLTNode** pphead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pphead);</span><br><span class="line"><span class="built_in">assert</span>(*pphead);</span><br><span class="line">SLTNode* first = *pphead;</span><br><span class="line">*pphead = first-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(first);</span><br><span class="line">first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找节点</span></span><br><span class="line"><span class="function">SLTNode* <span class="title">SListFind</span><span class="params">(SLTNode* phead, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SLTNode* cur = phead;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos前插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="keyword">if</span> (pos == *pphead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SLTPushBack</span>(pphead, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (prev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">prev-&gt;next = newnode;</span><br><span class="line">newnode-&gt;next = pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos前删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseBefore</span><span class="params">(SLTNode** pphead, SLTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*pphead == pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SLTPopFront</span>(pphead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SLTNode* prev = *pphead;</span><br><span class="line"><span class="keyword">while</span> (prev-&gt;next != pos)</span><br><span class="line">&#123;</span><br><span class="line">prev = prev-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">prev-&gt;next = pos-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pos);</span><br><span class="line"><span class="comment">//pos = NULL;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos后插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTInsertAfter</span><span class="params">(SLTNode* pos, SLTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line">SLTNode* newnode = <span class="built_in">BuySLTNode</span>(x);</span><br><span class="line">newnode-&gt;next = pos-&gt;next;</span><br><span class="line">pos-&gt;next = newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos后删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLTEraseAfter</span><span class="params">(SLTNode* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(pos-&gt;next);</span><br><span class="line">SLTNode* del = pos-&gt;next;</span><br><span class="line">pos-&gt;next = del-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(del);</span><br><span class="line">del = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/512d6bd8f19041658d9f2ec505d6653a.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】序列系统重构：顺序表</title>
      <link href="/2025/01/16/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2025/01/16/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><blockquote><p>线性表是<code>n个具有相同特性的数据元素的有限序列</code>。线性表是一种在实际中广泛使用的数据结构，常见的线性表：顺序表、链表、栈、队列、字符串…</p></blockquote><p>线性表在<code>逻辑上</code>是线性结构，也就说<code>是连续的</code>一条直线。但是在<code>物理结构上</code>并<code>不一定是连续的</code>，线性表在物理上存储时，通常以数组和链式结构的形式存储。</p><h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><h2 id="概念及结构"><a href="#概念及结构" class="headerlink" title="概念及结构"></a>概念及结构</h2><blockquote><p><code>顺序表</code>是线性表的一种存储方式，它是用<code>一组连续的存储单元</code>依次存储线性表的数据元素。简单来说，就像是把<code>线性表中的元素一个挨着一个地放在数组中</code>进行<code>增删查改</code>工作，就像在一排连续的小格子里存放东西一样</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ba19de5b8a54a6d9a4213c4a3bc2ac3.png" alt="请添加图片描述"></p><h3 id="静态顺序表"><a href="#静态顺序表" class="headerlink" title="静态顺序表"></a>静态顺序表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态开辟（不推荐）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 7</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">SLDataType array[N];<span class="comment">//指向动态开辟的数组</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//数据个数</span></span><br><span class="line">&#125;SL;</span><br></pre></td></tr></table></figure><p><code>静态顺序表</code>就是创建一个<code>普通的数组</code>，通常数组的<code>长度大小是固定的</code>，所以这种存储方式是不灵活的，静态顺序表的定长数组<code>导致N定大了</code>，空间<code>开多了浪费</code>，<code>开少了不够用</code>，只适用于确定知道需要存多少数据的场景</p><h3 id="动态顺序表"><a href="#动态顺序表" class="headerlink" title="动态顺序表"></a>动态顺序表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CAPACITY 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">SLDataType* a;<span class="comment">//指向动态开辟的数组</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//数据个数</span></span><br><span class="line"><span class="type">int</span> capacity;<span class="comment">//空间容量</span></span><br><span class="line">&#125;SL;</span><br></pre></td></tr></table></figure><p><code>动态顺序表</code>是用的最多的顺序表，符合大多数场景下的使用，可以<code>根据场景的需要试试调整数组的大小</code>，比静态数组更加灵活</p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><h3 id="顺序表打印"><a href="#顺序表打印" class="headerlink" title="顺序表打印"></a>顺序表打印</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPrint</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ps-&gt;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为要访问ps指针，所以基本功能的实现都要用<code>断言来预防非法访问</code>，顺序表的打印和数组的打印基本思路一致，这里不过多赘述</p><h3 id="顺序表初始化"><a href="#顺序表初始化" class="headerlink" title="顺序表初始化"></a>顺序表初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqInit</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line">ps-&gt;a = (SLDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SLDataType) * INIT_CAPACITY);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size = <span class="number">0</span>;</span><br><span class="line">ps-&gt;capacity = INIT_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对顺序表初始化，这里有个头文件中的宏定义<code>#define INIT_CAPACITY 4</code>，目的是为了方便修改初始化时的大小，不然每次修改要改多处，<code>定义之后就只需要修改一个地方即可</code>，刚开始<code>capacity也要给一定的容量</code>，而不是0</p><h3 id="顺序表销毁"><a href="#顺序表销毁" class="headerlink" title="顺序表销毁"></a>顺序表销毁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLDestroy</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;a);</span><br><span class="line">ps-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;size = ps-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一要注意的点就是，<code>释放完动态数组a之后要记得将指针置为空</code>，不然会导致野指针的出现</p><h3 id="顺序表容量检查"><a href="#顺序表容量检查" class="headerlink" title="顺序表容量检查"></a>顺序表容量检查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLCheckCapacity</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;size == ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">SLDataType* tmp = (SLDataType*)<span class="built_in">realloc</span>(ps-&gt;a, <span class="built_in">sizeof</span>(SLDataType) * ps-&gt;capacity * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>size</code>表示的是当前顺序表<code>存储了多少数据</code>，<code>capacity</code>表示的是当前顺序表<code>能够存储多少数据</code>，所以当数据存满了之后就需要进行扩容操作，通常我们<code>每次扩容都只扩容两倍</code>，以免空间的浪费</p><p>🔥<strong>值得注意的是：</strong> realloc开辟的空间大小不是<code>ps-&gt;capacity * 2</code>，而是<code>sizeof(SLDataType) * ps-&gt;capacity * 2</code>，前者是只考虑了扩大数组元素个数，但是<code>没考虑到每个元素的字节大小</code>，这是需要重点注意的</p><h3 id="顺序表尾插"><a href="#顺序表尾插" class="headerlink" title="顺序表尾插"></a>顺序表尾插</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushBack</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line">ps-&gt;a[ps-&gt;size++] = x;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br></pre></td></tr></table></figure><p>尾插就是在顺序表最后面插入数据，先<code>检查容量是否足够插入数据</code>，然后<code>ps-&gt;a[ps-&gt;size++] = x</code>可以拆分为<code>ps-&gt;a[ps-&gt;size] = x</code>和<code>ps-&gt;size++</code>理解，先将下一个数据加入顺序表，然后修改size大小</p><p>尾插只需要把n个数据依次放到末尾，所以<code>时间复杂度为O(n)</code></p><h3 id="顺序表头插"><a href="#顺序表头插" class="headerlink" title="顺序表头插"></a>顺序表头插</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushFront</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line"><span class="type">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[end + <span class="number">1</span>] = ps-&gt;a[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[<span class="number">0</span>] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;<span class="comment">//O(n^2)</span></span><br></pre></td></tr></table></figure><p>还是一样，先<code>检查容量是否足够插入数据</code>，然后用<code>覆盖的方式</code>，将前一个数据覆盖到后一个数据上，即<code>整体数据向右移动</code>，也可以使用mommove函数，最后记得<code>修改size大小</code>，然后在<code>开头插入数据</code></p><p>🔥<strong>值得注意的是：</strong> 头插每次插入n个数据之前都需要挪动数据，因此<code>时间复杂度为O(n²)</code>，所以得出结论<code>尾插的效率是高于头插的</code></p><h3 id="顺序表尾删"><a href="#顺序表尾删" class="headerlink" title="顺序表尾删"></a>顺序表尾删</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopBack</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps-&gt;size&gt; <span class="number">0</span>);</span><br><span class="line">ps-&gt;a[ps-&gt;size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个数据的索引为<code>size-1</code>，所以将该位置的数据置为0即可，但又有人有疑问了，<code>需不需要把删除的空间回收了?</code>答案是不需要也没必要，因为<code>通常空间的回收都是整体回收而不是一部分</code>，而且多出来的空间也有可能被使用</p><p>🔥<strong>值得注意的是：</strong> 要考虑<code>顺序表没有数据的情况</code>，如果没有数据了还删除肯定是会造成访问错误的，所以要加<code>断言assert(ps-&gt;size&gt; 0)</code>，头删也是如此</p><h3 id="顺序表头删"><a href="#顺序表头删" class="headerlink" title="顺序表头删"></a>顺序表头删</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopFront</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps); </span><br><span class="line"><span class="built_in">assert</span>(ps-&gt;size &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> begin = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[begin - <span class="number">1</span>] = ps-&gt;a[begin];</span><br><span class="line">++begin;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先<code>检查容量是否足够插入数据</code>，然后用<code>覆盖的方式</code>，将后一个数据覆盖到前一个数据上，即<code>整体数据向左移动</code>，也可以使用mommove函数，最后记得<code>修改size大小</code></p><h3 id="顺序表在pos位置插入x"><a href="#顺序表在pos位置插入x" class="headerlink" title="顺序表在pos位置插入x"></a>顺序表在pos位置插入x</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLInsert</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= ps-&gt;size &amp;&amp; pos &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line"><span class="type">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= pos)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[end + <span class="number">1</span>] = ps-&gt;a[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[pos] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>在pos位置之后将所有数据向左移</code>，然后在pos位置插入数据，注意要<code>断言pos &lt;= ps-&gt;size &amp;&amp; pos &gt;= 0</code>，避免传入的pos地址是个无效地址</p><h3 id="顺序表在pos位置删除x"><a href="#顺序表在pos位置删除x" class="headerlink" title="顺序表在pos位置删除x"></a>顺序表在pos位置删除x</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLErase</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= ps-&gt;size &amp;&amp; pos &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> begin = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[begin - <span class="number">1</span>] = ps-&gt;a[begin];</span><br><span class="line">++begin;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>变量 begin 从要删除元素的下一个位置开始</code>，使用 while 循环将从 pos + 1 位置开始的元素依次向左移动一个位置，<code>覆盖要删除的元素</code></p><p>🔥<strong>值得注意的是：</strong> 最后一个元素不需要特殊处理。因为顺序表的元素个数是由 size 控制的，当 size 减 1 后，<code>无论原来最后一个元素的值是什么，它都不在有效的元素列表中了</code>，所以不需要对其进行特殊处理，如将其置为某个默认值或进行其他操作</p><h3 id="顺序表查找"><a href="#顺序表查找" class="headerlink" title="顺序表查找"></a>顺序表查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SLFind</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a[i] == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历数组，符合则返回索引值，不符合返回-1</p><h1 id="顺序表的优劣"><a href="#顺序表的优劣" class="headerlink" title="顺序表的优劣"></a>顺序表的优劣</h1><p>🚩1. 中间&#x2F;头部的插入删除，<code>时间复杂度为O(N)</code></p><p>🚩2. 增容需要<code>申请新空间</code>，<code>拷贝数据</code>，释放旧空间，会有不小的消耗</p><p>🚩3. 增容一般是呈2倍的增长，<code>势必会有一定的空间浪费</code>。例如当前容量为100，满了以后增容到200，我们再继续插入了5个数据，后面没有数据插入了，那么就浪费了95个数据空间</p><h1 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h1><blockquote><p>传送门：<a href="https://gitee.com/zhang-zhanhua-000/c_-plus_-plus/tree/177e12c8696a5978626590923471753a9200cbcc/%E9%A1%BA%E5%BA%8F%E8%A1%A8/">Gitee顺序表代码</a></p></blockquote><h2 id="SeqList-h"><a href="#SeqList-h" class="headerlink" title="SeqList.h"></a>SeqList.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态开辟（不推荐）</span></span><br><span class="line"><span class="comment">//#define N 7</span></span><br><span class="line"><span class="comment">//typedef struct SeqList</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//SLDataType array[N];//指向动态开辟的数组</span></span><br><span class="line"><span class="comment">//int size;//数据个数</span></span><br><span class="line"><span class="comment">//&#125;SL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态开辟</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CAPACITY 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">SLDataType* a;<span class="comment">//指向动态开辟的数组</span></span><br><span class="line"><span class="type">int</span> size;<span class="comment">//数据个数</span></span><br><span class="line"><span class="type">int</span> capacity;<span class="comment">//空间容量</span></span><br><span class="line">&#125;SL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqInit</span><span class="params">(SL* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqDestory</span><span class="params">(SL* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLCheckCapacity</span><span class="params">(SL* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushBack</span><span class="params">(SL* ps, SLDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushFront</span><span class="params">(SL* ps, SLDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopBack</span><span class="params">(SL* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopFront</span><span class="params">(SL* ps)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLInsert</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLErase</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SLFind</span><span class="params">(SL* ps, SLDataType x)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SeqList-c"><a href="#SeqList-c" class="headerlink" title="SeqList.c"></a>SeqList.c</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表打印</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPrint</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ps-&gt;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqInit</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line">ps-&gt;a = (SLDataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(SLDataType) * INIT_CAPACITY);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size = <span class="number">0</span>;</span><br><span class="line">ps-&gt;capacity = INIT_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLDestroy</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;a);</span><br><span class="line">ps-&gt;a = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;size = ps-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查空间，如果满了，进行增容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLCheckCapacity</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;size == ps-&gt;capacity)</span><br><span class="line">&#123;</span><br><span class="line">SLDataType* tmp = (SLDataType*)<span class="built_in">realloc</span>(ps-&gt;a, <span class="built_in">sizeof</span>(SLDataType) * ps-&gt;capacity * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;realloc fail&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表尾插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushBack</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line">ps-&gt;a[ps-&gt;size++] = x;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushFront</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line"><span class="type">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[end + <span class="number">1</span>] = ps-&gt;a[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[<span class="number">0</span>] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;<span class="comment">//O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表头删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopFront</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps); </span><br><span class="line"><span class="built_in">assert</span>(ps-&gt;size &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> begin = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[begin - <span class="number">1</span>] = ps-&gt;a[begin];</span><br><span class="line">++begin;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序表尾删</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPopBack</span><span class="params">(SL* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps-&gt;size&gt; <span class="number">0</span>);</span><br><span class="line">ps-&gt;a[ps-&gt;size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表在pos位置插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLInsert</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= ps-&gt;size &amp;&amp; pos &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="built_in">SLCheckCapacity</span>(ps);</span><br><span class="line"><span class="type">int</span> end = ps-&gt;size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[end + <span class="number">1</span>] = ps-&gt;a[end];</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;a[pos] = x;</span><br><span class="line">ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表删除pos位置的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLErase</span><span class="params">(SL* ps, <span class="type">int</span> pos, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="built_in">assert</span>(pos &lt;= ps-&gt;size &amp;&amp; pos &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> begin = pos + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; ps-&gt;size)</span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;a[begin - <span class="number">1</span>] = ps-&gt;a[begin];</span><br><span class="line">++begin;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SLFind</span><span class="params">(SL* ps, SLDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(ps);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ps-&gt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ps-&gt;a[i] == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fd07db43138a4919908769466bb58679.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 顺序表 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【初阶数据结构】时空罗盘妙解：时间复杂度&amp;&amp;空间复杂度</title>
      <link href="/2025/01/15/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/01/15/%E5%88%9D%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;&amp;%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构介绍"><a href="#数据结构介绍" class="headerlink" title="数据结构介绍"></a>数据结构介绍</h1><h2 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h2><blockquote><p><code>数据结构</code>指相互之间存在<code>一种</code>或<code>多种特定关系</code>的<code>数据元素的集合</code>。简单来说，就是<code>组织和存储数据的方式</code>，让数据能被高效地<code>访问</code>、<code>修改</code>、<code>增删</code> ，就好比把杂乱的物品<code>用不同的收纳工具和方法归置整齐</code></p></blockquote><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><blockquote><p><code>算法</code>是指<code>解题方案的准确而完整的描述</code>，是一系列解决问题的清晰指令。它接收特定的输入，经过有限个步骤的处理，产生对应的输出。打个比方，<code>算法</code>就像是<code>一份精准的菜谱</code>，<code>食材</code>是<code>输入</code>，<code>按照菜谱上的步骤烹饪后得出的菜肴就是输出</code></p></blockquote><h2 id="如何学好算法和数据结构？"><a href="#如何学好算法和数据结构？" class="headerlink" title="如何学好算法和数据结构？"></a>如何学好算法和数据结构？</h2><p>博主在学习<code>数据结构</code>的时候也是学的头疼，这是因为数据结构是<code>偏向于底层逻辑</code>的东西，我认为学习数据结构重要的<code>不是学了很多</code>，而是<code>对于每个数据的代码，都知道是为什么</code></p><p>🚩<strong>时常问问自己为什么这里的代码这样写</strong></p><p>🚩<strong>多画图梳理逻辑</strong></p><p>🚩<strong>多写几遍代码</strong></p><p>🚩<strong>和不会的问题死磕到底，钻研不出来就问人</strong></p><h1 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h1><p><strong>如何判断一个算法的好坏</strong>，主要从<code>时间</code>和<code>空间</code>来考量，算法在编写成可执行程序后，运行时<code>需要耗费时间资源和空间(内存)资源</code></p><blockquote><p><strong>时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间</strong>。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度</p></blockquote><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>在计算机科学中，<strong>算法的时间复杂度是一个函数</strong>，它定量描述了该算法的运行时间。<code>一个算法执行所耗费的时间</code>，<code>从理论</code>上说，是<code>不能算出来的</code>，只有你把你的程序放在机器上跑起来，才能知道。但是我们<code>需要每个算法都上机测试吗？</code>是可以都上机测试，但是这很麻烦，所以才有了<code>时间复杂度</code>这个分析方式。一个算法所<code>花费的时间</code>与其中语句的<code>执行次数</code>成<code>正比例</code>，<code>算法中的基本操作的执行次数</code>，为算法的时间复杂度</p></blockquote><p>🚩<strong>举个例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请计算一下Func1中++count语句总共执行了多少次？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func1</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N ; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> M = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (M--)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们要计算的是程序语句执行了多少次，而不是单纯花费的时间</p><blockquote><p>$$<br>        Func1 执行的基本操作次数 ：F(N) &#x3D; N^2 + 2*N + 10<br>   $$</p></blockquote><p>首先是两层循环每次执行N²次，接着一次循环执行2N，最后执行10次</p><h2 id="大O的渐进表示法"><a href="#大O的渐进表示法" class="headerlink" title="大O的渐进表示法"></a>大O的渐进表示法</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0f20143f189c45aaa675b9e356f8456b.png" alt="在这里插入图片描述"><br>🚩<strong>确定基本操作</strong></p><p>算法由一系列操作组成，要先<code>找出其中最核心、执行次数最多</code>，且对整体运行时间起关键影响的基本操作</p><p>• 例如在<code>排序算法</code>里，元素比较、交换的操作；在<code>搜索算法</code>中，是数据元素的查看操作</p><p>• 以简单的<code>线性搜索算法</code>为例，基本操作就是逐个查看数组中的元素，判断是否为目标元素</p><p>🚩<strong>分析操作执行次数</strong></p><p>设<code>输入规模为N</code>，计算基本操作随着N的变化，<code>执行了多少次</code></p><p>还是线性搜索，对于一个<code>长度为n的数组</code></p><p><strong>最坏的情况</strong>：目标元素在数组末尾或者根本不在数组中，此时需要查看<code>N个元素</code></p><p><strong>最好的情况</strong>：目标元素刚好在数组首位，只需查看<code>1个元素</code> </p><p><code>平均下来查看(N+1)/2个元素</code></p><p>🚩<strong>忽略低阶项与常数系数</strong></p><p>根据大 O 记号的规则，<code>只保留最高阶的项</code>，并且<code>省略该项的常数系数</code>。因为当N足够大时，<code>低阶项和常数对整体增长趋势的影响微乎其微</code>。</p><p>在实际中一般情况关注的是<code>算法的最坏运行情况</code>，所以<code>数组中搜索数据时间复杂度为O(N)</code></p><h2 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算Func2的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span> * N ; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> M = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (M--)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数中，基本操作执行了<code>2N+10次</code>，for循环的<code>时间复杂度是O(N)</code>，while循环的<code>时间复杂度是O(1)</code>。在计算总体时间复杂度时，由于 O(N) 的增长速度比 O(1) 快，当 N 趋向于无穷大时，起主导作用的是 O(N) 这一项</p><p>所以，<code>Func2的时间复杂度是O(N)</code></p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算Func3的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; M; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; N ; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数中，基本操作执行了<code>M+N次</code>，两个循环是顺序执行的，总的执行时间是<code>两个循环执行时间之和</code>，由于<code>不知道M和N的大小关系</code>，根据时间复杂度的加法规则，总体时间复杂度为<code>O(M+N)</code></p><p>所以，<code>Func3的时间复杂度是O(M+N)</code></p><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算Func4的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func4</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; ++ k)</span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数中，基本操作执行了<code>10次</code>，由于该循环执行次数不随输入规模N变化，是一个<code>常数级别的操作</code></p><p>所以，<code>Func4的时间复杂度是O(1)</code></p><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算strchr的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">strchr</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * str, <span class="type">int</span> character )</span></span>;</span><br></pre></td></tr></table></figure><p>strchr 函数用于在字符串 str 中查找字符，基本操作执行<code>最好1次</code>，<code>最坏N次</code>，时间复杂度一般看最坏，<code>时间复杂度为O(N)</code></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算BinarySearch的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line"> <span class="comment">// [begin, end]：begin和end是左闭右闭区间，因此有=号</span></span><br><span class="line"><span class="keyword">while</span> (begin &lt;= end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = begin + ((end-begin)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; x)</span><br><span class="line">begin = mid<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)</span><br><span class="line">end = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每经过一轮循环，搜索区间的长度就会减半。设经过k轮循环后，搜索区间缩小到只剩 1 个元素，此时有等式$n*(\frac{1}{2})^k&#x3D;1$，求解k可得$k&#x3D;\log_2^n$。也就是说，在最坏的情况下，最多需要进行$\log_2^n$次比较操作就能确定目标元素是否存在于数组中</p><p><code>所以 BinarySearch 函数的时间复杂度为 O(log n)</code></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算BubbleSort的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[i<span class="number">-1</span>], &amp;a[i]);</span><br><span class="line">exchange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exchange == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况下，也就是数组原本就是有序的，内层循环第一次遍历就不会有任何元素交换，此时 exchange 变量始终为 0，内层循环<code>只完整执行一轮就会因 break 跳出</code>，整体<code>时间复杂度是O(n)</code>，但通常我们讨论的是算法的<code>最坏情况</code>时间复杂度，所以冒泡排序的<code>时间复杂度为O(n²)</code></p><h3 id="递归阶乘"><a href="#递归阶乘" class="headerlink" title="递归阶乘"></a>递归阶乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘递归Fac的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fac</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">0</span> == N)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Fac</span>(N<span class="number">-1</span>)*N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>基本操作递归了N次</code>，所以 Fac 函数的<code>时间复杂度为</code> O(N)</p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算斐波那契递归Fib的时间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fib</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(N &lt; <span class="number">3</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Fib</span>(N<span class="number">-1</span>) + <span class="built_in">Fib</span>(N<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看成一棵树，从渐近分析的角度，忽略常数系数，<code>只关注输入规模 N 增大时执行次数的增长趋势</code>，Fib 函数的<code>时间复杂度</code>为 O($2^N$)</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><blockquote><p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中<strong>临时占用存储空间大小的量度</strong><br>空间复杂度<code>不是程序占用了多少bytes的空间</code>，因为这个也没太大意义，所以<code>空间复杂度算的是变量的个数</code>。空间复杂度计算规则基本跟实践复杂度类似，也使用<strong>大O渐进表示法</strong>。</p></blockquote><p>🔥<strong>值得注意的是：</strong> <code>函数运行时</code>所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在<code>编译期间已经确定好了</code>，因此<code>空间复杂度</code>主要通过函数在运行时候<code>显式申请的额外空间来确定</code></p><h2 id="空间复杂度的计算"><a href="#空间复杂度的计算" class="headerlink" title="空间复杂度的计算"></a>空间复杂度的计算</h2><h3 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算BubbleSort的空间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> end = n; end &gt; <span class="number">0</span>; --end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> exchange = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; end; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i<span class="number">-1</span>] &gt; a[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[i<span class="number">-1</span>], &amp;a[i]);</span><br><span class="line">exchange = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exchange == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了输入的数组 a 外，<code>只使用了有限个额外变量，像 end、exchange 和 i 这些变量</code>，无论输入数组的规模 n 有多大，这些额外变量所占用的空间都是固定的，不会随着 n 的增长而增加</p><p>所以，<code>冒泡排序算法的空间复杂度为O(1)</code></p><h3 id="斐波那契数列-1"><a href="#斐波那契数列-1" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算Fibonacci的空间复杂度？</span></span><br><span class="line"><span class="comment">// 返回斐波那契数列的前n项</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span>* <span class="title">Fibonacci</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> * fibArray = (<span class="type">long</span> <span class="type">long</span> *)<span class="built_in">malloc</span>((n<span class="number">+1</span>) * <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"> fibArray[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"> fibArray[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n ; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">     fibArray[i] = fibArray[i - <span class="number">1</span>] + fibArray [i - <span class="number">2</span>];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> fibArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部使用 malloc <code>分配了一块连续的内存空间</code>，用来存储斐波那契数列的前 n 项，这块内存的大小是 <code>(n + 1) * sizeof(long long)</code></p><p>所以<code>动态开辟了N个空间，空间复杂度为 O(N)</code></p><h3 id="递归阶乘-1"><a href="#递归阶乘-1" class="headerlink" title="递归阶乘"></a>递归阶乘</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算阶乘递归Fac的空间复杂度？</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fac</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Fac</span>(N<span class="number">-1</span>)*N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归调用过程中，每次调用函数 Fac 时，系统会为当前这次调用<code>在栈上分配一定的空间</code>，<code>最深的递归调用层次达到了 N 层</code></p><p>所以，根据空间复杂度的衡量规则，<code>该函数的空间复杂度是O(N)</code></p><h1 id="常见复杂度的对比"><a href="#常见复杂度的对比" class="headerlink" title="常见复杂度的对比"></a>常见复杂度的对比</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/eed0bcc48aef42308623ecab18fe93de.png" alt="在这里插入图片描述"></p><p>一些和时间复杂度有关的练习：<br><a href="https://leetcode-cn.com/problems/missing-number-lcci/">消失的数字OJ</a><br><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组OJ</a></p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/46add82cf68b413c91c27f4dd3f7b887.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 初阶数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 空间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】D&amp;C-Quicksort-Mysteries：分治-快排的算法之迷</title>
      <link href="/2025/01/13/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB-%E5%BF%AB%E6%8E%92%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E8%BF%B7/"/>
      <url>/2025/01/13/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB-%E5%BF%AB%E6%8E%92%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E8%BF%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>🚩<strong>什么是分治-快排？</strong></p><blockquote><p><code>分治</code>是核心思想，即将<code>大问题拆解成形式相同的小问题</code>来处理，从待排序数组里挑出<code>一个元素当作基准</code>，设置<code>两个指针</code>，一个从数组<code>开头</code>，一个从<code>末尾</code>出发，先把一个<code>无序的数组</code>划分成<code>两个子数组</code>，接着分别处理这两个子数组，随着<code>递归深入</code>，子数组越来越小，最终<code>每个子数组只剩 1 个元素时</code>，<code>天然有序</code>，整个大数组也就<code>完成排序</code></p></blockquote><h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/447bc304c0ed4af38a9bf356816644ce.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9c22cac651e6494db7f1de426b83ba7f.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/sort-colors/description/">颜色分类</a></p></blockquote><p><strong>题解:</strong></p><p>对于排序的题目，根据前些的学习我们一般都是想到<code>冒泡排序</code>等基础算法，但是此类算法对于<code>带有重复性的排序</code>很不友好，还是太慢了，因此对于这道题，也是一道经典的荷兰国旗问题，使用类似<code>双指针算法</code>中的<code>移动零</code>那道题的方法，<code>划分区间比较排序</code>，衍生出来了一种<code>三划分排序算法</code>，也叫作<code>快速排序</code></p><p>💻<strong>第一步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/24512693b2e14e189bd85059d0c3de23.png" alt="在这里插入图片描述"></p><p>首先我们这题要排序的是<code>0、1、2三个数字</code>，所以划分为<code>三个区间</code>，分别是<code>小于1的区间</code>，<code>等于1的区间</code>，<code>大于1的区间</code>。<code>left</code>表示标记<code>左区间的指针</code>，<code>i</code>表示<code>扫描区间指针</code>，<code>right</code>表示标记<code>右区间的指针</code></p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/688ed55e706d43a6b163645602e52286.png" alt="在这里插入图片描述"></p><p>前提条件<code>left = -1</code>, <code>right = n</code>，根据<code>i扫描的区间</code>，可以分为<code>三种情况</code>：<code>如果遇到0</code>，要放在<code>左区间</code>，<code>left先++</code>，和i所指的元素互换，然后<code>i++</code>扫描下一个元素；<code>如果遇到1</code>，本来就要放在中间区间，所以<code>不用操作</code>，<code>i++</code>扫描下一个元素；<code>如果遇到2</code>，要放在<code>右区间</code>，<code>right先--</code>，和i所指的元素互换，注意<code>i不能++</code>，因为此时<code>交换过来的元素还没扫描过</code>，要再判断一次。<code>right和i相遇</code>时停止扫描</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">-1</span>, right = n, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++left], nums[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[--right], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f9e82d9b86524537b9e29a573c98db7f.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/90d27152e16d4c848260162d7be0fdfb.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2e9f05e7e1174e618ba929a038acd0f5.png" alt="在这里插入图片描述"></p><p>本题其实和<code>三色划分</code>的道理是相同的，只不过该题才是真正的将<code>快速排序</code>的<code>方法效率最大化</code>，能普及到大部分的题目上，重点是要<code>选取基准元素划分区间</code></p><p>💻<strong>第一步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7d319ab09fc34f12aa3b56fb873028b7.png" alt="在这里插入图片描述"></p><p>根据<code>算法导论的期望</code>严谨证明，发现用<code>随机的方式</code>选取基准元素是最优的算法，因此我们可以使用<code>rand()随机函数</code>，最开始<code>调用qsort</code>时，此时计算<code>随机数的范围就是基于 [l, r] </code>这个初始区间，<code>left作为基准偏移</code>，让随机选取的索引能<code>落在这个完整初始区间内</code></p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a4102d0d152416397a1a531fdd35896.png" alt="在这里插入图片描述"></p><p>既然已经选取完基准元素，那么划分的过程和三色划分是一样的，此时要注意，第一轮划分完后，<code>left在基准元素左边一位</code>，<code>right在基准元素右边一位</code>，此时就完成了两个字区间的划分，但是<code>左右两个区间只是大于或小于</code>，<code>区间内的数据排序还是乱的</code>，所以还要<code>对左右两个区间进行相同的排序</code>，依次往复，<code>每次排序都能确定一个基准元素的位置</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">qsort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">getRandom</span>(nums, l, r);</span><br><span class="line">        <span class="type">int</span> i = l, left = l - <span class="number">1</span>, right = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++left], nums[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[--right], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">qsort</span>(nums, l, left);</span><br><span class="line">        <span class="built_in">qsort</span>(nums, right, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">rand</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[r % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中的第k个最大元素"><a href="#数组中的第k个最大元素" class="headerlink" title="数组中的第k个最大元素"></a>数组中的第k个最大元素</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da26c6686dcd4a93b7d10d27b27bde37.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/25f6313ec73d4a778cbc5b9a7985081e.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第k个最大元素</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ab4828d2bac64362aef32d2a94cbf5aa.png" alt="在这里插入图片描述"></p><p>本题要求找<code>数组中的第k个最大元素</code>，本质是<code>快速排序</code>算法中的<code>快速选择</code>算法，该方法同样适用<code>第k小</code>，<code>前k大</code>，<code>前k小</code></p><p>💻<strong>细节问题：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4bf82fb11e4b481c8fd81e285cc29065.png" alt="在这里插入图片描述"></p><p>快速选择算法和快速排序基本上一样，唯一不同的是要在<code>递归时选择区间</code>，<code>若c&gt;=k</code>，说明<code>第k大落在大于基准元素的这段区间</code>，那么只在这段区间寻找即可；<code>若b+c&gt;=k</code>，<code>说明第k大就在等于基准元素这段区间</code>，即等于基准元素；<code>若前面两种都不成立</code>，那么<code>第k大一定落在比基准元素小的区间</code>，因此在<code>整个区间上找第k大</code>相当于在<code>左区间上找第k-b-c大</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qsort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">getRandom</span>(nums, l, r);</span><br><span class="line">        <span class="type">int</span> left = l - <span class="number">1</span>, right = r + <span class="number">1</span>, i = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++left], nums[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[--right], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> c = r - right + <span class="number">1</span>, b = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qsort</span>(nums, right, r, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c + b &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qsort</span>(nums, l, left, k - b - c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">rand</span>();</span><br><span class="line">        <span class="keyword">return</span> nums[r % (right - left + <span class="number">1</span>) + left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="库存管理Ⅲ"><a href="#库存管理Ⅲ" class="headerlink" title="库存管理Ⅲ"></a>库存管理Ⅲ</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/504aeec55d6942d7a69642d75b5c32b1.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cc485b8504bb4bf6b0dd1534cd65f3bd.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/">库存管理Ⅲ</a></p></blockquote><p><strong>题解:</strong></p><blockquote><p>这题其实也是一样的，要求一个区间内的数，只要<code>求第k个数的位置</code>，然后<code>计算这个区间间的长度</code>就行了</p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inventoryManagement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stock, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">qsort</span>(stock, <span class="number">0</span>, stock.<span class="built_in">size</span>() - <span class="number">1</span>, cnt);</span><br><span class="line">        <span class="keyword">return</span> &#123; stock.<span class="built_in">begin</span>(),stock.<span class="built_in">begin</span>() + cnt &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stock, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> key = <span class="built_in">getRandom</span>(stock, l, r);</span><br><span class="line">        <span class="type">int</span> left = l - <span class="number">1</span>, right = r + <span class="number">1</span>, i = l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stock[i] &lt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(stock[++left], stock[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stock[i] &gt; key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(stock[--right], stock[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a = left - l + <span class="number">1</span>, b = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qsort</span>(stock, l, left, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a + b &gt;= cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">qsort</span>(stock, right, r, cnt - b - a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stock, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stock[<span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/80ed85dbfec14273868870f2376194cf.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Simulation-Phoenix：模拟算法的重生涅槃</title>
      <link href="/2025/01/09/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E7%94%9F%E6%B6%85%E6%A7%83/"/>
      <url>/2025/01/09/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95%E7%9A%84%E9%87%8D%E7%94%9F%E6%B6%85%E6%A7%83/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>🚩<strong>什么是模拟算法？</strong></p><blockquote><p>简单来说就是<code>照葫芦画瓢</code>，题目说啥就照着写代码就行，所以很考察代码能力</p></blockquote><h1 id="替换所有的问号"><a href="#替换所有的问号" class="headerlink" title="替换所有的问号"></a>替换所有的问号</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ae06ac9f36294c6ca0ed05beb3cc52d5.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/df2f84d372634c1d8d4bdbe15ea6f577.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters/description/">替换所有的问号</a></p></blockquote><p><strong>题解:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c9069a5cc69c4be2b637b55c52b8fb26.png" alt="在这里插入图片描述"></p><p>这题很简单，显然是先<code>遍历一遍数组</code>，然后在遍历的时候，如果遇到<code>？</code>就替换为与该位置<code>前后都不相同</code>的数，所以也要对要<code>替换的数遍历一遍</code>，直到发现合适的数</p><p>💻<strong>细节问题：</strong></p><blockquote><p>注意边界情况，<code>没有两个相邻的数</code></p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">modifyString</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ++ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i == <span class="number">0</span> || ch != s[i - <span class="number">1</span>]) &amp;&amp; (i == s.<span class="built_in">size</span>() - <span class="number">1</span> || ch != s[i + <span class="number">1</span>]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        s[i] = ch;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="提莫攻击"><a href="#提莫攻击" class="headerlink" title="提莫攻击"></a>提莫攻击</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/70564d0d49c946f2899df9c23a8b88fb.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/340cc125d4574631a033ef8fd987ec25.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/teemo-attacking/description/">提莫攻击</a></p></blockquote><p><strong>题解:</strong></p><p>做模拟算法题的<code>精髓就是要画图</code>，只有图画明白了，才能找到规律，而不是凭空想象</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/08cf85d9ae794ae494c3835d00a12062.png" alt="在这里插入图片描述"></p><p>所以根据规律发现<code>相邻两数之差</code>是突破点，如果相邻两数之差<code>大于duration</code>，那么<code>不用</code>重置中毒时间；如果相邻两数之差<code>小于duration</code>，那么<code>要</code>重置中毒时间</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPoisonedDuration</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; timeSeries, <span class="type">int</span> duration)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; timeSeries.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = timeSeries[i] - timeSeries[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= duration)</span><br><span class="line">            &#123;</span><br><span class="line">                ret += duration;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret + duration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Z字形变换"><a href="#Z字形变换" class="headerlink" title="Z字形变换"></a>Z字形变换</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8216ef82b0d14b02a264997f4e8eee5e.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5bfd7566f2904b538088e286eda2ace7.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/zigzag-conversion/description/">Z字形变换</a></p></blockquote><p><strong>题解:</strong></p><p>本题的意思是要你根据题目给出的<code>Z字形字符串</code>，将其<code>从上到下</code>，<code>从左至右</code>的方式以一个<code>新字符串</code>的方式返回，显然这是一个<code>找规律性极强</code>的题目，所以<code>画图！画图！画图！</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e056dcd538c6472c9c1d16e0e8b229e8.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>首先我们将<code>每个数的索引按照Z字形填入</code>，我们是从<code>第一行</code>开始录入，所以可以发现<code>第一行</code>和<code>最后一行</code>都是一个<code>等差数列</code>，然后发现规律，<code>公差是0~6之间元素的个数</code>，所以得出<code>d=2n-2</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5f4300eb93cb4d1093cdaa5be887faa5.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><blockquote><p>接下来处理<code>中间的行数</code>，发现如图的<code>1 ~ 7 ~ 13</code>，<code>5 ~ 11 ~ 17</code>也是以<code>6为公差</code>，只不过是<code>两个数两个数的差</code>，所以得出规律<code>（k，d-k）</code></p></blockquote><p>💻<strong>细节问题：</strong></p><blockquote><p>注意for循环的判断条件为<code>i &lt; n || j &lt; k</code>，而<code>不是&amp;&amp;</code>，因为当一个越界之后，另一个可能还没越界判断完</p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> d = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += d)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; numRows - <span class="number">1</span>; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k, j = d - k; i &lt; n || j &lt; k; i += d, j += d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret += s[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret += s[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = numRows - <span class="number">1</span>; i &lt; n; i += d)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="外观序列"><a href="#外观序列" class="headerlink" title="外观序列"></a>外观序列</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/774d94ec8c5d43968323126c769c3822.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/42f8b09f0a6b403caf19884ea5c9ca77.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/count-and-say/description/">外观序列</a></p></blockquote><p><strong>题解:</strong></p><p>其实题目意思就是对<code>上一行的序列进行解释</code>，比如<code>第三行为21</code>，那么<code>第四行</code>的意思就是<code>一个2一个1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/14ab066693164c0fb632876dd66356f7.png" alt="在这里插入图片描述"></p><p>💻<strong>细节问题：</strong></p><p>所以很明显这题要用<code>双指针</code>解决，因为要持续向后查找有几个相同的，直到不同为止</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e29ce9a335c342268ecab691fc49803e.png" alt="在这里插入图片描述"></p><p><code>left</code>和<code>right</code>都从<code>0</code>开始，然后<code>right</code>向后移动，直到该位置和前一个位置不相同，然后记录长度和数字，直接让<code>left=right</code>，开始下一段</p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string ret = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp;</span><br><span class="line">            <span class="type">int</span> len = ret.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; len; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (ret[left] == ret[right])</span><br><span class="line">                &#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp += <span class="built_in">to_string</span>(right - left) + ret[left];</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数青蛙"><a href="#数青蛙" class="headerlink" title="数青蛙"></a>数青蛙</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9b08f94b5aab4d9083de64fee501d9de.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/06dc8c343dec4d52965c2d3d610e3b80.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/minimum-number-of-frogs-croaking/">数青蛙</a></p></blockquote><p><strong>题解:</strong></p><p>要理解本题题意，就是<code>一只青蛙要完整叫完croak</code>，如果一只青蛙没叫完，那么就需要另一只青蛙来发出叫声</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/615edfcb90b7477bb6e45584a7edf427.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4f32036eedbe4c21bfbae2a2f187174d.png" alt="在这里插入图片描述"></p><p>首先，以如图所示为例子，<code>第一个c</code>，计入该<code>位置为1</code>，接下来到<code>r</code>，<code>该位置变为1</code>，<code>上一个位置变为0</code>，可以理解为<code>一个1一直在移动</code>，表示这个叫声遍历到哪里了，<code>直到遍历到k为止</code></p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d9bbddaa1e4949319219768df30d8ee6.png" alt="在这里插入图片描述"></p><p>注意在遍历过程中注意要像图中分类，<code>对于字符c</code>，若<code>k位置不为0</code>，那么表示有青蛙闲置，那么<code>之前叫完的青蛙就可以再次叫</code>；<code>对于其他字符</code>，要找该字符的前一个字符符<code>不符合croak的顺序和字符</code>，<code>若不符合字符</code>，<code>直接返回-1</code></p><p>💻<strong>细节问题：</strong></p><blockquote><p>注意处理完所有字符时，要判断一下<code>是否还有没叫完的叫声</code></p></blockquote><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(string croakOfFrogs)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string t = <span class="string">&quot;croak&quot;</span>;</span><br><span class="line">        <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            index[t[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : croakOfFrogs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash[n - <span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    hash[n - <span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">                hash[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> i = index[ch];</span><br><span class="line">                <span class="keyword">if</span> (hash[i - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash[i - <span class="number">1</span>]--;</span><br><span class="line">                hash[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/02127126db94448eae172ed4ee106b52.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Bit-Samurai：位运算的算法之道</title>
      <link href="/2025/01/06/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93/"/>
      <url>/2025/01/06/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="常见位运算总结"><a href="#常见位运算总结" class="headerlink" title="常见位运算总结"></a>常见位运算总结</h1><h2 id="基础位运算符号"><a href="#基础位运算符号" class="headerlink" title="基础位运算符号"></a>基础位运算符号</h2><p>这六个位运算符是实现位运算算法的重要运算符，在C语言阶段有详细的介绍过</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143237196?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.10——进制转化&amp;&amp;操作符进阶</a></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/94d7391d021e41068731e1f1c16ce9b4.png" alt="在这里插入图片描述"><br>记法如图所示，强调一下<strong>什么是无进位相加？</strong></p><blockquote><p>异或运算的规则决定了它天然契合<code>无进位相加</code>的概念<br>异或运算在比较两个二进制位时，0 ^ 0 &#x3D; 0，0 ^ 1 &#x3D; 1 ，1 ^ 0 &#x3D; 1， 1 ^ 1 &#x3D; 0<br>只是单纯对比两个数在每一位上的值，将<code>不同的视为 1</code>，<code>相同的视为 0</code> ，<code>不涉及向高位进位</code></p></blockquote><h2 id="给一个数-n，确定它的二进制表示中的第-x-位是-0-还是-1"><a href="#给一个数-n，确定它的二进制表示中的第-x-位是-0-还是-1" class="headerlink" title="给一个数 n，确定它的二进制表示中的第 x 位是 0 还是 1"></a>给一个数 n，确定它的二进制表示中的第 x 位是 0 还是 1</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e73375f0b9374b1fa7df66458de8d661.png" alt="在这里插入图片描述"></p><p>约定二进制位<code>从右到左</code>，为<code>最低位</code>到<code>最高位</code>，定义为<code>从0到31</code>，为的就是对应<code>右移x位</code>刚好<code>对应第x位</code>。所以将要比较的数 n 的<code>第x位右移x位</code>，与<code>1</code>按位与<code>&amp;</code>，如果是<code>0</code>，第<code>x</code>位为<code>0</code>；如果是<code>1</code>，第<code>x</code>位是<code>1</code></p><h2 id="将一个数-n-的二进制表示的第-x-位修改成-1"><a href="#将一个数-n-的二进制表示的第-x-位修改成-1" class="headerlink" title="将一个数 n 的二进制表示的第 x 位修改成 1"></a>将一个数 n 的二进制表示的第 x 位修改成 1</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c82be053dfbf48bf8354f4370b968d1e.jpeg" alt="请添加图片描述"></p><p>要修改<code>数n第x位为1</code>就不能破坏原来的数，所以将<code>1移动x位</code>，<code>与1按位或|</code>，只修改了我们想要修改的那一位</p><h2 id="将一个数-n-的二进制表示的第-x-位修改成-0"><a href="#将一个数-n-的二进制表示的第-x-位修改成-0" class="headerlink" title="将一个数 n 的二进制表示的第 x 位修改成 0"></a>将一个数 n 的二进制表示的第 x 位修改成 0</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2cea6964886e4db082a8bb491382f915.jpeg" alt="请添加图片描述"></p><p>要修改<code>数n第x位为0</code>就不能破坏原来的数，所以将<code>1移动x位</code>，<code>取反~为0</code>，<code>与1按位与&amp;</code>，只修改了我们想要修改的那一位</p><h2 id="位图的思想"><a href="#位图的思想" class="headerlink" title="位图的思想"></a>位图的思想</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e4c9c1fd3fa947e298360c1cc394c3f4.png" alt="在这里插入图片描述"></p><p>位图其实和哈希表相似，哈希表是<code>额外开辟一个空间</code>，计算数据出现频次，而位图则是<code>把数据存在数据类型一个个字节里</code>，这就<code>省去了多开一个空间</code>，然后利用上述的方法<code>修改为1或0</code>，统计<code>数是否出现过</code></p><h2 id="提取一个-n-二进制表示中最右侧的-1"><a href="#提取一个-n-二进制表示中最右侧的-1" class="headerlink" title="提取一个 n 二进制表示中最右侧的 1"></a>提取一个 n 二进制表示中最右侧的 1</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/357f21bd54cd4675af9a05c0c972f24a.jpeg" alt="请添加图片描述"></p><p>将<code>数n取反后+1</code>得到<code>相反数-n</code>，然后两数<code>按位与&amp;</code>得到<code>最右侧的1</code>。即<code>最右侧的1及其右边都不变</code>，<code>左边的数都变成0</code></p><h2 id="干掉一个数-n-二进制表示中最右侧的-1"><a href="#干掉一个数-n-二进制表示中最右侧的-1" class="headerlink" title="干掉一个数 n 二进制表示中最右侧的 1"></a>干掉一个数 n 二进制表示中最右侧的 1</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e5c3fd4f36e340758e3e67dfe91f4bad.jpeg" alt="请添加图片描述"></p><p>将<code>数n</code>减1，然后两数<code>按位与&amp;</code>干掉<code>最右侧的1</code>。即<code>最右侧的1及其右边都变成0</code>，<code>左边的数都不变</code></p><h2 id="位运算的优先级"><a href="#位运算的优先级" class="headerlink" title="位运算的优先级"></a>位运算的优先级</h2><blockquote><p>通常优先级为：<code>~</code> &gt; <code>&amp;</code> &gt; <code>^</code> &gt;  <code>|</code><br>但是记起来太麻烦了，干脆<code>直接加括号</code>更好  </p></blockquote><h2 id="异或运算符-的运算律"><a href="#异或运算符-的运算律" class="headerlink" title="异或运算符 ^ 的运算律"></a>异或运算符 ^ 的运算律</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9efd7deed45645c4912c5614117ff12c.png" alt="在这里插入图片描述"></p><p>这是<code>异或运算符^常用的运算律</code>，在题目中经常用</p><h1 id="判定字符是否唯一"><a href="#判定字符是否唯一" class="headerlink" title="判定字符是否唯一"></a>判定字符是否唯一</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/755dca3ddba94811b339309d8e6ea720.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/642406e1ab3344a3a93733ea72e6533e.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/is-unique-lcci/">判定字符是否唯一</a></p></blockquote><p><strong>题解:</strong></p><p>通常<code>统计多数的字母</code>出现次数一般想到的是<code>哈希表</code>，<code>时间空间复杂度都为O(n)</code>，这就有人问了，有没有既简单又强势的方法能够解决？有的兄弟有的，这么强势的方法有九个，都是当前蓝桥杯T0.5的强势方法，因为本题<code>只涉及26个小写英文字母</code>，所以可以用<code>减少开辟空间</code>的<code>位图</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c6c857281ac5439c8549696447accf29.png" alt="在这里插入图片描述"></p><p>如上述介绍位图一样，用<code>1</code>和<code>0</code>表示字母<code>是否出现过</code>，<code>如果为1</code>，就返回<code>false</code>；<code>如果是0</code>，就<code>添加1到指定位数上</code>，遍历完字符串后返回<code>true</code>，</p><p>💻<strong>细节问题:</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6505fd7e8e304a24a5ada71bfd1f098a.png" alt="在这里插入图片描述"></p><p>利用<code>鸽巣原理</code>，如果<code>字符串长度大于26</code>，那么<code>必定有字母是重复的</code>，所以<code>大于26直接返回false</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUnique</span><span class="params">(string astr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (astr.<span class="built_in">size</span>() &gt; <span class="number">26</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> bitMap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : astr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i = ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> ((bitMap &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bitMap |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="丢失的数字"><a href="#丢失的数字" class="headerlink" title="丢失的数字"></a>丢失的数字</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7cdc06ca162943c78d495f998ca38faf.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e7740d3f94a04b8baab24083727b0a1d.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/missing-number/description/">丢失的数字</a></p></blockquote><p><strong>题解:</strong></p><p>该题一共有<code>四种方法</code>解决</p><p>🚩<strong>哈希表</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b95a61f4f84e4c66beaff0a88bf62cc4.png" alt="在这里插入图片描述"></p><p>把<code>0 ~ n</code>中出现的所有数字都放进<code>哈希表</code>里，然后<code>遍历一遍</code>哈希表，如果<code>某一格内对应的0</code>，那么<code>该数就是缺失的数字</code></p><p>🚩<strong>高斯求和</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ef56341a589a4bdeb264da5c1799168a.png" alt="在这里插入图片描述"></p><p>利用简单的<code>求和公式</code>求出<code>0 ~ n</code>所有数的和，然后<code>减去缺失数字的数组</code>，<code>剩下的数</code>就是题意所求</p><p>🚩<strong>二分查找</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d04102c48ea44de389a5198544d3a8e1.png" alt="在这里插入图片描述"></p><p>先对数组进行<code>排序</code>，在<code>连续数组</code>的前提下，缺失数字的位置开始<code>下标与实际值不同</code>，很明显<code>二段性</code>立马就出来了，如果在<code>右区间</code>，那么<code>mid</code>会有<code>等于缺失值的实际位置索引</code>，即<code>right = mid</code>；如果在左区间，<code>mid及其前面的值都不可能是缺失值的实际位置索引</code>，即<code>left = mid + 1</code></p><p>🚩<strong>位运算</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e95da8c658e84d529235d226f14799f5.png" alt="在这里插入图片描述"></p><p>根据异或运算^的运算律，<code>相同的两个数异或会抵消成0</code>，所以显而易见，把<code>缺失数字的数组</code>和<code>完整的数组</code>异或，剩下的就是<code>缺失的数字</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ret ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两整数之和"><a href="#两整数之和" class="headerlink" title="两整数之和"></a>两整数之和</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fa2e622703524f9ca9f994c5317efbe4.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1e9976616f9541ef830cc2a20b853ff7.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/sum-of-two-integers/description/">两整数之和</a></p></blockquote><p><strong>题解:</strong></p><p>很显然本题是一道为了笔试而出题的题，通常是不会要我们这样去计算的，如果是在笔试环节时，可以投机取巧，直接<code>return a+b</code>通过测试用例，一般面试官也不会去看你的代码</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/33ceb3c83fd44d0f9897d71869d5f609.png" alt="在这里插入图片描述"></p><p>言归正传，该题主要使用<code>异或运算+无进位相加</code>解决</p><p>我们知道<code>无进位相加</code>就是<code>只相加不进位</code>，所以我们只要解决了<code>进位问题</code>，那么问题就迎刃而解了，那么进位也只会在<code>两个位都为1</code>的情况下才会<code>进位</code>，观察发现<code>进位的操作就是按位与&amp;</code>，注意要<code>进位的是下一位</code>，所以要把<code>按位与&amp;完的结果右移一位</code>。两个结果不断重复上述操作，直到<code>进位为0</code>，就是<code>相加的最终结果</code></p><p>💻<strong>细节问题:</strong></p><blockquote><p>注意进位的数有可能因为<code>一直右移导致为-1</code>，只要<code>强转为无符号整数</code>就行</p></blockquote><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = a ^ b;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> carry = (<span class="type">unsigned</span> <span class="type">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = x;</span><br><span class="line">            b = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="只出现一次的数字Ⅱ"><a href="#只出现一次的数字Ⅱ" class="headerlink" title="只出现一次的数字Ⅱ"></a>只出现一次的数字Ⅱ</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/450a332ecfe24fb9b983927a2a66b132.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/60884bbfee004059a59d5acfbbfb7af3.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/single-number-ii/description/">只出现一次的数字Ⅱ</a></p></blockquote><p><strong>题解:</strong></p><p>本题的解法是一种通用解法，以后遇到类似的题目思路是一样的，但是前提是要见过这种解法，这种思路十分的巧妙</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/de51dd3cf95e4eefbcdb0626dcf94239.png" alt="该图取自力扣Krahets"></p><p>因为<code>除去单独的数</code>，每个数的一位<code>必定出现三次</code>，也就是<code>三的倍数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/623703dd7be5447dbaf47b445d096c32.png" alt="在这里插入图片描述"></p><p>所以<code>每个数的指定位数之和</code>必定为如图<code>四种情况的一种</code>，对<code>加和总数求余数</code>发现<code>剩下的数</code>就是那个<code>单独的数的指定位数</code>，很好，如此一来就发现了规律，如此循环往复，把<code>每一位存入位图</code>就能求出<code>只出现一次的数</code></p><p>💻<strong>细节问题:</strong></p><blockquote><p>实际上本题还能改成<code>出现n次</code>，只要把<code>求余数时改成除n</code>就行，其余的算法思路是一样的</p></blockquote><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (((x &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum %= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="消失的两个数字"><a href="#消失的两个数字" class="headerlink" title="消失的两个数字"></a>消失的两个数字</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/caf606579de346f1af09a7cf262619b1.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7aac60a6cff4474b9f0cf300135e42c3.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/missing-two-lcci/description/">消失的两个数字</a></p></blockquote><p><strong>题解:</strong></p><p>本题是丢失的数字的延伸扩展，难度可以说是上升不少，博主自己也想了好久才大彻大悟，但是掌握了这题以后无论是丢失了几个数字都可以用相同的思路来做</p><p>💻<strong>第一步：</strong></p><p>显而易见，首先利用异或的特性把<code>nums</code>和完整数组异或，得到缺失的两个数的异或结果，即<code>a ^ b</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5afc371d35454ec884a57222aea4c669.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>接下来是最关键的一步，我们要知道除了<code>a</code>、<code>b</code>以外的数在异或时是偶数个，所以能够相互抵消，已知<code>a ^ b = 1</code>，所以两个数异或后为<code>1</code>的那一位，表示在这一位上两个数必然不同，一个数为<code>1</code>，另一个数为<code>0</code>。那么我们就可以根据这个差异，异或后为<code>1</code>有很多位，我们选取最右侧的<code>1</code>来分组方便计算</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d704e7f0fb834569800ae1d9c7edc927.jpeg" alt="请添加图片描述"></p><p>基于此，我们把最右侧的<code>1</code>这一位定为<code>diff</code>，先把<code>nums</code>进行分类，如果<code>nums</code>在<code>diff</code>位是<code>1</code>，那么就和<code>a</code>异或^ ；如果<code>nums</code>在<code>diff</code>位是<code>0</code>，那么就和<code>b</code>异或^。那么我们现在就是把有差异的那一位和<code>nums</code>异或并分类了，所以我们还要和一个完整的数组分类异或，抵消掉别的数，因为相同异或为<code>0</code>，不同异或为<code>1</code>，由于前面的分类，除了丢失的数，其他的数都抵消了，丢失的数也在异或的过程中把剩余位数补上了</p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">missingTwo</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ret ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>() + <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((ret &gt;&gt; diff) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((x &gt;&gt; diff) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b ^= x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a ^= x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>() + <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; diff) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                a ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123; a,b &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/20ccf8898c1c44e4b5d5065269db4cc3.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Binary-Blade：二分查找的算法刃（下）</title>
      <link href="/2025/01/03/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/01/03/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="山脉数组的峰顶索引"><a href="#山脉数组的峰顶索引" class="headerlink" title="山脉数组的峰顶索引"></a>山脉数组的峰顶索引</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f4dc01aeff39479d9620feba0762e0a5.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9fbb4e3ce4144b8c9aca7b1b10bf2670.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/">山脉数组的峰顶索引</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>首先<code>确定二段性</code>，把顶峰放到<code>左区间</code>还是<code>右区间</code>取决于你自己，会根据取法不同而导致代码不同，但是都能<code>求出顶峰索引</code>，这里我们<code>放到左区间</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/813ee80250894ed3800632b7c4708938.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>按照我们的划分方式，要确保左边区间不会越过分界，右边区间同理，就要用<code>mid</code>和<code>mid-1</code>这种划分方式。如果在<code>左区间</code>，那么<code>mid</code>会有<code>等于峰顶索引</code>，即<code>left = mid</code>；如果在<code>右区间</code>，<code>mid及其后面的值都不可能是峰顶索引</code>，即<code>right = mid - 1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/49f9ad6e2a204816945b1e3818eff451.png" alt="在这里插入图片描述"></p><p>💻<strong>细节问题:</strong></p><blockquote><p>对于二分查找进阶模版，如果在if语句的函数体里有减法操作时，那么计算mid的公式就要+1</p></blockquote><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/32082df94c994738aada1834409984bc.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/689aa16e63ef4a37be648c8eb78a178d.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>首先<code>确定二段性</code>，可以分为在<code>上坡</code>或者<code>下坡</code>，其实这道题和<code>山脉数组的峰顶索引</code>是一样的，这里我们顶峰放在右区间里</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/12e82951a3c04eed8a0fbde00efeb276.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>按照我们的划分方式，要确保右边区间不会越过分界，左边区间同理，就要用<code>mid</code>和<code>mid+1</code>这种划分方式。如果在<code>右区间</code>，那么<code>mid</code>会有<code>等于峰顶索引</code>，即<code>right = mid</code>；如果在<code>左区间</code>，<code>mid及其前面的值都不可能是峰顶索引</code>，即<code>left = mid + 1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b551f505572b4a9686b5c74f0b31f173.png" alt="在这里插入图片描述"><br>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5f061bbffe924a5b814cc2721c47f52f.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/23d815f1c92640438c1f5fddc74be5b9.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>根据画图，似乎不太好确认二段性，但我们可以发现以<code>D点为分界点</code>，<code>左区间的数（A到B）都大于D</code>，<code>右区间的数（C到D）都小于D</code>，那么由此就能确定二段性，不断向中寻找<code>最小的数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/46d52de3444a423b82ec07eafaf9b4b8.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>如果在<code>右区间</code>，那么<code>mid</code>会有<code>等于最小值</code>，即<code>right = mid</code>；如果在左区间，<code>mid及其前面的值都不可能是最小值</code>，即<code>left = mid + 1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45bc108ddc39488598d0060db52582f1.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x = nums[right];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; x)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-点名"><a href="#4-点名" class="headerlink" title="4.点名"></a>4.点名</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c2b174be3c5644f18d1077bcaa094b50.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e8e1b1801e5149459ed3238042c91132.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/">点名</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>在<code>连续数组</code>的前提下，缺失数字的位置开始<code>下标与实际值不同</code>，很明显<code>二段性</code>立马就出来了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/517322574f904e1e940e689429fdb39b.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>如果在<code>右区间</code>，那么<code>mid</code>会有<code>等于缺失值的实际位置索引</code>，即<code>right = mid</code>；如果在左区间，<code>mid及其前面的值都不可能是缺失值的实际位置索引</code>，即<code>left = mid + 1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a82ace049ba84ab4b2d266bfef92409a.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeAttendance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; records)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = records.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (records[mid] == mid)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> records[left] == left ? left + <span class="number">1</span> : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a9dfedbb829647fcac0758e9fac41c5c.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Binary-Blade：二分查找的算法刃（上）</title>
      <link href="/2025/01/01/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%83%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/01/01/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%83%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析s"><a href="#概念解析s" class="headerlink" title="概念解析s"></a>概念解析s</h1><p>🚩<strong>什么是二分查找算法？</strong></p><p>每次<code>比较中间元素</code>，通过判断中间元素与目标元素的<code>大小关系</code>，将搜索<code>区间缩小一半</code>，持续这个过程，直至<code>找到目标元素</code>或者确定<code>目标元素不存在</code></p><h1 id="二分查找的简单模版"><a href="#二分查找的简单模版" class="headerlink" title="二分查找的简单模版"></a>二分查找的简单模版</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/014c949fec7e4f678a411c6efb3c25f6.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5439e23d8e4049ec8d7c9fc44ee140f4.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/binary-search/description/">二分查找</a></p></blockquote><p><strong>题解:</strong></p><p>在一个<code>无论是有序还是无序</code>的数列里，一般最先想到的就是<code>暴力解法遍历一遍</code>，然后符合条件则成立，这种方法固然是好用，但是一般在搜索数据的过程中，<code>数据量庞大</code>，<code>O(n)</code>的<code>时间复杂度还是太大了</code>，那么这时候就要使用时间复杂度为<code>O(log n)</code>的<code>二分查找</code></p><p>💻<strong>第一步：</strong></p><p><code>二分查找</code>说的就是<code>折中查找</code>，那么二段性就是重要的第一步，找出<code>左右区间不同的地方</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cfc76be7d9284b34a752b2b771ec076b.png" alt="在这里插入图片描述"></p><p>比如这题就是 <code>target</code> 的<code>左区间小于</code>它，<code>右区间大于</code>它，根据这个特性不断调整<code>left</code>和<code>right</code>的位置，接下来看一下具体实现</p><p>💻<strong>第二步：</strong></p><p>不断循环算出mid的值，<code>与target作比较</code>，如果<code>大于target</code>，说明<code>mid所指位置及后面的数</code>都不是符合<code>target</code>的数，<code>right = mid - 1</code>；如果<code>小于target</code>，说明<code>mid所指位置及前面的数</code>都不是符合<code>target</code>的数，<code> left = mid + 1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fae4ee945a214fd8a30422e7929feaf7.png" alt="在这里插入图片描述"></p><p>💻<strong>细节问题：</strong></p><p>🚩<strong>循环条件</strong></p><p>循环条件为 <code>left&lt;=right</code> ，因为当 <code>left</code> 变得比 <code>right</code> 大时，查找区间自然就不存在了；如果只是 <code>left &lt; right</code>，会<code>遗漏掉最后一个元素</code>。例如，在数组<code>只有一个元素</code>时，初始<code>left = 0</code>，<code>right = 0</code>， 若条件是 <code>left &lt; right</code>，循环压根不会进入，直接<code>判定未找到</code>，但实际上这个唯一元素还没检查，使用 <code>left &lt;= right</code> 就能<code>保证这种单元素数组也能被正确查找</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/16e0ae6c63604b2185c1ca494ee505ca.png" alt="在这里插入图片描述"></p><p>🚩<strong>时间复杂度</strong></p><p>不断将<code>区间折中</code>，最终折中为区间<code>长度为1</code>即找到指定元素，即 n &#x2F; $2^x$ &#x3D; 1，解得 x &#x3D; $\log_n$</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e7e41e09b7db4b58bab7c4b1d13616b9.png" alt="在这里插入图片描述"></p><p>假设要查找<code>2³²个数中的一个数</code>，暴力解法就是<code>有多少数就找多少次</code>，而二分查找是<code>指数关系</code>，只需要找32次，明显<code>效率高了不止一点</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分查找的进阶模版"><a href="#二分查找的进阶模版" class="headerlink" title="二分查找的进阶模版"></a>二分查找的进阶模版</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b4ec87b348b4456ea353795df0dd473e.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a171f0cbed414761af94bc9bfb5d9c71.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">二分查找的进阶模版</a></p></blockquote><p><strong>题解:</strong></p><p>题目中的<code>非递减</code>的意思就是数据要么<code>递增</code>要么<code>不变</code></p><p>💻<strong>第一步：</strong></p><p>如果用简单的二分查找方法必然是不行的，因为<code>不知道找到的数是否为端点值</code>，因此在此基础上衍生出<code>查找左右端点</code>的进阶二分查找</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/852a2f1196b54355b9c22e034c07ba5a.png" alt="在这里插入图片描述"></p><p>先找<code>左端点</code>，主要的思路还是一样，找出<code>二段性</code>，那么<code>为什么是像如图分类呢？</code>我们要找的是<code>左端点等于target</code>的情况，那么应该在<code>左端点和前一个数之间划分</code>，那么在<code>右区间寻找</code>的时候就会有<code>等于target</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fcbc15f15c80409e8e8b19fd52f31007.jpeg" alt="请添加图片描述"></p><p>在<code>左区间</code>寻找，<code>mid所指位置及前面的数</code>都不是符合<code>target</code>的数，即使指向<code>左端点前一个数</code>，也是要<code>越过该数</code>，<code>指向左端点</code>，即<code>left = mid + 1</code>；在<code>右区间</code>寻找，<code>mid所指的位置可能是左端点值</code>，所以<code>不能越过左端点</code>，即<code>right = mid</code></p><p>💻<strong>第二步：</strong></p><p>接着寻找<code>右端点</code>也是同理</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9526fa0a07b748dcb4cf1aeb22561d18.png" alt="在这里插入图片描述"></p><p>我们要找的是<code>右端点等于target</code>的情况，那么应该在<code>右端点和后一个数之间划分</code>，那么在<code>左区间寻找</code>的时候就会有<code>等于target</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/16c0d1476f754ec688c7d5af02e04e58.png" alt="在这里插入图片描述"></p><p>在<code>右区间</code>寻找，<code>mid所指位置及后面的数</code>都不是符合<code>target</code>的数，即使指向<code>右端点后一个数</code>，也是要<code>越过该数</code>，<code>指向右端点</code>，即<code>right = mid - 1</code>；在<code>左区间</code>寻找，<code>mid所指的位置可能是右端点值</code>，所以<code>不能越过右端点</code>，即<code>left = mid</code></p><p>💻<strong>细节问题：</strong></p><p>🚩<strong>循环条件</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e4fed4ef21024ac483aebd2f92964ee5.png" alt="在这里插入图片描述"></p><p>无论是找<code>左端点</code>还是<code>右端点</code>，有<code>right = mid</code>和<code>left = mid</code>，通过举例会发现，当<code>left</code>和<code>right</code>汇合到一个数时，因为这两种情况会<code>一直停在那儿不动</code>，会<code>死循环</code></p><p>🚩<strong>求mid操作</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9c0a2ca578384032a4cf51ab0c113d3f.jpeg" alt="请添加图片描述"></p><p>求<code>mid</code>的公式<code>是否加1</code>其实是对<code>偶数个数字</code>的<code>简单模版</code>时候是<code>没区别的</code>，无非是<code>先求右边</code>还是<code>先求左边</code>的区别。但是在如图<code>进阶二分模版极端条件</code>下，求<code>左端点</code>，只有<code>两个数</code>时，如果用<code>加1的公式</code>的话，<code>mid</code>会指向<code>右边</code>，由于<code>right = mid</code>，<code>right</code>就会一直不动<code>死循环</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/565ddf7257a447e3966013cc97b569a4.jpeg" alt="请添加图片描述"></p><p><code>右端点</code>也是同理，在如图<code>进阶二分模版极端条件</code>下，求<code>右端点</code>，只有<code>两个数</code>时，如果用<code>不加1的公式</code>的话，<code>mid</code>会指向<code>左边</code>，由于<code>left = mid</code>，<code>right</code>就会一直不动<code>死循环</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] != target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret = &#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            begin = left;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = right;</span><br><span class="line">        <span class="keyword">return</span> ret = &#123; begin,end &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a>x的平方根</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ea963df0d6c04ac78653171c671387c0.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/359388d23ceb4c7ea2958204655116e9.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/sqrtx/description/">x的平方根</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong></p><p>学习完模版后二分基本上都很简单，一般都是用进阶模版，<code>确定二段性</code>很重要</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/36fa3c94a53d476a971bf4d98c2c0cd8.png" alt="在这里插入图片描述"></p><p>由于求平方根是<code>向下取整</code>，所以把<code>等于的情况划分到左区间</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * mid &lt;= x)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/17cdc35982e542dc912bec595176d8a6.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/10b1a9d1260e4cfdb154a6f434525457.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/473c6015db06469595c9e6ceaa877fd9.png" alt="在这里插入图片描述"></p><p>由于是在<code>target大一位的数插入</code>，所以<code>把等于的情况划分到右区间</code></p><p>💻<strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>🌸 愿新年如初春的花开般灿烂，芬芳四溢，盈满心间；<br>✨ 告别2024年的些许遗憾，迎接2025年的满怀希望；<br>🌟 愿你在新的一年里，心怀星光，步履坚定；<br>🎉 愿每一份努力都有收获，每一个梦想都能成真；<br>❤️ 愿日子如诗，岁月如歌，温柔且浪漫；<br>🌿 每一步都走得从容，每一天都活得明媚；<br>🎀 愿你在新岁中，遇见更闪亮的自己；<br>2025，期待你的美好与光芒！<br>各位2025新年快乐！</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/acbd6728e05546e8bd5957c7ae0ea9c6.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Sliding-Chakra：滑动窗口的算法流（下）</title>
      <link href="/2024/12/30/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/12/30/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="水果成篮"><a href="#水果成篮" class="headerlink" title="水果成篮"></a>水果成篮</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4210cfbee6c94798b14dfcf025463302.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6072a57d4ad34836b1cdca63e58c5262.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/fruit-into-baskets/description/">水果成篮</a></p></blockquote><p><strong>题解:</strong></p><p>首先解读题意，简单来说就是找到一个区间，其中的<code>果树种类用数字表示</code>，种类<code>不超过两种</code>，题目默认是能找到<code>至少两种水果</code>，所以求在此前提下<code>能找到的最长区间是多少？</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/004cb6193d0e40c3952ad05973e65aa1.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>或许该题可以使用暴力解法解决，但明显<code>时间复杂度太高</code>无法通过示例<br>因此根据前些题目的经验，由于是<code>找区间</code>，而且要<code>统计种类数量</code>，<code>滑动窗口＋哈希表</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1617dd5e418d40dcb0dd31e270112d7d.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>具体的<code>窗口滑动</code>如图所示</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/eba21f8cd16442f491aecb410eba46b0.png" alt="在这里插入图片描述"></p><p>先让<code>第一个数据录入</code>，即<code>进窗口</code>，<code>判断不断循环</code>，然后<code>right</code>依次<code>向后移</code>并不断<code>往哈希表录入每个位置种类</code>和<code>更新数据</code>，直到<code>哈希表内的键值对大于2</code>，即<code>种类大于2</code>；此时<code>left减去第一个数据</code>，即<code>出窗口</code>，<code>判断不断循环</code>，然后不断<code>向后移</code>直到<code>哈希表里的一个种类数据变为0</code>，对其进行<code>erase操作减少一个种类</code>，再次<code>开始更新数据</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>, n = fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[fruits[right]]++;</span><br><span class="line">            <span class="keyword">while</span> (hash.<span class="built_in">size</span>() &gt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hash[fruits[left]]--;</span><br><span class="line">                <span class="keyword">if</span> (hash[fruits[left]] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    hash.<span class="built_in">erase</span>(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b3ea90342f724f23a11b762e04f83123.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0c7e4f75a5d2460f94501d40f7728c19.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/">找到字符串中所有字母异位词</a></p></blockquote><p><strong>题解:</strong></p><p>首先我们要知道<code>什么是异位词？</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c3b1997ef0374626a0ac28ef56397c05.png" alt="在这里插入图片描述"></p><p>本题第一难为解读题意，通常读不懂题目时要多结合示例分析，结合<code>示例1</code>和<code>示例2</code>，把<code>p这个字符串</code>放在<code>s这个字符串</code>里比对，<code>不考虑p的顺序</code>，找到<code>所有异位词</code>，返回其<code>起始下标</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/de94ae1d2a1d4261af11a761469d67e6.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>先思考如何在代码运行过程中<code>判断其是否为异位词</code>，只判断个数显然是不行的，既要<code>种类相同</code>，又要<code>出现的个数相同</code>，因为哈希表会减慢运行，这里也只有26种字母，所以我们可以给<code>需要找到的字符串创建模拟哈希表hash1</code>，<code>被寻找的字符串创建模拟哈希表hash2</code>，<code>对比两个哈希表的种类及数量</code>就能准确得出是否为异位词</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/49a4fdf58ba64f8c82f56c36635fd9a2.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>具体实现的流程图如图所示，与前些写的题有些许不同</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8143f5b6ee5240d79f24bf1025f21988.png" alt="在这里插入图片描述"></p><p>先让<code>第一个数据录入</code>，即<code>进窗口</code>，<code>判断不断循环</code>，然后<code>right</code>依次<code>向后移</code>并不断<code>往哈希表中录入</code>，直到<code>left和right之间的长度大于字符串p</code>；此时<code>left减去第一个数据</code>，即<code>出窗口</code>，<code>判断不断循环</code>，然后<code>向后移1位</code>使<code>长度继续维持为字符串p</code>，<code>check</code>然后如果<code>符合要求则更新结果</code>。然后right向前一位，判断，left向前一位，判断更新结果，以此循环</p><p>💻<strong>细节问题</strong></p><p>这里重点在于如何更新结果，一般的思路是<code>遍历hash1和hash2</code>，并<code>对比两个数组</code>，显然此方法是冗余复杂的，接下来将介绍一种方法，通常想不到，因此很有学习价值</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c09a59d695804c3eb408e4de06e5b497.png" alt="在这里插入图片描述"></p><p>先统计字符串p中的字符种类及数量，<code>count</code>表示<code>s</code>中<code>left</code>和<code>right</code>之间的种类数量，在<code>right</code>移动过程中，字符串<code>s</code>的起始种类数量都为<code>0</code>，然后当字符串<code>s</code>的种类数量小于等于字符串<code>p</code>的种类数量时，说明该位置增加的是有效字符，<code>count++</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c1f34835271e43d1a44f7908ce0741e6.png" alt="在这里插入图片描述"></p><p>还是滑动窗口的起始操作，如图当<code>right</code>到<code>e</code>时，明显超出了字符串<code>p</code>的大小，<code>left</code>应该在<code>c</code>，移动<code>left</code>到<code>b</code>，然后当字符串<code>s</code>的种类数量小于等于字符串<code>p</code>的种类数量时，说明该位置减少的是有效字符，<code>count--</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9e5b86342c2b4a149615e6ff0aab0cab.jpeg" alt="请添加图片描述"></p><p>最后当两个模拟哈希表中的<code>种类数量相等</code>，即<code>count == m</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : p)</span><br><span class="line">        &#123;</span><br><span class="line">            hash1[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">26</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            hash2[s[right] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (hash2[s[right] - <span class="string">&#x27;a&#x27;</span>] &lt;= hash1[s[right] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hash2[s[left] - <span class="string">&#x27;a&#x27;</span>] &lt;= hash1[s[left] - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                hash2[s[left] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == m)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="串联所有单词的子串"><a href="#串联所有单词的子串" class="headerlink" title="串联所有单词的子串"></a>串联所有单词的子串</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1fe9df0b5bf8454ea70c159fad8831d9.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/89c578abe1c743f19c6c0225d2d502e2.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/">串联所有单词的子串</a></p></blockquote><p><strong>题解:</strong></p><p>本题的题意也有些难以理解，但是结合<code>找到字符串中所有字母异位词</code>这题的铺垫，使得这题也不是无从下手</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/40cecb36947642d096ceb76f8abfa377.png" alt="在这里插入图片描述"></p><p>如图所示，把这些<code>字符串看成一个个的字符</code>，是不是就和之前那题是一样的？</p><p>💻<strong>细节问题</strong></p><p><strong>w每个字符串的长度多长，那么left，right就有几种起始情况</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/888276378e014196bc81ae45f11536c6.png" alt="在这里插入图片描述"></p><p><strong>当right移动到最后不足字符串w的长度时，会发生越界，所以要写为right + len &lt;&#x3D; n</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8f39eeb4faba4cec8845eca71cf74cc7.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; hash1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : words)</span><br><span class="line">        &#123;</span><br><span class="line">            hash1[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="type">int</span> len = words[<span class="number">0</span>].<span class="built_in">size</span>(), m = words.<span class="built_in">size</span>(), n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; hash2;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> left = i, right = i, count = <span class="number">0</span>; right + len &lt;= n; right += len)</span><br><span class="line">            &#123;</span><br><span class="line">                string in = s.<span class="built_in">substr</span>(right, len);</span><br><span class="line">                hash2[in]++;</span><br><span class="line">                <span class="keyword">if</span> (hash<span class="number">1.</span><span class="built_in">count</span>(in) &amp;&amp; hash2[in] &lt;= hash1[in])</span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; len * m)</span><br><span class="line">                &#123;</span><br><span class="line">                    string out = s.<span class="built_in">substr</span>(left, len);</span><br><span class="line">                    <span class="keyword">if</span> (hash<span class="number">1.</span><span class="built_in">count</span>(out) &amp;&amp; hash2[out] &lt;= hash1[out])</span><br><span class="line">                    &#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    hash2[out]--;</span><br><span class="line">                    left += len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == m)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fb2797b76e48495a8532a144529a4d06.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/20a0a5374eaf465fa10e478d1e2eee73.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/minimum-window-substring/description/">最小覆盖子串</a></p></blockquote><p><strong>题解:</strong></p><p>本题题意为在<code>字符串s里找到一个含有t的字符串区间</code>，只要该区间内<code>符合t的种类数量</code>即可，无论其他的字符有多少个</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2d69e0343da84f0892fed79f76a7bca6.png" alt="在这里插入图片描述"></p><p>💻<strong>细节问题</strong></p><p>所以本题虽说是困难难度，但是依据前几题的思路铺垫，这道题也能说不在话下了，依旧是<code>模拟哈希表+滑动窗口</code>（因为哈希表太占空间了，影响效率）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83da54151dc24b158c7b953668466313.png" alt="在这里插入图片描述"></p><p><strong>注意</strong>当是当<code>hash2中的种类数量</code>和<code>hash1中的种类数量</code>一样时才<code>count++</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash1[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> kinds = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash1[ch]++ == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                kinds++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hash2[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), minlen = INT_MAX, begin = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, count = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (++hash2[s[right]] == hash1[s[right]])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == kinds)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minlen)</span><br><span class="line">                &#123;</span><br><span class="line">                    minlen = right - left + <span class="number">1</span>;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hash2[s[left]]-- == hash1[s[left]])</span><br><span class="line">                &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin, minlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/41a28939bde74ae9be20ef119e964009.png" alt="在这里插入图片描述"></p><p>也是第一次用时击败100%，比官方还优秀的解法😎</p><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/22b8b7683af04e9e865207223f2bd705.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Sliding-Chakra：滑动窗口的算法流（上）</title>
      <link href="/2024/12/27/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/12/27/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E7%AE%97%E6%B3%95%E6%B5%81%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>🚩<strong>什么是滑动窗口算法？</strong></p><p>把一个<code>较长的序列</code>（比如<code>数组</code>、<code>字符串</code>等），划分成一个个<code>固定长度或者动态长度的 “子序列”</code>，这个<code>子序列就被称作窗口</code> 。好比通过一个固定大小的窗框在一幅长画卷上逐步移动，每次窗框圈定的部分就是一个窗口内容，窗口会按照<code>特定的规则在序列上 “滑动”</code>，常见的是每次移动一个元素的位置，<code>新元素进入窗口</code>，同时<code>最靠前的旧元素移出窗口</code>，借此不断更新窗口内的数据集合</p><h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/de3632557e964afa95637b9eddc8cb4f.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/04819835b8144143a34bae9a196ee45b.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>以示例1为例子，如果使用<code>暴力枚举</code>，那么<code>从 2 开始一直向后扩展区间找子集</code>，然后再从开始以此往复，所有的子数组和都枚举一遍显然<code>十分冗余</code>，<code>时间复杂度为O(n²)</code><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/987bdad84d5e4e74beeecb4c86871222.png" alt="在这里插入图片描述"></p><p>说明我们要<code>减少不必要的子数组</code>来优化，如果使用<code>双指针</code>那样<code>异侧指针</code>的话，从两侧缩小来找子集会<code>漏掉一些情况</code>，所以可以考虑<code>同侧指针结合单调性</code>来解决问题</p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/82c0e56678744db09baea757f27dbbd9.png" alt="在这里插入图片描述"></p><p>还是 <code>left</code> 和 <code>right</code> ，都从<code>索引为 0 开始</code>，<code>right</code> 一直<code>向右移动</code>直到该区间的<code>和大于 target 停止</code>，然后 <code>left</code> 一直<code>向右移动</code>寻找<code>是否还有能满足大于 target 的区间</code>，直到<code>小于等于 target 为止</code>，以此往复就能<code>找到所有有效的区间</code>，更新结果的位置是不确定的，要根据题意来</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5c4b9e46b7e94c1fb066b519a542d342.png" alt="在这里插入图片描述"></p><p>具体流程大致如图，<code>元素进入区间</code>，<code>循环判断</code>，<code>元素出区间</code></p><p>💻<strong>细节问题</strong></p><p>代码用了两层循环似乎是<code>O(n²)</code>，但实际上<code>right</code>和<code>left</code>分别<code>往后遍历数组</code>的<code>时间复杂度</code>为<code>O(n+n) = O(2n) = O(n)</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), sum = <span class="number">0</span>, len = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                len = <span class="built_in">min</span>(len, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == INT_MAX ? <span class="number">0</span> : len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="无重复字符的最长数组"><a href="#无重复字符的最长数组" class="headerlink" title="无重复字符的最长数组"></a>无重复字符的最长数组</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/41ac55bfbc784017b7fdc02bd53060d2.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/efafce1f42d94e94b7047d5f5bc3cd24.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长数组</a></p></blockquote><p><strong>题解:</strong></p><p>本题的大意为找到<code>一段子区间每个字符都只出现一次</code>，没有重复</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3ff22061ff74469eb412ee54202c678d.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>遇到这种<code>求子区间</code>优先思考用<code>滑动窗口</code>来解决，因为本题需要<code>统计每个数出现的次数</code>，判断其是否重复，索性可以<code>利用哈希表解决重复类的问题</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3a62e2eab86f4734a9124f2d36d4e27d.png" alt="在这里插入图片描述"><br>💻<strong>第二步：</strong></p><p>通常<code>滑动窗口</code>的格式是<code>很固定的</code>，只有<code>更新数据</code>的地方需要<code>灵活变动</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/84d84ae1689f45688159bb775dc2f487.png" alt="在这里插入图片描述"></p><p>先让<code>第一个数据录入</code>，即<code>进窗口</code>，<code>判断不断循环</code>，然后<code>right</code>依次<code>向后移</code>并不断<code>往哈希表录入每个位置字符</code>和<code>更新结果</code>，直到<code>哈希表内某个字符的数据为2</code>；此时<code>left减去第一个数据</code>，即<code>出窗口</code>，<code>判断不断循环</code>，然后不断<code>向后移</code>直到<code>数据为2的字符数据变为1</code>，再次<code>开始更新数据</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">200</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[right]]++;</span><br><span class="line">            <span class="keyword">while</span> (hash[s[right]] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hash[s[left++]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最大连续1的个数"><a href="#最大连续1的个数" class="headerlink" title="最大连续1的个数"></a>最大连续1的个数</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/260cb9728b0948a7a00d4d01cd3fd010.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/632816f4924d4bd5b75becc702dfc3e6.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/description/">最大连续1的个数</a></p></blockquote><p><strong>题解:</strong></p><p>本题题意为在选取的某个子区间里能够<code>反转0为1</code>，只能<code>反转k个</code>，在此前提下找到<code>最长的连续为1的子数组</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a9bbc53f6464f12865b0940d9fabad1.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>求子区间依然是以<code>滑动窗口算法</code>为主，不过我们要<code>统计0出现的次数</code>，但并不像<code>无重复字符的最长数组</code>那题一样需要使用<code>哈希表</code>来处理次数，毕竟这里<code>只有两个数</code>，显得有点太麻烦了，只用在<code>right向右移动</code>时遇到0时创建一个<code>计数器++</code>就行了</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dae547d5743b4ca3b62cfc1cca1181d9.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong></p><p>主要的<code>出入窗口</code>流程如图所示</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fd7847a38cfa482ca06d28a551996604.png" alt="在这里插入图片描述"></p><p>先让<code>第一个数据录入</code>，即<code>进窗口</code>，<code>判断不断循环</code>，然后<code>right</code>依次<code>向后移</code>并不断<code>往计数器录入0</code>和<code>更新结果</code>，直到<code>计数器0的数据大于k</code>；此时<code>left减去第一个数据</code>，即<code>出窗口</code>，<code>判断不断循环</code>，然后不断<code>向后移</code>直到<code>0的出现次数小于等于k</code>，再次<code>开始更新数据</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret, zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (zero &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left++] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    zero--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="将x减到0的最小操作数"><a href="#将x减到0的最小操作数" class="headerlink" title="将x减到0的最小操作数"></a>将x减到0的最小操作数</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cad6e67afad047fab69002c4a5bc3096.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/edd3c8dce2954f7a8e0163efeb620803.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/">将x减到0的最小操作数</a></p></blockquote><p><strong>题解:</strong></p><p>本题的题意相对来说有点<code>难以理解</code>，但结合示例之后就能明白。就是每次从<code>最左边</code>或者<code>最右边</code>选取数字，让<code>x依次减去这几个数</code>，求<code>减到0最少需要几个数</code>，若<code>没有能减到零</code>，就<code>返回-1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ec3455ceb7e44003a9a215751f1b6309.png" alt="在这里插入图片描述"></p><p>💻<strong>第一步：</strong></p><p>显然该题如果<code>左边拿一点数</code>，<code>右边拿一点数</code>，显然是<code>很难考虑到所有的情况的</code>，那么我们在写算法题的时候，通常正面遇到难以解决的问题时，可以考虑反面，即<code>正难则反</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9b355094d923410b95cd3a1bbfcf645c.png" alt="在这里插入图片描述"></p><p><code>a、b区间</code>表示在<code>获取数过程中所得到的数</code>，那么<code>sum表示整个数组的和</code>，减去<code>a+b=x</code>就是<code>剩下的一段连续区间</code>，显然根据<code>a、b选择的数不同</code>，<code>sum-x</code>的区间长度位置也会<code>不同</code>，潜移默化中又回到了<code>滑动窗口</code>的问题上</p><p>💻<strong>第二步：</strong></p><p>因此我们只需要找到一段<code>连续区间sum1</code>符合<code>sum1=target=sum-x</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/622aea8719d24374b3c981e74f6f8662.png" alt="在这里插入图片描述"></p><p>先统计<code>整个数组的和</code>，让<code>第一个数据录入</code>，即<code>进窗口</code>，<code>判断不断循环</code>，然后<code>right</code>依次<code>向后移</code>并不断<code>往sum1录入数据</code>，符合要求则<code>更新结果</code>，直到<code>sum1大于target=sum-x</code>；此时<code>left减去第一个数据</code>，即<code>出窗口</code>，<code>判断不断循环</code>，然后不断<code>向后移</code>直到<code>sum1小于target</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> target = sum - x;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum1 = <span class="number">0</span>; right &lt; n; ++right)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1 += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (tmp &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum1 -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum1 == target)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">-1</span> ? ret : n - ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2bfff2a774ad48efbebc3584dd88ea8f.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Pointer-Slice：双指针的算法切片（下）</title>
      <link href="/2024/12/25/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%87%E7%89%87%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/12/25/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%87%E7%89%87%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="有效三角形的个数"><a href="#有效三角形的个数" class="headerlink" title="有效三角形的个数"></a>有效三角形的个数</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f9aafd0d1b9f4826aa80667e30f056da.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/035c2e8beddd4438a770d8a5ad5f056d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://leetcode.cn/problems/valid-triangle-number/description/">有效三角形的个数</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>一般针对<code>三元的变量</code>，优先想到的是<code>三层 for 循环暴力枚举</code>所有的组合，此时的<code>时间复杂度为O(n³)</code>，明显是超时了。争取<code>遍历一遍</code>就能找出所有组合，那么就要<code>减少无效的枚举</code></p><p>根据数学知识可知，假设三角形<code>最大边为c</code>，那么<code>其余两边a、b之和大于c</code>，就能<code>确定一个三角形</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/137f964295fa4b9c9d85beebeeef6b14.png" alt="在这里插入图片描述"></p><p>为了<code>减少无效的枚举</code>，通常需要利用<code>数列的单调性</code>，就用<code>sort函数迭代器</code>对数组<code>升序排序</code></p><p>💻<strong>第二步：</strong></p><p>由于是三元，且依据数学知识，我们<code>先固定其中一个数(从最大的开始)</code>，<code>剩下两个数就可以利用双指针求组合</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b91430bf6c204fa78de963dc514345de.png" alt="在这里插入图片描述"></p><p>假设<code>两数之和大于c</code>，那么可以<code>减小和</code>，寻找<code>是否还有符合要求</code>的组合，即<code>right--</code>；假设<code>两数之和小于c</code>，那么需要<code>增加和</code>，寻找<code>有符合要求</code>的组合，即<code>left++</code>；<code>和相等时</code>就返回组合，然后继续<code>left++</code>，因为<code>减小和仍然有可能找到符合大于c的组合</code>。<code>每判断一次和</code>，就要<code>执行一次移动</code>，当<code>left &gt;= right</code>就停止，此时最大数的组合情况<code>已经全部找完</code>，接下来<code>c就减小一位</code>，继续循环上述操作</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/61f6719ddbf1434ea22703a2af53b42a.png" alt="在这里插入图片描述"></p><p>注意<code>c最多减小到索引为2的位置</code>，保证<code>依然为三元组合</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ret += right - left;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="查找总价格为目标值的两个商品"><a href="#查找总价格为目标值的两个商品" class="headerlink" title="查找总价格为目标值的两个商品"></a>查找总价格为目标值的两个商品</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5ee443e83d144a06a0476aad48543c54.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ee6def8087ad40549b0f8de4cb620afb.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/">查找总价格为目标值的两个商品</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong> </p><p>该题是上一题的简化版，显然是使用<code>双指针找符合的组数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/12e86f681df84579b43337dde7404ded.png" alt="在这里插入图片描述"></p><p>唯一不同的是<code>上题要寻找所有符合的情况</code>，该题<code>找到一个符合的即可</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = price.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = price[left] + price[right];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123; price[left], price[right] &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123; <span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a3a280c044174145b1e7355756427fc8.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1048b61240f346ffa5b83a293f746e1d.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/3sum/description/">三数之和</a></p></blockquote><p><strong>题解:</strong></p><p>本题也是<code>三元组合</code>的问题，与<code>有效三角形的个数</code>那题的思路也是一样的，做到<code>不漏情况</code>是很简单的，但是本题要求<code>不重复</code>，那么这是本题要处理的难点，<code>细节问题特别多</code></p><p>💻<strong>第一步：</strong> <code>不漏</code></p><p>或许可以通过暴力枚举+set容器去重，但仍然涉及时间复杂度高的问题，所以还是排序+双指针的方法减小时间复杂度</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/33059de97f514a1d82b900020b682d2c.png" alt="在这里插入图片描述"></p><p>💻<strong>第二步：</strong> <code>不重</code></p><p>🚩<strong>left、right不重复</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2b1bf95944c0484d9411a4144fcdb8ae.png" alt="在这里插入图片描述"><br>🚩<strong>固定的数不重复</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1efe29dfb2f9499da7f505b8c0e5d71e.png" alt="在这里插入图片描述"><br>因为此时<code>其余两个数都是不变的</code>，移动到下一个一样的数<code>重复了之前的情况</code>，为了<code>减少不必要的枚举</code>，当遇到重复的数时两种情况<code>都需要跳过</code></p><p>💻<strong>细节问题：</strong> </p><p>注意<code>不要</code>在处理重复数的情况时<code>移动越界</code>，要考虑<code>如果都是重复数的情况</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7ca0ead30be04fb582302ef6d0121f62.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>, target = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(&#123; nums[i],nums[left],nums[right] &#125;);</span><br><span class="line">                    left++, right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c47d5ad672ea477da9dc1e3f28fce35a.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2e0966703e8d4e0d804d6e36522af0d9.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/4sum/description/">四数之和</a></p></blockquote><p>💻<strong>细节问题：</strong> </p><p><code>四数之和</code>和<code>三数之和</code>是一个思路，只不过是<code>要固定两个数</code>，<code>套用两层 for 循环处理两次边界问题</code>，注意双指针运算过程中，<code>比较的值可能会太大</code>，所以要用 <code>long long</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/236b6ef306ac4af5a93e4007afdda9ab.png" alt="a"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left = j + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> aim = (<span class="type">long</span> <span class="type">long</span>)target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> sum = nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; aim)</span><br><span class="line">                    &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; aim)</span><br><span class="line">                    &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ret.<span class="built_in">push_back</span>(&#123; nums[i],nums[j],nums[left],nums[right] &#125;);</span><br><span class="line">                        left++,right--;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>寒冷的冬夜里，祝大家圣诞节快乐，平安喜乐！🎅❄️🎄</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3ee8bdfdb0254da48f3eee807db0df80.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Pointer-Slice：双指针的算法切片（上）</title>
      <link href="/2024/12/23/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%87%E7%89%87%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/12/23/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%87%E7%89%87%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>🚩<strong>什么是双指针算法？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d21853c22c4248bbb4f9aff16d2459e5.png" alt="在这里插入图片描述"></p><p><code>双指针算法</code>使用<code>两个索引</code>来遍历数据结构，可以根据问题的要求，以不同的方式移动，如<code>同向移动</code>、<code>相向移动</code>或<code>快慢不同的速度移动</code></p><h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e0ba78ff1aee477da0e39dd99d6fb805.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f41804f016a544ecbfb112643ccf248e.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b18e0f9b0fda4aca903b6b80de3939ef.png" alt="在这里插入图片描述"></p><p>有两个索引 <code>dest</code> 和 <code>cur</code><br>• <code>dest</code> 表示在<code>已处理的区间内</code>，<code>非零元素的最后一个位置</code><br>• <code>cur</code> 表示<code>从左往右扫描数组遍历数组</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0c58d0324554fa0996ca8c554511bba.png" alt="在这里插入图片描述"></p><p>把整个区间划分为<code>三个部分</code>，从前往后分别是<code>非零区间</code>，<code>0区间</code>，<code>待处理区间</code></p><p>💻<strong>第二步：</strong></p><p>根据题意我们要把 <code>0 都移到数组末尾</code>，所以是要<code>注意是移动</code>，而<code>不是覆盖</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ef5983fbf68847228b1fef5a6fe33e1b.png" alt="在这里插入图片描述"></p><p>刚开始<code>dest 指向 -1</code>的位置，表示<code>非0区间还不存在</code>，然后 <code>cur 先向右</code>移动，<code>如果为 0</code> 就继续向后；<code>如果为非0</code>，就让 <code>dest 向后一位</code>，然后<code>和 cur 交换</code>（因为 cur 遇到 0 不会改变其位置，所以在 dest 后面<code>必定至少有一个 0 </code>，通过交换就能一直把 0 向后移）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ffb6782e4df44d01aaf1eeda74d4d5b4.png" alt="在这里插入图片描述"></p><p>总结后的代码如下：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45e1759c27ff4ff1810793a51cafb73b.png" alt="在这里插入图片描述"></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cur = <span class="number">0</span>, dest = <span class="number">-1</span>; cur &lt; nums.<span class="built_in">size</span>(); ++cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[++dest], nums[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="复写零"><a href="#复写零" class="headerlink" title="复写零"></a>复写零</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/60365b4fe1d544b79bca3e597745d347.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7dc8065d1585499ca2779aa35df8dcea.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/duplicate-zeros/description/">复写零</a></p></blockquote><p><strong>题解:</strong></p><p>双指针问题在解题<code>通常要求就地操作</code>，但往往很难立马想出来，所以可以<code>先进行异地操作拓展思路</code>。本题的<code>异地操作</code>就是<code>额外创建一个数组</code>，然后据题意操作即可，很简单就不过多讲解</p><p>💻<strong>第一步：</strong> 先找到最后一个复写的数</p><p><code>从前往后复写</code>会发现会出现<code>前一个数把后一个数覆盖</code>的情况，所以我们尝试<code>从后往前复写</code>，发现是可行的，所以唯一的要点就是<code>找到那个开始复写的数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2d65e64180b74cb1a24a29946ff748dc.jpeg" alt="请添加图片描述"></p><p>如图为<code>示例 1 </code>找到<code>最后一个复写的数</code>，那么是<code>如何找到的呢？</code>没有过多的技巧，就是要通过<code>不断地画图尝试找到规律</code></p><p>• <code>cur</code> 表示<code>最后一个复写的数</code><br>• <code>dest</code> 表示<code>是否为最后一个数</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f657d7160f8f47dca3a0ff12e8a0d65a.png" alt="在这里插入图片描述"></p><p><code>如果 cur 的值为 0</code> ，<code>dest</code> 向后<code>两位</code>；<code>如果 cur 的值为非 0</code> ，<code>dest</code> 向后<code>一位</code>。那么就延伸出另一个问题，<code>要是 dest 越界了怎么办？</code></p><p>💻<strong>第二步：</strong> 处理越界情况并从后往前复写</p><p>如果越界了，那么 <code>dest 所在的位置一般默认为 0</code> ，但是在平台上越界就会报错，且这种情况的时候<code>一定是因为 cur 最后一个复写数为 0 导致的</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7bc7c05e2d4342c6bbbeba0f1fe0c04a.jpeg" alt="请添加图片描述"></p><p>所以我们只需将 <code>n-1 处赋为 0</code>，<code>dest -= 2</code>，<code>cur--</code> 即可回到最后一个复写数为非0的情况</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8f046479c5ff4889b4be504c69552aeb.png" alt="在这里插入图片描述"></p><p>接着再完成<code>从后向前复写</code>的操作即可</p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">duplicateZeros</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.先找到最后一个数</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, dest = <span class="number">-1</span>, n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                dest++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dest += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dest &gt;= n - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.处理边界情况</span></span><br><span class="line">        <span class="keyword">if</span> (dest == n)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            dest -= <span class="number">2</span>;</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.从后向前完成复写操作</span></span><br><span class="line">        <span class="keyword">while</span> (cur &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                arr[dest--] = arr[cur--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                arr[dest--] = <span class="number">0</span>;</span><br><span class="line">                arr[dest--] = <span class="number">0</span>;</span><br><span class="line">                cur--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/02745269c708491093a119544bf40f91.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f001a748cace43edb750d14e3f01b9db.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://leetcode.cn/problems/happy-number/description/">快乐数</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>解读题意：</strong> </p><p>据题意<code>快乐数的判断</code>分为<code>两种情况</code></p><p><strong>是快乐数 ，以 1 循环</strong>（以示例 1 为例）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8474eb1dabef4275aeab489153c5be4f.png" alt="在这里插入图片描述"></p><p><strong>不是快乐数，自循环</strong>（以示例 2 为例）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f7cce275f1fc49ea86bbe09fdcbee7a5.png" alt="在这里插入图片描述"></p><p>看到这里显然需要我们<code>判断是否成环</code>，在链表部分了解过，应该使用<code>快慢指针</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/985398b1b13a4004bf58c62256355327.png" alt="在这里插入图片描述"></p><p>💻<strong>细节问题：</strong> </p><p>如果题目没有说明只有两种情况，那是不是可能会出现第三种情况：<code>线性死循环</code><br>答案是<code>不会的</code>，以下是一些简单的证明，不影响本题，作了解即可</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0c75d65f0c614acabba750a98ff00518.png" alt="在这里插入图片描述"></p><p>我们假设 <code>n</code> 可取的最大值为 <code>9 × 10⁹</code> ，那么经过<code>快乐数操作的数为 810</code>，接下来无论进行多少次操作都是在<code>[1，810]里的数</code>，那么在经过<code>大于 810 次操作</code>后，根据<code>鸽巢原理</code>，必然会有重复，也就是成环，所以<code>第三种情况不可能存在</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bitSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = n % <span class="number">10</span>;</span><br><span class="line">            sum += t * t;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = n, fast = <span class="built_in">bitSum</span>(n);</span><br><span class="line">        <span class="keyword">while</span> (slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = <span class="built_in">bitSum</span>(slow);</span><br><span class="line">            fast = <span class="built_in">bitSum</span>(<span class="built_in">bitSum</span>(fast));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5c860255f3e34f8aa6c1c61eff490770.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7a121e16f75245e29f009dc9648e9a5d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://leetcode.cn/problems/container-with-most-water/description/">盛最多水的容器</a></p></blockquote><p><strong>题解:</strong></p><p>看到这道题一般最先想到的是用<code>两层for循环暴力枚举</code>，但在本题会超时，<code>时间复杂度为 O(n²)</code>，所以本题的思路是尽量把<code>时间复杂度降为O(n)</code></p><p>尝试<code>减少枚举数量</code>来降低时间复杂度，本题求的是体积，所以我们可以在<code>标记开头和结尾的下标为 left 和 right</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/234be19466a54be5b3a9e6e90b72a7f7.png" alt="在这里插入图片描述"></p><p><code>v 为体积</code>，<code>h 为高度</code>，<code>w 为宽度</code>，可以发现在取两边的数计算宽度时，先固定一个不动，然后另一个逐渐缩小宽度，<code>小的那个数缩小之后算出来的体积永远是小的</code>，所以我们可以通过<code>不断舍掉小的那个数</code>缩小宽度，然后得出<code>多个体积数</code>，<code>找出里面最大的那个</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0d9fb18c4d944c8d92673803ba4b1b0e.png" alt="在这里插入图片描述"></p><p>通过这种方式<code>减少了不必要的枚举</code>，降低了时间复杂度，<code>只需遍历一遍数组</code>就能得出最大的体积</p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = (right - left) * <span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">            ret = <span class="built_in">max</span>(v, ret);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ce77fc6170fc4c3a98e80b57d6c14957.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Prefix-Kage：前缀和的算法影（下）</title>
      <link href="/2024/12/20/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%E5%BD%B1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/12/20/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%E5%BD%B1%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和-后缀和"><a href="#前缀和-后缀和" class="headerlink" title="前缀和+后缀和"></a>前缀和+后缀和</h1><h2 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a>寻找数组的中心下标</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7834cfaac3bb463bb30919c276584bc7.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f79e6e1d8a4343619bc9238835299af4.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/find-pivot-index/description/">寻找数组的中心下标</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong> 要计算<code>前后和相等</code>的数的下标（不包括该数），显然要计算前后缀和</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b63bad3ab2564b079d41d0e111fcd7c4.png" alt="在这里插入图片描述"></p><p>假设<code>符合题意的数的下标为 i </code>，那么其前后数的下标就很容易推导出来了。我们小学的时候就学过函数，那么前后和是不是也可以<code>用一个函数表示</code>，只要有符合的 i 直接代入即可</p><blockquote><p>f：前缀和数组 → <code>f[i]</code> 表示：<code>[0，i-1]</code> 区间所有元素的和<br>g：后缀和数组 → <code>g[i]</code> 表示：<code>[i+1，n-1]</code> 区间所有元素的和</p></blockquote><p>所以根据<code>一维前缀和模版的公式</code>可得 <code>f[i] = f[i - 1] + nums[i - 1]</code> 、<code>g[i] = g[i + 1] + nums[i + 1]</code>，注意这个后缀和是<code>从后往前加</code>推导的</p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1dffb86a5c574f6b9515372b604936d8.png" alt="在这里插入图片描述"></p><p>接着<code>遍历题目的数组</code>，枚举出符合 <code>f[i] == g[i]</code> 情况的下标就行了</p><p>💻<strong>细节问题：</strong></p><p>根据我们写的两个公式，当 <code>i = 0</code> ，<code>i = n - 1</code> 时，即<code>第一个数和最后一个数的下标</code>，发现会出现 <code>f[-1]</code> 、<code>g[n]</code> 的情况，也就是<code>数组越界</code>，所以<code>前缀和</code>要<code>从第二个数开始</code>，<code>后缀和</code>要<code>从倒数第二个数开始</code>，那么<code>第一个数和最后一个数会不会访问不到？</code>答案是<code>不会的</code>，<code>后缀和</code>会访问到<code>第一个数</code>，<code>前缀和</code>会访问到<code>最后一个数</code>。因此当 <code>i</code> 在<code>最左侧</code>或<code>最右侧</code>时，令 <code>f[0]</code> 为 <code>0</code> ，<code>g[n-1]</code> 为 <code>0</code> 来处理这种特殊情况</p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span>, <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i] = g[i + <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] == g[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果数组<code>存在</code>中心下标，返回 <code>1</code> ；<code>不存在</code>中心下标，返回 <code>-1</code></p><h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/30d05b290bff454990546a4f4aaeba1d.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6f90d337848f458ca0b90827f6a8493b.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/product-of-array-except-self/description/">除自身以外数组的乘积</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong><br>本题和<code>寻找数组的中心下标</code>思路基本一致，因为要相乘，所以令 <code>f[0] = 1</code>，<code>g[n-1] = 1</code>，要<code>额外创建一个数组</code>存放各个位置下乘积的结果</p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.读取数据</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span>, <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//2.预处理前缀积和后缀积</span></span><br><span class="line">        f[<span class="number">0</span>] = g[n - <span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//细节</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i] = g[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.使用</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i] = f[i] * g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和+哈希表"></a>前缀和+哈希表</h1><h2 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a>和为k的子数组</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/07f52db2b5e84bdfb82ec204c9f996fb.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cd57bf8ed64d4454b34637f00b9d2087.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为k的子数组</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>第一步：</strong></p><p>根据题意要求<code>和为k的子数组</code>，那么假设在某个<code>下标为 i 处</code>有符合题意的<code>子数组</code>，<code>前缀和</code>为 <code>sum</code> 表示</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/85aa479d551e4a588168008d557c548f.png" alt="在这里插入图片描述"><br>那么就有 <code>sum[i] - sum[j] = k</code> ，<code>移项</code>可得 <code>sum[i]  - k = sum[j]</code> ，所以要求<code>和为 k 的子数组</code>等同于在<code>不断往前求前缀和 sum[i] 的过程中</code>，计算 <code>sum[i]  - k</code> 能否找到<code>符合题意的 sum[j] </code></p><p>💻<strong>第二步：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a9a1bbdd2fd4c11ae878bd5bd4f2e52.png" alt="在这里插入图片描述"></p><p>因为前缀和<code>可能存在重复的情况</code>，我们又需要计算<code>前缀和其对饮出现的次数</code>，进而我们可以想到<code>哈希表</code>来处理这种情况</p><p>💻<strong>细节问题：</strong></p><p>🚩<strong>前缀和加入哈希表的时机？</strong></p><blockquote><p>在不断往前求<code>前缀和 sum[i]</code> 的过程中，i 是不断变化的，我们是要找在 <code>[0，i-1] 区间</code>内，<code>有多少个前缀和等于 sum[i]  - k</code> ，我们关心的是 <code>sum[i]-k 是否在之前出现过</code>，<code>以及出现的次数</code>，这样就能知道有多少个子数组的和为 k </p></blockquote><p>• 如果一次性把每个位置的前缀和都放入哈希表，会导致一些问题。例如，当<code>有一个数组nums = [1,2,3]，k = 3</code></p><p>• 假设我们在遍历过程中，不加判断地每次都放入哈希表。当<code>第一次计算到前缀和为3（1 + 2）</code>时放入哈希表，然后继续遍历到3这个元素时，<code>前缀和变成了6</code>，如果此时又放入哈希表，就会<code>覆盖之前前缀和为3的记录</code></p><p>• 但是，<code>从1开始到2的子数组和为3</code>，从3本身这个元素也构成和为3的子数组，这两个情况是不同的，<code>如果错误地覆盖了之前的记录，就无法正确统计出和为k的子数组数量</code></p><p>🚩<strong>不用真的创建一个前缀和数组</strong></p><blockquote><p>用一个<code>变量sum</code>来标记前一个位置的前缀和即可</p></blockquote><p>🚩<strong>如果整个前缀和等于k呢？</strong></p><blockquote><p>那么就每次遍历开始前特殊的令 <code>hash[0] = 1</code></p></blockquote><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(sum - k))</span><br><span class="line">            &#123;</span><br><span class="line">                ret += hash[sum - k];</span><br><span class="line">            &#125;</span><br><span class="line">            hash[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="和可被k整除的子数组"><a href="#和可被k整除的子数组" class="headerlink" title="和可被k整除的子数组"></a>和可被k整除的子数组</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c4f40e3bb88146f881d46e921c4439a7.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/17f5a35128c54cdc90e6a091ce675139.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/">和可被k整除的子数组</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong></p><p>本题基本上与<code>和为k的子数组</code>思路一致</p><p><strong>补充两个知识点：</strong></p><ol><li><strong>同余定理</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/39fc78c78c06445a872e1bd03834c8ac.png" alt="在这里插入图片描述"></li><li><strong>负数结果修正成正数</strong></li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/57f994f778f8464c920cdb7023b8dbfa.png" alt="在这里插入图片描述"></p><p>因为<code>数组里可能会存在负数</code>，而<code>数组下标没有负数</code>，所以需要修正</p><hr><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc83fc8b4f3a421d97c84ac23ddd811c.png" alt="在这里插入图片描述"></p><p>所以根据<code>同余定理</code>，这里本质上就是在求在<code>[0，i-1]区间</code>内，<code>有多少个前缀和的余数等于 sum % k</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span> % k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="type">int</span> r = (sum % k + k) % k;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(r))</span><br><span class="line">            &#123;</span><br><span class="line">                ret += hash[r];</span><br><span class="line">            &#125;</span><br><span class="line">            hash[r]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a>连续数组</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ae103691abe46a1b0f7976f611c9e3d.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1a7aa2735d424ef1837de48048a208b0.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/contiguous-array/">连续数组</a></p></blockquote><p><strong>题解:</strong><br>💻<strong>细节问题：</strong></p><p>该题的思路也是<code>前缀和+哈希表</code>，要求<code>和为有相同数量的 0 和 1</code>，不妨令<code>所有的 0 为 -1</code>，也就把题目转化为 <code>sum[i] - sum[j] = 0</code>，即 <code>sum[i] = sum[j]</code>，求在<code>遍历前缀和的过程中能不能找到前面的一个前缀和与其相等</code>，注意 <code>hash[0] = -1</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0226a2b7eebf4b96a250ccae9edd3ab2.png" alt="在这里插入图片描述"></p><p><strong>如果在后面又求到一个符合</strong><code>sum[i] = sum[j]</code><strong>的怎么办？</strong></p><blockquote><p>本题求的是<code>最长连续子数组</code>，所以<code>两个是同种情况</code>，无需考虑覆不覆盖的问题，无论<code>哪个都可以</code></p></blockquote><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i] == <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (hash.<span class="built_in">count</span>(sum))</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i - hash[sum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hash[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二维前缀和拓展"><a href="#二维前缀和拓展" class="headerlink" title="二维前缀和拓展"></a>二维前缀和拓展</h1><h2 id="矩阵区域和"><a href="#矩阵区域和" class="headerlink" title="矩阵区域和"></a>矩阵区域和</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bba938783cef46a0a44599236a5702f8.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c0862fdce35443a580c4257569e148ba.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://leetcode.cn/problems/matrix-block-sum/description/">矩阵区域和</a></p></blockquote><p>💻<strong>解读题意：</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c53888747d5c4408836ad867691300e5.png" alt="在这里插入图片描述"><br>这题单看题目或许有点难理解，以<code>示例 1 为例</code>，每个方格里的数对应的求和矩阵，为<code>该方格周围延伸 k 长度所围成的数字加和（若超出范围外，则数组外的不算）</code>。比如 <code>2</code> 的<code>矩阵求和</code>为 <code>1 + 2 + 3 + 4 + 5 + 6 = 21</code>，<code>5</code> 的<code>矩阵求和</code>为 <code>1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45</code>，求和<code>包括原本的数</code></p><p>💻<strong>第一步：</strong></p><p> 本题是<code>二维前缀和模版的延伸</code>，所以要用到上一篇的<code>两个公式</code></p><blockquote><p><strong>传送门：</strong><a href="https://blog.csdn.net/Zero_VPN/article/details/144523054?spm=1001.2014.3001.5502">【模版】前缀和（二维）</a></p></blockquote><p>根据题意我们可以<code>延伸该方格周围 k 长度</code>，若<code>超出范围</code>，则让他<code>回到边界上</code>，使用 <code>max</code> 和 <code>min</code> 就能解决<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8b2cc73a8b82486fbb99f94d6eecd27c.png" alt="在这里插入图片描述"><br>💻<strong>第二步：</strong></p><p>这也是最重要的一步，因为 <code>dp 的下标</code>是从 <code>1</code> 开始读入数据，<code>mat 和 ans 的下标</code>是从 <code>0</code> 开始读入数据的， 为了能使用<code>同一个公式表示来计算</code>，就需要进行<code>函数映射</code>的操作</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/61d917576a304bf7816613e6ad2d9998.png" alt="在这里插入图片描述"><br><code>映射关系如图所示</code></p><p>💻<strong>代码实现:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrixBlockSum</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> k) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x1 = <span class="built_in">max</span>(<span class="number">0</span>, i - k) + <span class="number">1</span>, y1 = <span class="built_in">max</span>(<span class="number">0</span>, j - k) + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> x2 = <span class="built_in">min</span>(m - <span class="number">1</span>, i + k) + <span class="number">1</span>, y2 = <span class="built_in">min</span>(n - <span class="number">1</span>, j + k) + <span class="number">1</span>;</span><br><span class="line">                ans[i][j] = dp[x2][y2] - dp[x1 - <span class="number">1</span>][y2] - dp[x2][y1 - <span class="number">1</span>] + dp[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>以上就是所有精选的前缀和算法题解析，多写几遍代码，不要死套模版，灵活理解应用能够更好地掌握前缀和算法，整理不易，如有出错希望能够私信博主指出错误！😎</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4cbf9ce3829c44bcbb0b783acdca342d.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++天使的灵动心跳代码：类和对象（下）</title>
      <link href="/2024/12/15/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/12/15/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数补充"><a href="#构造函数补充" class="headerlink" title="构造函数补充"></a>构造函数补充</h1><h2 id="构造函数赋值"><a href="#构造函数赋值" class="headerlink" title="构造函数赋值"></a>构造函数赋值</h2><p>一般把成员变量放在私有，通常只是<code>声明</code>或<code>给了缺省值</code>，所以要给他们<code>定义</code></p><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><p>直接给个直观的例子，之前也使用过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _year;</span><br><span class="line"> <span class="type">int</span> _month;</span><br><span class="line"> <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然上述构造函数调用之后，对象中<code>已经有了一个初始值</code>，但是<code>不能将其称为对对象中成员变量的初始化</code>，构造函数体中的语句<code>只能将其称为赋初值</code>，而<code>不能称作初始化</code>。因为初始化只能<code>初始化一次</code>，而构造函数体内<code>可以多次赋值</code></p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>什么是初始化列表？</strong></p><blockquote><p>以<code>一个冒号开始</code>，接着是一个<code>以逗号分隔</code>的数据成员列表，每个”成员变量”后面跟一个放在括号中的<code>初始值或表达式</code></p></blockquote><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line"> : _year(year)</span><br><span class="line"> , _month(month)</span><br><span class="line"> , _day(day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _year;</span><br><span class="line"> <span class="type">int</span> _month;</span><br><span class="line"> <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按照代码中<code>初始化列表里的顺序</code>，依次将传入构造函数的参数 <code>year</code> 初始化给 <code>_year</code>，<code>month</code> 初始化给 <code>_month</code>，<code>day</code> 初始化给 <code>_day</code></p><p>🔥<strong>值得注意的是</strong>：</p><ol><li>每个成员变量在初始化列表中<code>只能出现一次</code>(初始化只能初始化一次)</li><li>类中包含以下成员，<code>必须放在初始化列表位置进行初始化</code>：<br> • <strong>引用成员变量</strong><br> • <strong>const 成员变量</strong><br> • <strong>自定义类型成员(且该类没有默认构造函数时)</strong></li></ol><p>🔥<strong>总结</strong>：<code>尽量使用初始化列表初始化</code>，因为不管你是否使用初始化列表，对于自定义类型成员变量，<code>一定会先使用初始化列表初始化</code>；成员变量在类中<code>声明次序</code>就是其在<code>初始化列表中的初始化顺序</code>，<code>与其在初始化列表中的先后次序无关</code></p><h2 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h2><p><strong>什么是 <a href="https://legacy.cplusplus.com/">explicit</a> 关键字？</strong></p><blockquote><p>explicit 关键字<code>主要用于修饰类的构造函数</code>，其目的是<code>防止隐式类型转换</code>。当一个构造函数被声明为 explicit 时，编译器就<code>不允许使用该构造函数进行隐式的类型转换了</code>，而<code>只能进行显式的类型转换操作</code></p></blockquote><p>🚩<strong>无 explicit 情况</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> num) : <span class="built_in">data</span>(num) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 隐式地将整数 10 转换为 MyClass 类型的对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动调用 <code>MyClass 的以 int 为参数的构造函数</code>，将 <code>10</code> 转换为 <code>MyClass</code> 类型的对象，这种隐式转换有时候<code>可能并非程序员的本意</code>，而且可能会导致一些<code>不易察觉的错误</code>或者<code>代码逻辑不够清晰</code></p><p>🚩<strong>有 explicit 情况</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> num)</span> : data(num) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 编译错误，不能进行隐式类型转换了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果想要从 <code>int</code> 类型转换为 <code>MyClass</code> 类型，就<code>必须进行显式的转换</code>，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 正确，显式调用构造函数创建对象</span></span><br><span class="line">MyClass obj = <span class="built_in">MyClass</span>(<span class="number">10</span>);  <span class="comment">// 也正确，通过显示构造临时对象再赋值（或者用于初始化）的方式</span></span><br></pre></td></tr></table></figure><p>这里 <code>MyClass(10)</code> 是个<code>匿名对象</code>，即<code>没有名字的对象</code>，匿名对象<code>具有临时性</code>，<code>只能使用一次</code>，使用完就<code>销毁</code></p><h1 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h1><blockquote><p>声明为 <code>static 的类成员</code>称为<code>类的静态成员</code>，用 static 修饰的成员变量，称之为<code>静态成员变量</code>；用 static 修饰的<br>成员函数，称之为<code>静态成员函数</code></p></blockquote><p>🔥<strong>值得注意的是</strong>：</p><ol><li>静态成员也是<code>类的成员</code>，受<code>public</code>、<code>protected</code>、<code>private</code> 访问限定符的限制</li><li>静态成员为所有类对象所<code>共享</code>，<code>不属于某个具体的对象</code>，存放在<code>静态区</code></li><li>静态成员变量<code>必须在类外定义</code>，定义时不添加<code>static</code>关键字，类中只是声明</li><li>类静态成员即可用 <code>类名::静态成员</code> 或者 <code>对象.静态成员</code> 来访问</li></ol><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p><code>静态成员变量</code>是<code>属于类的变量</code>，而<code>不是属于类的某个具体对象</code>。它被该类的所有对象所<code>共享</code>，在内存中<code>只有一份拷贝</code>。这与普通成员变量不同，<code>普通成员变量</code>是<code>每个对象都有自己独立的一份</code></p><p><strong>以记录学生总数为例子</strong>：<br>无论创建多少个 Student 对象，这个变量都只有一个，并且可以被所有 Student 对象访问</p><p>🚩<strong>定义和初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total_students;</span><br><span class="line">    <span class="comment">// 其他成员函数和变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total_students = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>静态成员变量<code>不能在类内部初始化</code>。因为类<code>只是一个模板</code>(后续介绍模版会更容易理解)，当类被加载时，还<code>没有</code>为静态成员变量<code>分配内存空间</code>。必须在<code>类的外部</code>进行初始化，而且要<code>使用类名来限定</code></p><p>🚩<strong>访问方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student::total_students++;</span><br></pre></td></tr></table></figure><p>也可以通过<code>类的对象来访问静态成员变量</code>，但是这种方式<code>容易让人误解为是对象的普通成员变量</code></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p><code>静态成员函数</code>基本与<code>静态成员变量</code>差不多</p><p>💻<strong>区别在于</strong>：由于静态成员函数<code>不与特定对象相关联</code>，所以<code>它没有this指针</code>。这意味着在静态成员函数内部<code>不能直接访问非静态成员变量和非静态成员函数</code>，因为没有 this 指针来<code>指明访问的是哪个对象的成员</code></p><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p><code>友元函数</code>是一种在类中<code>被声明为 “朋友” 的非成员函数</code>。它可以访问类的<code>私有（private）</code>和<code>保护（protected）</code>成员，就好像它是类的成员函数一样。这<code>打破了类的封装性</code>，但在某些特定情况下是非常有用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2024</span>,<span class="type">int</span> month = <span class="number">12</span>,<span class="type">int</span> day = <span class="number">2</span>)</span><br><span class="line">:_year(year)</span><br><span class="line">,_month(month)</span><br><span class="line">,_day(day)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Date::ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; out, Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">out &lt;&lt; d._year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; d._month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; d._day &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d1;</span><br><span class="line">cout &lt;&lt; d<span class="number">1.</span><span class="built_in">Getret</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d1;</span><br><span class="line"><span class="type">double</span> a = <span class="number">1.11</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在必须使用<code>operator&lt;&lt;重载</code>时，这种情况下不得不<code>突破封装性去访问类内变量</code>。友元函数可以<code>直接访问类的私有成员</code>，它是<code>定义在类外部的普通函数</code>，<code>不属于任何类</code>，但需要在类的内部声明，声明时需要<code>加 friend 关键字</code></p><p>🔥<strong>值得注意的是</strong>：<br>• 友元函数可访问类的私有和保护成员，但<code>不是类的成员函数</code><br>• 友元函数<code>不能用 const 修饰</code><br>• 友元函数可以<code>在类定义的任何地方声明</code>，<code>不受类访问限定符限制</code><br>• 一个函数可以是<code>多个类的友元函数</code><br>• 友元函数的调用与普通函数的<code>调用原理相同</code></p><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>顾名思义，就是把函数换成类的友元，<code>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 声明日期类为时间类的友元类，则在日期类中就直接访问Time类中的私有成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span> hour = <span class="number">0</span>, <span class="type">int</span> minute = <span class="number">0</span>, <span class="type">int</span> second = <span class="number">0</span>)</span><br><span class="line">: _hour(hour)</span><br><span class="line">, _minute(minute)</span><br><span class="line">, _second(second)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _hour;</span><br><span class="line"><span class="type">int</span> _minute;</span><br><span class="line"><span class="type">int</span> _second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">: _year(year)</span><br><span class="line">, _month(month)</span><br><span class="line">, _day(day)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetTimeOfDate</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 直接访问时间类私有的成员变量</span></span><br><span class="line"><span class="type">_t</span>._hour = hour;</span><br><span class="line"><span class="type">_t</span>._minute = minute;</span><br><span class="line"><span class="type">_t</span>._second = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">Time <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：<br>• 友元关系是<code>单向的</code>，<code>不具有交换性</code><br>比如上述 Time 类和 Date 类，在 Time 类中声明 Date 类为其友元类，那么可以在 Date 类中直接访问 Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行<br>• 友元关系<code>不能传递</code><br>如果B是A的友元，C是B的友元，则不能说明C时A的友元<br>• 友元关系<code>不能继承</code>，在继承位置再给大家详细介绍</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><strong>如果一个类定义在另一个类的内部，这个内部类就叫做内部类</strong>，内部类是一个<code>独立的类</code>，它<code>不属于外部类</code>，更<code>不能</code>通过外部类的对象去访问内部类的成员。外部类对内部类<code>没有任何优越的访问权限</code></p><p>所以<code>内部类天生就是外部类的友元类</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="comment">// B天生就是A的友元</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; k &lt;&lt; endl;<span class="comment">//OK</span></span><br><span class="line">cout &lt;&lt; a.h &lt;&lt; endl;<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::B b;</span><br><span class="line">b.<span class="built_in">foo</span>(<span class="built_in">A</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：</p><ol><li>内部类可以定义在外部类的 <code>public</code>、<code>protected</code>、<code>private</code> 都是可以的。</li><li>注意内部类<code>可以直接访问外部类中的 static 成员</code>，不需要外部类的对象&#x2F;类名。</li><li>sizeof(外部类)&#x3D;外部类，<code>和内部类没有任何关系</code></li></ol><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3665fc5d07cd49cfb6f3b0aad314bb02.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【优选算法】Prefix-Kage：前缀和的算法影（上）</title>
      <link href="/2024/12/15/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%E5%BD%B1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/12/15/%E4%BC%98%E9%80%89%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9A%84%E7%AE%97%E6%B3%95%E5%BD%B1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><p>🚩<strong>什么是前缀和算法？</strong><br><code>前缀和算法</code>是一种用于高效计算<code>数组区间和</code>的算法。对于一个给定的数组 <code>nums</code>，我们可以预先计算出它的前缀和数组 <code>prefixSum</code> ，其中 <code>prefixSum[i]</code> 表示 <code>nums[0]</code> 到 <code>nums[i]</code> 的<code>元素之和</code></p><p><strong>比如：</strong></p><blockquote><p>数组：<br><code>nums [ 1，2，3，4，5，6]</code><br>前缀和数组 ：<br><code>prefixSum [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]</code><br>即<code>[1, 3, 6, 10, 15]</code></p></blockquote><p>🚩<strong>为什么要使用前缀和算法？</strong><br>假设我们要对数组的一块<code>区间进行检查</code>，<code>元素个数为 n</code> ，<code>检查次数为 q</code> ，那么如果使用传统的<code>暴力解法</code>，即模拟算法，每次检查就要遍历一次数组，那么时间复杂度为 <code>O(n∗q)</code>，即 <code>O(n²)</code>；使用了前缀和算法可以让时间复杂度降级，即<code>O(n) +  O(q) </code>，是一种<code>空间换时间</code>的算法。此时如果 <code>n 和 q 的数据庞大</code>，暴力解法的<code>效率必然是低下的</code>，所以前缀和算法使用是<code>必要的</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="【模版】前缀和（一维）"><a href="#【模版】前缀和（一维）" class="headerlink" title="【模版】前缀和（一维）"></a>【模版】前缀和（一维）</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/755aade90d1b4f93a5d13c3b8e14e75c.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c86e1e5f436244bf9c93f337fcf247ea.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://www.nowcoder.com/practice/acead2f4c28c401889915da98ecdc6bf?tpId=230&tqId=2021480&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=196">【模版】前缀和（一维）</a></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>💻<strong>第一步：</strong> 预处理一个前缀和数组</p><p>假设有一个<code>数组 arr</code>，<code>dp [i]</code> 表示 <code>[1，i]</code> 区间內<code>所有元素的和</code>，<code>index</code> 表示<code>数组下标</code>（从 1 开始）<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/08d0f4ee39ce4956aafc570dcfb59596.jpeg" alt="请添加图片描述"><br>每一位的元素都可以表示为 <code>dp[i] = dp[i - 1] + arr[i]</code>，即<code>该位元素的和</code>等于<code>前面元素的和加上该位的元素</code>，可能你会无法理解，但本质上是个<code>小的动态规划</code>，会从最开始的元素<code>不断迭代</code>到当前的元素</p><p>💻<strong>第二步：</strong> 使用前缀和数组</p><p>那么回到这道题目，我们要<code>求一段区间内的和</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/367a33fd156847dbacb31964cdd84e8e.jpeg" alt="请添加图片描述"><br>假设我们要<code>求区间 [3，5] 的数据和</code>，因为前缀和都是<code>从 1 开始加的</code>，所以我们可以用<code>区间 [1，5]</code> 减去 <code>区间[1，2]</code> 得到想要的区间。取<code>左边界为 L</code> ，<code>右边界为 R</code>，即可总结出公式：<code>某区间的和 = dp[R] - dp[L- 1]</code></p><p>💻<strong>细节问题：</strong></p><p><strong>为什么 dp 数组从下表为 1 开始？</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a6221d71e1ab4d21af158f74dd59899c.jpeg" alt="请添加图片描述"><br>目的是为了<code>添加一个虚拟节点（辅助节点）</code>，<code>规避了边界处理</code>的问题。如图所示，如果取<code>区间 [0，2]</code> ，那么<code>左边界 L 取 0 </code>的时候会造成<code>下标为 -1 </code>的情况出现，所以为了避免这种情况，下标从 1 开始存放数据，且<code>下标为 0 处存放数据为 0 </code>就不会影响加和的结果</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.读入数据</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.预处理出来一个前缀和数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.使用前缀和数组</span></span><br><span class="line"><span class="type">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">cout &lt;&lt; dp[R] - dp[L - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> <code>dp 数组</code>的容量大小类型应为 <code>long long</code> ，因为存放的数据可能很大，想加后可能会超过 <code>int</code> 的类型大小</p><h2 id="【模版】前缀和（二维）"><a href="#【模版】前缀和（二维）" class="headerlink" title="【模版】前缀和（二维）"></a>【模版】前缀和（二维）</h2><p>✏️<strong>题目描述：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b36f6e922f8c482497e5db71e58d524c.png" alt="在这里插入图片描述"></p><p>✏️<strong>示例：</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7219267a73834038ad044cfde4a73b2e.png" alt="在这里插入图片描述"></p><blockquote><p><strong>传送门：</strong><a href="https://www.nowcoder.com/practice/99eb8040d116414ea3296467ce81cbbc?tpId=230&tqId=2023819&ru=/exam/oj&qru=/ta/dynamic-programming/question-ranking&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=196">【模版】前缀和（二维）</a></p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>根据示例 1 ，<code>二维矩阵图</code>如下：<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a15a23619c04f7393cfa5e45c1ae1cc.jpeg" alt="请添加图片描述"><br>从一点<code>（x1，y1）</code>到<code>（x2，y2）</code>的表示<code>这个矩阵中所有元素的和</code><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fc2aab3a668246afb74bee1a9f9ab542.jpeg" alt="请添加图片描述"><br>💻<strong>第一步：</strong> 预处理一个前缀和矩阵</p><p>根据题意我们想要求整个矩阵中<code>某个子集矩阵</code>，需要先把求<code>矩阵的模版</code>列出来<br>所以我们定义 <code>dp[i][j]</code> 表示从 <code>[1，1]</code> 到 <code>[i，j]</code> 位置，这段区间里所有元素的和<br>然后把矩阵<code>划分为A、B、C、D四个部分</code>便于求和</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ef16796603eb4be6b8b2052ef74dfb3e.jpeg" alt="请添加图片描述"></p><p>显然整个矩阵的面积是由四个部分加和而成，但是我们发现<code>B、C的面积不好求得</code><br>所以可以进行一些<code>加减的转化</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2764a61f87354e0da160c7cda11047aa.jpeg" alt="请添加图片描述"></p><p>主要是一个矩阵要在<code>[1，1]</code> 位置延伸就比较好算，所以通常会<code>结合着 A 计算</code>，多出的 A 要注意减掉，就可以整理出公式：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + arr[i][j] - dp[i - 1][j - 1]</code></p><p>💻<strong>第二步：</strong> 使用前缀和矩阵</p><p>回到题目，我们是要求矩阵中<code>某个子集矩阵</code>，所以根据图形及题意，画出如图：</p><p> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b23e2b6555644b7893b3b7dad9aa0379.jpeg" alt="请添加图片描述"></p><p>还是和第一步的方法一样，<code>巧用加减法算出矩阵元素和</code></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5b00e009379f4290bf42458b37986915.jpeg" alt="请添加图片描述"><br>那么可以整理出<code>（x1，y1）</code>到<code>（x2，y2）</code>表示为 <code>dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1]</code>，记得要<code>加上多减的一块 A</code></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.读入数据</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.预处理前缀和矩阵</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] + arr[i][j] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.使用前缀和矩阵</span></span><br><span class="line"><span class="type">int</span> x1 = <span class="number">0</span>, x2 = <span class="number">0</span>, y1 = <span class="number">0</span>, y2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">cout &lt;&lt; dp[x2][y2] - dp[x1 - <span class="number">1</span>][y2] - dp[x2][y1 - <span class="number">1</span>] + dp[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是：</strong> 和一维一样<code>从下标为 1 开始读入数据</code>，用 <code>long long 容器</code>存放</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/be14a674100d42a29ea03e0896aaa966.gif" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 优选算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microi吾码低代码平台：前端源码的本地运行探索</title>
      <link href="/2024/12/11/Microi%E5%90%BE%E7%A0%81/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%8E%A2%E7%B4%A2/"/>
      <url>/2024/12/11/Microi%E5%90%BE%E7%A0%81/%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E7%9A%84%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>传送门：<a href="https://microi.net/">Microi吾码官网</a></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0204770bc4f8457b927f85f7bf3b902e.jpeg" alt="在这里插入图片描述"></p><h1 id="前端源码运行环境要求"><a href="#前端源码运行环境要求" class="headerlink" title="前端源码运行环境要求"></a>前端源码运行环境要求</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>• <code>Windows</code>、<code>macOS</code> 或 <code>Linux</code> 都可以作为开发环境</p><p>• 对于某些<code>依赖特定工具链或包的项目</code>，可能有不同的要求，但大多数前端项目都可以<code>跨平台运行</code></p><h2 id="必备软件工具"><a href="#必备软件工具" class="headerlink" title="必备软件工具"></a>必备软件工具</h2><p>在开始之前，确保本地环境中已经安装了<code>以下工具</code>：</p><p>• <strong>Node.js 和 npm&#x2F;yarn</strong>：<code>Node.js</code> 是前端开发中不可或缺的环境，<code>npm</code> 和 <code>yarn</code> 是常用的<code>包管理工具</code>，可以从 <code>Node.js</code> 官网下载并安装</p><p>• <strong>代码编辑器</strong>：如 <code>Visual Studio Code</code>、<code>Sublime Text</code> 或 <code>WebStorm</code>，用于<code>编写和调试代码</code></p><p>• <strong>Git</strong>：用于<code>克隆代码库</code>和<code>版本控制</code>，Git 也可以从 <code>Git 官网</code>下载安装</p><h2 id="项目源码依赖"><a href="#项目源码依赖" class="headerlink" title="项目源码依赖"></a>项目源码依赖</h2><p>• 项目可能依赖于一些<code>特定版本的库或框架</code>，如 <code>React</code>、<code>Vue</code>、<code>Angular</code> 等，确保提前阅读项目文档，了解是否有其他依赖项</p><h1 id="从Git仓库克隆前端源码"><a href="#从Git仓库克隆前端源码" class="headerlink" title="从Git仓库克隆前端源码"></a>从Git仓库克隆前端源码</h1><ol><li><p>打开<code>终端（Terminal）</code>，选择合适的工作目录</p></li><li><p>使用 <code>git clone 命令</code>将项目源码克隆到<code>本地</code>：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/your-repository-name/project-name.git</span><br><span class="line"><span class="built_in">cd</span> project-name</span><br></pre></td></tr></table></figure><p>这里的 <code>your-repository-name/project-name</code> 替换成实际的Git仓库地址</p><h1 id="安装项目依赖"><a href="#安装项目依赖" class="headerlink" title="安装项目依赖"></a>安装项目依赖</h1><p>大部分前端项目都会使用 <code>package.json</code> 文件来管理项目依赖。依赖包的<code>安装过程</code>如下：</p><ol><li>使用 <code>npm</code> 或 <code>yarn</code> 安装依赖包：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>或者如果你<code>偏好使用 yarn</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure><ol start="2"><li>等待依赖包下载完成。这个过程可能<code>需要一些时间</code>，具体取决于项目的大小和网络速度</li></ol><h1 id="启动本地开发服务器"><a href="#启动本地开发服务器" class="headerlink" title="启动本地开发服务器"></a>启动本地开发服务器</h1><p>前端项目一般会有一个<code>本地开发服务器</code>，用于实时查看代码变化。大多数项目使用 <code>webpack-dev-server</code>、<code>Vite</code> 或其他开发服务器来实现这一点。启动开发服务器的命令通常会写在 <code>package.json</code> 的 <code>scripts</code> 字段下。常见的命令如下：</p><p>💻使用 npm 启动服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>💻使用 yarn 启动服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure><p>通常，运行后你可以在浏览器中访问 <code>http://localhost:3000</code>（或项目文档中提供的其他端口号），查看项目运行效果</p><h1 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h1><h2 id="依赖安装失败"><a href="#依赖安装失败" class="headerlink" title="依赖安装失败"></a>依赖安装失败</h2><p>在安装依赖时，常常会遇到一些<code>安装失败的情况</code>，常见原因包括：</p><p>• <strong>网络问题</strong>：在国内使用 <code>npm</code> 时，可能会因为网络原因导致依赖下载失败。此时可以使用<code>淘宝镜像源</code>来加速依赖安装</p><p>⌨️使用 <code>npm</code> 时，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>⌨️如果使用 <code>yarn</code>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>• <strong>依赖版本问题</strong>：有时候，项目依赖的某些包版本与当前<code>环境不兼容</code>。此时，可以尝试<code>删除 node_modules 目录</code>和 <code>package-lock.json 文件</code>，重新安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf node_modules</span><br><span class="line"><span class="built_in">rm</span> package-lock.json</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="端口冲突"><a href="#端口冲突" class="headerlink" title="端口冲突"></a>端口冲突</h2><p>如果在启动本地服务器时遇到<code>端口冲突</code>，可以尝试<code>更改项目的端口配置</code>。许多前端工具如 <code>webpack-dev-server</code> 和 <code>Vite</code> 都允许在配置文件中<code>指定不同的端口</code>。例如，在 <code>webpack</code> 配置中，可以<code>修改 devServer.port</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: 8081,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码更新未生效"><a href="#代码更新未生效" class="headerlink" title="代码更新未生效"></a>代码更新未生效</h2><p>当你修改代码后，浏览器中的更新没有即时显示，可以尝试以下方法：</p><p>• <strong>清空浏览器缓存</strong>：浏览器有时会<code>缓存旧的代码</code>，导致<code>新的修改不生效</code>。可以尝试<code>清空缓存</code>或<code>打开无痕模式</code></p><p>• <strong>检查热重载是否正常工作</strong>：大多数现代前端工具都<code>支持热重载</code>（Hot Module Replacement，HMR）。如果热重载<code>未能正常工作</code>，检查<code>开发服务器的配置文件</code></p><h1 id="提升本地开发体验的技巧"><a href="#提升本地开发体验的技巧" class="headerlink" title="提升本地开发体验的技巧"></a>提升本地开发体验的技巧</h1><h2 id="使用代理解决跨域问题"><a href="#使用代理解决跨域问题" class="headerlink" title="使用代理解决跨域问题"></a>使用代理解决跨域问题</h2><p>在开发过程中，前端和后端通常是分开的，跨域问题可能会导致<code>接口请求失败</code>。可以通过<code>配置开发服务器的代理</code>来绕过跨域问题。例如，<code>webpack-dev-server</code> 支持设置代理，将请求<code>转发到后端服务器</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成热重载与自动刷新"><a href="#集成热重载与自动刷新" class="headerlink" title="集成热重载与自动刷新"></a>集成热重载与自动刷新</h2><p>大多数现代开发框架都支持<code>热重载（HMR）</code>和<code>自动刷新</code>功能。当你修改文件时，浏览器会<code>自动刷新并显示最新内容</code>。为了<code>避免手动刷新</code>，可以确保在 <code>webpack</code> 或 <code>Vite</code> 配置中启用这些功能</p><h2 id="使用开发工具增强调试"><a href="#使用开发工具增强调试" class="headerlink" title="使用开发工具增强调试"></a>使用开发工具增强调试</h2><p>• <strong>浏览器开发者工具</strong>：浏览器自带的开发者工具（如 <code>Chrome DevTools</code>）能帮助你<code>调试 JavaScript 代码</code>、<code>查看网络请求</code>、<code>分析页面性能</code>等</p><p>• <strong>React DevTools&#x2F;Vue DevTools</strong>：对于使用 <code>React</code>或 <code>Vue</code> 的项目，安装相关的开发者工具扩展（如 <code>React DevTools</code>）可以帮助你<code>调试组件的状态和生命周期</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>运行界面源码</strong>：<br>🚩<strong>运行PC端vue2传统界面源码</strong></p><ol><li>在欢迎页打开Microi吾码开源版<code>【/microi.vue2.pc/】</code>文件夹</li><li>查看<code>【/microi.vue2.pc/说明.txt】</code>文件，执行几条<code>npm</code>常规命令后即可跑起来</li></ol><blockquote><p>传送门：<a href="https://www.nbweixin.cn/autopage/">Vue2传统界面试用地址（可操作数据）</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nvm use 14【注意一定需要14】</span></span><br><span class="line"><span class="comment">#nrm use taobao</span></span><br><span class="line"><span class="comment">#npm install</span></span><br><span class="line"><span class="comment">#npm run dev</span></span><br><span class="line"></span><br><span class="line">可能会出现的问题：</span><br><span class="line">1、报错：/node_modules/_monaco-editor@0.33.0@monaco-editor/esm/vs/basic-languages/_.contribution.js</span><br><span class="line">    解决：</span><br><span class="line">    将以下5个变量（在30多行代码左右）从LazyLanguageLoader内部移动到之上，使用var声明即可。</span><br><span class="line">    var _languageId;</span><br><span class="line">    var _loadingTriggered;</span><br><span class="line">    var _lazyLoadPromise;</span><br><span class="line">    var _lazyLoadPromiseResolve;</span><br><span class="line">    var _lazyLoadPromiseReject;</span><br><span class="line">    var LazyLanguageLoader = class &#123; ......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🚩<strong>运行PC端vue3仿webos操作系统界面（编译版）</strong></p><ol><li>进入<code>【/microi.vue3.os.build/】</code>文件夹</li><li>执行命令<code>#http-server</code>即可跑起来</li></ol><p>🚩<strong>运行PC端vue3仿webos操作系统界面源码（个人版）</strong></p><ol><li>在欢迎页打开Microi吾码个人版<code>【/microi.vue3.os/】</code>文件夹</li><li>查看<code>【/microi.vue3.os/说明.txt】</code>文件，执行几条<code>npm</code>常规命令后即可跑起来</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nvm use 18【建议使用18，与我们开发团队node版本一致】</span></span><br><span class="line"><span class="comment">#nrm use taobao</span></span><br><span class="line"><span class="comment">#npm install</span></span><br><span class="line"><span class="comment">#npm run dev</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="🚩运行移动端vue3-uniapp源码（基于图鸟UI）1-进入【-microi-vue3-tuniao-】文件夹2-执行-npm-install后，使用小程序调试工具即可打开"><a href="#🚩运行移动端vue3-uniapp源码（基于图鸟UI）1-进入【-microi-vue3-tuniao-】文件夹2-执行-npm-install后，使用小程序调试工具即可打开" class="headerlink" title="🚩运行移动端vue3 uniapp源码（基于图鸟UI）1. 进入【/microi.vue3.tuniao/】文件夹2. 执行#npm install后，使用小程序调试工具即可打开"></a>🚩<strong>运行移动端vue3 uniapp源码（基于图鸟UI）</strong><br>1. 进入<code>【/microi.vue3.tuniao/】</code>文件夹<br>2. 执行<code>#npm install</code>后，使用小程序调试工具即可打开</h2><p>在本地运行前端源码的过程相对简单，但成功的关键在于环境的配置与依赖的管理。通过<code>正确安装依赖</code>、<code>启动开发服务器</code>，<code>并了解如何解决常见问题</code>，你将能够顺利运行前端项目并进行高效开发。希望本文能帮助你顺利完成本地开发环境的搭建和调试。如果遇到任何问题，及时参考相关文档或开发者社区，通常都能找到解决方案</p><p>希望以上 <strong>Microi吾码低代码平台：前端源码的本地运行探索</strong> 能对你前端运行有帮助，在该平台上更流畅的运行(´▽&#96;ʃ♡ƪ)</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e5c9288a0caa4ecc90e768d1bf18defa.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Microi吾码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 低代码 </tag>
            
            <tag> vue </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++天使的灵动心跳代码：类和对象（中下）</title>
      <link href="/2024/12/09/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/12/09/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><blockquote><p><code>拷贝构造函数</code>是一种<code>特殊的构造函数</code>，它用于创建一个<code>新对象</code>，这个新对象是另一个<code>同类型对象的副本</code>，只有<code>单个形参</code>，该形参是对本类类型<code>对象的引用</code>(一般常用 const 修饰)，在用已存在的类类型对象创建新对象时由编译器<code>自动调用</code></p></blockquote><p><strong>其语法形式为</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名 (<span class="type">const</span> 类名&amp; 对象名) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>🤔<strong>为什么一定要引用传参呢？</strong></p><blockquote><p>当实参把对象传给形参的时候，如果不使用引用传参，那就是一个<code>传值的过程</code>，那么传值的时候要把<code>实参</code>传给一个<code>中间变量</code>，然后再由<code>中间变量</code>传给<code>形参</code>，这中间又<code>涉及了对象的拷贝</code>，然后以此类推，又要传值，又要拷贝，所以使用传值方式编译器直接报错，因为会<code>引发无穷递归调用</code></p></blockquote><p>🔥<strong>值得注意的是</strong>：</p><ol><li><code>已存在</code>的对象初始化一个<code>新对象</code>时叫做<code>拷贝</code>，<code>已存在</code>的对象初始化一个<code>已存在</code>的对象时叫做<code>赋值</code></li><li>const 关键字表示这个引用在函数内部<code>不会被修改</code></li><li><code>拷贝构造函数</code>是<code>构造函数</code>的一个<code>重载</code>形式</li><li>拷贝构造函数的<code>参数只有一个</code>且必须是类类型<code>对象的引用</code></li></ol><h2 id="默认拷贝构造函数"><a href="#默认拷贝构造函数" class="headerlink" title="默认拷贝构造函数"></a>默认拷贝构造函数</h2><p>当程序员没有为一个类定义拷贝构造函数时，编译器会<code>自动生成</code>一个<code>默认的拷贝构造函数</code></p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的类，其内部有一个指针成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，用于初始化字符串</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(s) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没有自定义拷贝构造函数，编译器会生成默认的拷贝构造函数（执行浅拷贝）</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="comment">// 析构函数，释放动态分配的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 使用默认的拷贝构造函数（浅拷贝）创建s2对象，相当于只是复制了指针str的值</span></span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(s1)</span></span>; </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1的字符串内容: &quot;</span> &lt;&lt; s<span class="number">1.</span>str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2的字符串内容: &quot;</span> &lt;&lt; s<span class="number">2.</span>str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改s2所指向的字符串内容</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s<span class="number">2.</span>str, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后s1的字符串内容: &quot;</span> &lt;&lt; s<span class="number">1.</span>str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;修改后s2的字符串内容: &quot;</span> &lt;&lt; s<span class="number">2.</span>str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若未显式定义，编译器会生成默认的拷贝构造函数，默认的拷贝构造函数对象<code>按内存存储按字节序完成拷贝</code>，这种拷贝叫做<code>浅拷贝</code>，或者<code>值拷贝</code>。<code>默认拷贝构造函数</code>会对类中的<code>每个成员进行简单的复制</code>，如果对于数据只是<code>可读</code>的话，直接<code>浅拷贝</code>即可；如果对于数据是<code>读写</code>的话，就需要<code>深拷贝</code>了</p><blockquote><p><code>深浅拷贝概念</code>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/144049255?spm=1001.2014.3001.5502">C++命运石之门代码抉择：C++入门（中）——3.2.4 引用的使用</a></p></blockquote><p>🔥<strong>值得注意的是</strong>：<code>MyString s2(s1)</code> 和 <code>MyString s2 = s1</code> 是<code>等价的</code></p><h2 id="显式调用拷贝构造函数"><a href="#显式调用拷贝构造函数" class="headerlink" title="显式调用拷贝构造函数"></a>显式调用拷贝构造函数</h2><p><code>显式调用拷贝构造函数</code>是指在代码中通过<code>明确的语法形式</code>来触发拷贝构造函数的调用，而不是依赖编译器在某些隐式场景下自动调用</p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>(<span class="type">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">_array = (DataType*)<span class="built_in">malloc</span>(capacity * <span class="built_in">sizeof</span>(DataType));</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">nullptr</span> == _array)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;malloc申请空间失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">_capacity = capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> DataType&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// CheckCapacity();</span></span><br><span class="line">_array[_size] = data;</span><br><span class="line">_size++;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_array)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(_array);</span><br><span class="line">_array = <span class="literal">nullptr</span>;</span><br><span class="line">_capacity = <span class="number">0</span>;</span><br><span class="line">_size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DataType* _array;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack s1;</span><br><span class="line">s<span class="number">1.</span><span class="built_in">Push</span>(<span class="number">1</span>);</span><br><span class="line">s<span class="number">1.</span><span class="built_in">Push</span>(<span class="number">2</span>);</span><br><span class="line">s<span class="number">1.</span><span class="built_in">Push</span>(<span class="number">3</span>);</span><br><span class="line">s<span class="number">1.</span><span class="built_in">Push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="function">Stack <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里<code>涉及了资源空间分配的问题</code>，如果只是调用默认拷贝构造函数的话，只能<code>按值拷贝</code>，那么两个对象将<code>指向同一块空间</code>，这明显是<code>不合理的</code>，所以这里我们就需要<code>显式调用拷贝构造函数</code>，进行<code>深拷贝</code>避免这个问题导致的<code>程序崩溃</code></p><p>🔥<strong>总结</strong>：类中如果<code>没有涉及资源申请时</code>，拷贝构造函数<code>是否写都可以</code>；一旦<code>涉及到资源申请时</code>，则拷贝构造函数是<code>一定要写的</code>，否则就是浅拷贝</p><p>🚩<strong>拷贝构造常用场景</strong>：<br>以下场景因为<code>都涉及对象拷贝</code>，所以要调用拷贝构造</p><ol><li>使用已存在对象创建新对象</li><li>函数参数类型为类类型对象</li><li>函数返回值类型为类类型对象</li></ol><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7da95dc7ae4940e9ae1f7c47c9eb0ddf.png" alt="在这里插入图片描述"><br>为了提高程序效率，一般对象传参时，尽量使用引用类型，返回时根据实际场景，<code>能用引用尽量使用引用</code></p><h1 id="运算符重载函数"><a href="#运算符重载函数" class="headerlink" title="运算符重载函数"></a>运算符重载函数</h1><h2 id="赋值运算符重载函数"><a href="#赋值运算符重载函数" class="headerlink" title="赋值运算符重载函数"></a>赋值运算符重载函数</h2><p><code>赋值运算符重载函数</code>是对类的<code>赋值运算符（=）</code>进行重新定义的<code>成员函数</code>或<code>非成员函数（通常作为成员函数实现）</code>，目的是让用户<code>自定义类型</code>（类对象）能够像<code>内置数据类型</code>那样<code>使用赋值运算符</code>进行赋值操作</p><p><strong>其语法形式为</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型 <span class="keyword">operator</span>运算符(参数) </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：</p><ol><li>不能通过连接其他符号来创建新的操作符：比如<code>operator@</code> </li><li>重载操作符<code>必须有一个类类型参数</code></li><li>用于内置类型的运算符，其含义不能改变，例如：内置的整型 <code>+</code>，<code>不能改变其含义</code></li><li>作为类成员函数重载时，其形参看起来比操作数数目少 1，因为成员函数的<code>第一个参数为隐藏的this</code></li><li><code>.*</code> <code>::</code> <code>sizeof</code> <code>?:</code> <code>.</code>注意以上5个运算符不能重载，这个经常在笔试选择题中出现</li></ol><h3 id="默认赋值运算符重载函数"><a href="#默认赋值运算符重载函数" class="headerlink" title="默认赋值运算符重载函数"></a>默认赋值运算符重载函数</h3><p>如果程序员<code>没有为类自定义赋值运算符重载函数</code>，编译器会<code>自动生成</code>一个<code>默认的赋值运算符重载函数</code>。这个默认函数会对类中的各个数据成员执行<code>按成员的赋值操作</code>，类似于<code>默认拷贝构造函数</code>执行的<code>浅拷贝</code>行为，<code>以值的方式逐字节拷贝</code></p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point p1, p2; </span><br><span class="line">p2 = p1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器生成的<code>默认赋值运算符重载函数</code>会把 <code>p1.x</code> 的值赋给 <code>p2.x</code>，把 <code>p1.y</code> 的值赋给 <code>p2.y</code>，因为 <code>x</code> 和 <code>y</code> 都是<code>基本数据类型成员</code></p><h3 id="显式调用赋值运算符重载函数"><a href="#显式调用赋值运算符重载函数" class="headerlink" title="显式调用赋值运算符重载函数"></a>显式调用赋值运算符重载函数</h3><p>🚩<strong>既然编译器生成的默认赋值运算符重载函数已经可以完成字节序的值拷贝了，还需要自己实现吗？</strong></p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">_year = year;</span><br><span class="line">_month = month;</span><br><span class="line">_day = day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">_year = d._year;</span><br><span class="line">_month = d._month;</span><br><span class="line">_day = d._day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Date&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;d)</span><br><span class="line">&#123;</span><br><span class="line">_year = d._year;</span><br><span class="line">_month = d._month;</span><br><span class="line">_day = d._day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line"><span class="type">int</span> _month;</span><br><span class="line"><span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回类型、参数类型为引用<code>提高传值效率</code>，<code>this != &amp;d</code> 检测是否<code>自己给自己赋值</code>，返回<code>*this</code> 便于进行<code>连续赋值操作</code></p><p>可以发现这里赋值运算符重载函数是<code>作为成员函数存在</code></p><p>🧐<strong>为什么赋值运算符只能重载成类的成员函数不能重载成全局函数？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符重载成全局函数，注意重载成全局函数时没有 this 指针了，需要给两个参数</span></span><br><span class="line">Date&amp; <span class="keyword">operator</span>=(Date&amp; left, <span class="type">const</span> Date&amp; right)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (&amp;left != &amp;right)</span><br><span class="line"> &#123;</span><br><span class="line"> left._year = right._year;</span><br><span class="line"> left._month = right._month;</span><br><span class="line"> left._day = right._day;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>赋值运算符如果<code>不显式实现</code>，编译器会<code>生成一个默认的</code>。此时用户再在类外自己实现一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载<code>冲突</code>了，<code>故赋值运算符重载只能是类的成员函数</code></p></blockquote><p>🔥<strong>总结</strong>：如果类中<code>未涉及到资源管理</code>，赋值运算符<code>是否实现都可以</code>；一旦<code>涉及到资源管理</code>则<code>必须要实现</code></p><h2 id="const-取地址运算符重载函数"><a href="#const-取地址运算符重载函数" class="headerlink" title="const 取地址运算符重载函数"></a>const 取地址运算符重载函数</h2><p><code>取地址运算符重载函数</code>是对<code>取地址运算符（&amp;）</code>进行重载的函数，在 C++ 中可以通过重载它来<code>改变获取对象地址</code>这一操作的默认行为。通常可以将其<code>定义为类的成员函数</code>，用于<code>返回对象的地址</code>或者<code>经过自定义处理后的与地址相关的信息</code></p><blockquote><p><code>取地址运算符重载</code>的逻辑与<code>赋值运算符重载类似</code>，且<code>不常用</code>，这两个运算符<code>一般不需要重载</code>，使用编译器生成的<code>默认取地址的重载即可</code>，只有特殊情况，才需要重载，比如<code>想让别人获取到指定的内容</code>！所以这里不重点讲述，感兴趣的读者可以自行了解</p></blockquote><p><strong>但我们可以思考几个问题</strong>：</p><p>🚩<strong>const 对象是否可以调用非 const 成员函数？</strong></p><p>一般情况下，const 对象不能调用非 const 成员函数。这是因为 const 对象被定义为其状态不能被修改，而非 const 成员函数可能会修改对象的数据成员</p><p>🚩<strong>非 const 对象是否可以调用 const 成员函数？</strong></p><p>非 const 对象可以调用 const 成员函数。因为 const 成员函数承诺不会修改对象的数据成员，所以对于非 const 对象来说，调用这样的函数是安全的</p><p>🚩<strong>const 成员函数内是否可以调用其它的非 const 成员函数？</strong><br>一般情况下，const 成员函数内不能直接调用非 const 成员函数。因为非 const 成员函数可能会修改对象的数据成员，这与 const 成员函数的承诺（不修改对象的数据成员）相冲突</p><p>🚩<strong>非 const 成员函数内是否可以调用其它的 const 成员函数？</strong><br>非 const 成员函数内可以调用 const 成员函数。因为 const 成员函数不会修改对象的数据成员，所以在非 const 成员函数中调用它是完全合法的，并且这种调用方式在实际编程中很常见</p><p>🔥<strong>总结</strong>：<code>主要看被调用的函数有没有可能会修改对象的数据成员</code></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9a768afb6bf04417b1f2a25cfc47ca1b.gif" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++天使的灵动心跳代码：类和对象（中上）</title>
      <link href="/2024/12/06/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/12/06/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="类的六大默认成员函数"><a href="#类的六大默认成员函数" class="headerlink" title="类的六大默认成员函数"></a>类的六大默认成员函数</h1><p>一个类里面如果<code>什么都没有</code>，就被叫做<code>空类</code>，但是空类里并不是真的什么都没有，而是<code>存在默认构造函数</code>。这个默认构造函数虽然没有做任何具体的初始化操作（因为类中没有成员变量），但它<code>满足了创建对象的基本需求</code></p><blockquote><p><strong>默认成员函数</strong>：用户<code>没有显式实现</code>，编译器会生成的成员函数称为<code>默认成员函数</code></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/00b81fdcd9174a4d808e200e8e3e9a49.png" alt="在这里插入图片描述"></p><p>• <strong>构造函数</strong>：主要完成<code>初始化</code>工作</p><p>• <strong>析构函数</strong>：主要完成<code>清理</code>工作</p><p>• <strong>拷贝构造函数</strong>：使用同类对象<code>初始化创建对象</code></p><p>• <strong>赋值运算符重载函数</strong>：将一个对象的值<code>赋值</code>给另一个同类型的对象</p><p>• <strong>取地址运算符重载函数</strong>：<code>返回对象的地址</code>或返回const对象的地址</p><p>• <strong>const 取地址运算符重载函数</strong>：<code>返回 const 对象在内存中的地址</code></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><blockquote><p><code>构造函数</code>是<code>特殊的成员函数</code>，需要注意的是，构造函数虽然名称叫构造，但是构造函数的主要任务并<code>不是开空间创建对象</code>，而是<code>初始化对象</code></p></blockquote><p><strong>其语法形式为</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名 () </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：</p><ol><li>函数名与类名<code>相同</code></li><li><code>无返回值</code></li><li><code>对象实例化</code>时编译器<code>自动调用</code>对应的构造函数</li><li>构造函数可以<code>重载</code></li><li>在<code>开空间</code>和<code>释放空间</code>特别好用，因为<code>自动调用</code>，不会忘记</li><li><code>一般不能放在私有</code>（学<code>单逆模式</code>的时候是放在私有的）</li></ol><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p><code>默认构造函数</code>是一种<code>特殊的构造函数</code>，在<code>没有显式提供初始化值</code>的情况下，用于<code>创建对象并进行默认的初始化</code>。它<code>没有参数</code>或者<code>所有参数都有默认值（全缺省）</code>，比如使用<code>缺省参数</code>就是，并且在对象整个生命周期内<code>只调用一次</code></p><p>🧐<strong>为什么要有默认构造函数？</strong> </p><blockquote><p>当创建一个<code>对象</code>时，需要对其进行<code>初始化</code>。<code>默认构造函数</code>提供了一种简单的、默认的初始化方式。例如，对于一个包含多个成员变量的类，默认构造函数可以<code>将这些成员变量初始化为合理的默认值</code>（即使是随机值也会是个确切的值），这样就保证了对象在创建后处于一个<code>确定的、合理的初始状态</code>。这就像是在建造一个房子时，给它一个基本的初始状态，比如所有的房间都是空的，墙壁是白色的等</p></blockquote><p>🤔<strong>为什么内置类型不用默认构造函数？</strong></p><blockquote><p><code>内置类型</code>（如<code>int</code>、<code>double</code>、<code>char</code>等）在 C++ 中是语言本身提供的<code>基本数据类型</code>，它们的初始化相对简单直接，它们不像类类型对象那样，有<code>复杂的成员变量</code>和<code>可能需要执行的构造函数</code>来完成初始化</p></blockquote><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// 此时obj.num的值为0，因为默认构造函数将其初始化为0</span></span><br><span class="line">    cout &lt;&lt; obj.num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用的<code>默认构造函数</code>是<code>无参的</code>，也可以不写 <code>num = 0</code> 这一条语句，只不过 num 的值就变成<code>随机值</code>了，也就是说如果<code>要对对象进行操作一定要有默认构造函数显式存在</code>，无论你赋不赋值，至少要让 num 有个值保证其处于一个<code>确定的状态 </code>；反过来如果<code>只是创建了对象</code>的话，没有进行对象操作，那么<code>可以不显式写默认构造函数</code>，编译器会<code>自动生成一个无参的默认构造函数</code></p><p>🔥<strong>值得注意的是</strong>：调用构造函数<code>不传参数</code>时不能写成<code>MyClass obj（）</code>，只能写成 <code>MyClass obj</code>，因为对象后面<code>不能跟括号</code>，否则就成了<code>函数声明</code>；<code>无参的</code>，<code>全缺省的</code>，我们<code>没写编译器默认生成的默认构造函数</code>只能有一个</p><h2 id="显式调用构造函数"><a href="#显式调用构造函数" class="headerlink" title="显式调用构造函数"></a>显式调用构造函数</h2><p><code>显式调用构造函数</code>主要用于<code>精确控制对象的创建和初始化过程</code>，当一个类有<code>多个构造函数</code>，且参数类型可能存在转换关系时，显式调用构造函数可以<code>明确指定使用哪一个构造函数来创建对象</code>，也就是<code>带参的构造函数</code></p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">  &#123;</span><br><span class="line">      _year = year;</span><br><span class="line">      _month = month;</span><br><span class="line">      _day = day;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数2024、12 、 6，将 d1 对象初始化为表示 2024 年 12 月 6 日这个日期</p><p>🔥<strong>值得注意的是</strong>：当在类中显式定义了其他构造函数（非默认构造函数）时，编译器<code>仍然会生成默认构造函数</code>，但是<code>优先使用</code>显式定义的构造函数</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><blockquote><p><code>析构函数</code>是类的一个特殊成员函数，与构造函数<code>功能相反</code>，析构函数<code>不是完成对对象本身的销毁</code>，对象销毁工作是由<code>编译器完成的</code>。而对象在销毁时会自动调用析构函数，完成<code>对象中资源的清理工作</code>。对象在生命周期结束时，需要释放其占用的资源，以<code>避免资源浪费</code>和可能出现的<code>内存泄漏</code>等问题</p></blockquote><p><strong>其语法形式为</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~类名 () </span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：</p><ol><li>析构函数名是在<code>类名前加上字符 ~</code></li><li><code>无参数无返回值类型</code></li><li>一个类<code>只能有一个析构函数</code>。若未显式定义，系统会<code>自动生成默认的析构函数</code>，注意：析构函数<code>不能重载</code></li><li><code>对象生命周期结束</code>时，C++编译系统系统<code>自动调用析构函数</code></li></ol><h2 id="默认析构函数"><a href="#默认析构函数" class="headerlink" title="默认析构函数"></a>默认析构函数</h2><p>对于只包含<code>基本类型</code>（如<code>int</code>、<code>double</code>、<code>char</code>等）成员变量的类，默认析构函数虽然看起来没有做什么实际的操作，但它是整个<code>对象销毁过程的一部分</code></p><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Time()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _hour;</span><br><span class="line"><span class="type">int</span> _minute;</span><br><span class="line"><span class="type">int</span> _second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 基本类型(内置类型)</span></span><br><span class="line"><span class="type">int</span> _year = <span class="number">1970</span>;</span><br><span class="line"><span class="type">int</span> _month = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> _day = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line">Time <span class="type">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Date d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序运行结束后输出</strong>：<code>~Time()</code>，在 main 中根本没有直接创建 Time 类的对象，<code>为什么最后会调用 Time 类的析构函数？</code></p><blockquote><p><code>内置类型</code>成员，销毁时<code>不需要资源清理</code>，最后系统直接将其<code>内存回收</code>即可；而 <code>_t</code> 是<code>Time</code>类对象，所以在 <code>d</code> 销毁时，要将其内部包含的 <code>Time</code> 类的 <code>_t</code> 对象<code>销毁</code>，所以要调用 <code>Time</code> 类的<code>析构函数</code>。但是：main 函数中<code>不能直接调用</code> <code>Time</code> 类的析构函数，实际要释放的是 <code>Date</code> 类对象，所以编译器会调用 <code>Date</code> 类的<code>析构函数</code>，而<code>Date</code> 没有显式提供，则编译器会给 <code>Date</code> 类生成一个<code>默认的析构函数</code>，目的是在其内部调用 <code>Time</code> 类的析构函数，即当 <code>Date</code> 对象销毁时，<code>要保证其内部每个自定义对象都可以正确销毁</code></p></blockquote><p>🔥<strong>总结</strong>：main 函数中并没有直接调用Time 类析构函数，而是显式调用编译器为 Date 类生成的<code>默认析构函数</code>，&#x3D;&#x3D;创建哪个类的对象则调用该类的析构函数，销毁那个类的对象则调用该类的析构函数&#x3D;&#x3D;</p><h2 id="显式调用析构函数"><a href="#显式调用析构函数" class="headerlink" title="显式调用析构函数"></a>显式调用析构函数</h2><p>当使用 <code>malloc</code> 在预先分配好的内存空间中创建对象时，就需要<code>显式调用析构函数</code>来进行<code>对象销毁</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，用于开辟指定大小的内存空间</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="type">int</span>* data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数，用于释放构造函数中开辟的内存空间</span></span><br><span class="line">    ~<span class="built_in">Array</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">        data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码<code>自动调用</code>构造函数和析构函数实现了<code>空间创建和销毁</code>，<code>避免忘记</code>释放或开辟空间</p><p>🔥<strong>值得注意的是</strong>：</p><ol><li>一般情况下<code>有动态资源申请</code>，就<code>需要显式写</code>析构函数释放资源</li><li><code>没有动态申请</code>，不需要写析构函数</li><li>需要释放的成员<code>都是自定义类型</code>，不需要写析构函数，这些成员变量<code>所属类的析构函数会自动被调用</code></li></ol><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/648f8819437d41608441582ee12aa634.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microi吾码低代码平台：高效便捷的生成与管理全能助手</title>
      <link href="/2024/12/04/Microi%E5%90%BE%E7%A0%81/%E9%AB%98%E6%95%88%E4%BE%BF%E6%8D%B7%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E7%AE%A1%E7%90%86%E5%85%A8%E8%83%BD%E5%8A%A9%E6%89%8B/"/>
      <url>/2024/12/04/Microi%E5%90%BE%E7%A0%81/%E9%AB%98%E6%95%88%E4%BE%BF%E6%8D%B7%E7%9A%84%E7%94%9F%E6%88%90%E4%B8%8E%E7%AE%A1%E7%90%86%E5%85%A8%E8%83%BD%E5%8A%A9%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Microi-吾码？"><a href="#什么是-Microi-吾码？" class="headerlink" title="什么是 Microi 吾码？"></a>什么是 Microi 吾码？</h1><p><code>Microi 吾码</code>是一个专为开发者设计的代码编辑平台，专注于提升开发者的编码效率和工作体验。它以<code>简洁的设计</code>和<code>强大的功能</code>著称，为开发者提供了一个<code>高效、灵活且高度可定制</code>的编程环境</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7e97d64deb694c2093b2a3ec9274b553.jpeg" alt="在这里插入图片描述"></p><h2 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h2><blockquote><p>Microi 吾码的设计初衷是平衡轻量与强大，让用户<code>无需庞大的集成开发环境（IDE）</code>，也能享受到快速、流畅的编码体验。它适用于从日常脚本编写到大型项目开发的各种场景</p></blockquote><h2 id="功能亮点"><a href="#功能亮点" class="headerlink" title="功能亮点"></a>功能亮点</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6dfa2ccbe0e5405e9d61aa359b9b6224.png" alt="在这里插入图片描述"></p><p>🚩<strong>多语言支持</strong></p><p>• Microi 吾码<code>支持多种主流编程语言</code>，如 Python、Java、JavaScript、C++、Go、Ruby 等<br>• 提供语法高亮、代码补全、错误提示、重构等实用功能，帮助开发者更高效地编写代码</p><p>🚩<strong>轻量级但功能全面</strong></p><p>• Microi 吾码<code>启动速度快</code>，<code>占用内存少</code>，但提供了类似 IDE 的功能，如调试工具、终端集成、任务管理等<br>• 特别<code>适合需要在性能有限的设备</code>上编程的用户</p><p>🚩<strong>插件生态系统</strong></p><p>• Microi 吾码<code>内置插件市场</code>，用户可以按需安装插件，扩展功能，比如代码片段管理器、Git 版本控制、数据库工具等<br>• 开发者还能根据需求<code>自行开发插件</code></p><p>🚩<strong>多平台支持</strong></p><p>• 无论是 <code>Windows</code>、<code>macOS</code> 还是 <code>Linux</code>，Microi 吾码都提供了<code>全面优化的安装包</code>，用户可随时<code>跨平台</code>工作</p><p>🚩<strong>高可定制性</strong></p><p>• 支持修改界面主题、图标风格、代码字体、行号显示等细节<br>• 用户可以通过<code>配置文件</code>进一步调整编辑器行为，如键绑定、扩展功能</p><p>🚩<strong>团队协作</strong></p><p>• 内置对 <code>Git</code> 等版本控制工具的支持，便于团队协作开发<br>• 提供<code>实时共享</code>功能，支持<code>多用户协作</code>编辑代码（需插件支持）</p><p>🚩<strong>内置调试工具</strong></p><p>• 支持对多种语言的<code>断点调试</code>和<code>运行日志查看</code>，开发者可以快速定位代码问题</p><h1 id="为什么选择-Microi-吾码？"><a href="#为什么选择-Microi-吾码？" class="headerlink" title="为什么选择 Microi 吾码？"></a>为什么选择 Microi 吾码？</h1><p>🔥轻量但强大<br>🔥快速上手<br>🔥灵活扩展<br>🔥高效生产力</p><h2 id="适用人群广"><a href="#适用人群广" class="headerlink" title="适用人群广"></a>适用人群广</h2><p><strong>初学者</strong></p><p>简单直观的界面和丰富的功能，使初学者可以专注于学习编程，而<code>无需应对复杂的开发环境 </code></p><p><strong>自由职业者</strong></p><p>轻量化设计和强大插件功能，让自由职业者能够<code>高效管理不同项目</code></p><p><strong>资深开发者</strong></p><p><code>丰富的调试工具、强大的代码分析功能以及高度可定制性</code>，非常适合有较高要求的资深开发者</p><p><strong>跨平台用户</strong></p><p>对需要在<code>多种操作系统之间切换</code>的用户来说，Microi 吾码的多平台支持非常便利</p><h2 id="2-2-编译工具比较"><a href="#2-2-编译工具比较" class="headerlink" title="2.2 编译工具比较"></a>2.2 编译工具比较</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/eb489040cb5f4a64a924ae6a77bd71a5.png" alt="在这里插入图片描述"><br>从这张对比表可以看出，Microi 吾码在<code>轻量性</code>、<code>启动速度</code>和<code>插件丰富度</code>上具有<code>明显的优势</code>，是许多开发者的理想选择</p><h1 id="Microi-吾码的安装使用教程"><a href="#Microi-吾码的安装使用教程" class="headerlink" title="Microi 吾码的安装使用教程"></a>Microi 吾码的安装使用教程</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="下载-Microi-吾码"><a href="#下载-Microi-吾码" class="headerlink" title="下载 Microi 吾码"></a>下载 Microi 吾码</h3><ol><li><p>打开 <code>Microi 吾码官网</code></p></li><li><p>根据你的操作系统选择适配的安装包：<br> • <code>Windows</code> 用户：下载 <code>.exe</code> 文件<br> • <code>macOS</code> 用户：下载 <code>.dmg</code> 文件<br> • <code>Linux</code> 用户：下载 <code>.tar.gz</code> 文件</p></li></ol><h3 id="安装-Microi-吾码"><a href="#安装-Microi-吾码" class="headerlink" title="安装 Microi 吾码"></a>安装 Microi 吾码</h3><p><strong>Windows</strong></p><blockquote><p>双击下载的 <code>.exe</code> 文件<br> 按照安装向导的提示，<code>选择安装路径</code><br>  点击<code>“下一步”</code>完成安装</p></blockquote><p><strong>macOS</strong></p><blockquote><p>打开下载的 <code>.dmg</code> 文件<br>将 Microi 吾码的图标拖拽到<code>“应用程序”</code>文件夹中<br>打开“应用程序”，点击 <code>Microi 吾码</code>启动</p></blockquote><p><strong>Linux</strong></p><ol><li>解压下载的 <code>.tar.gz</code> 文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf microi.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>进入解压后的文件夹：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> microi</span><br></pre></td></tr></table></figure><ol start="3"><li>运行安装脚本：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./install.sh</span><br></pre></td></tr></table></figure><h3 id="启动和配置"><a href="#启动和配置" class="headerlink" title="启动和配置"></a>启动和配置</h3><ol><li>启动 <code>Microi 吾码</code>，进入主界面</li><li>按需<code>安装插件</code>：点击“扩展”图标，搜索并安装需要的插件</li><li>自定义主题：进入<code>“设置”</code>，选择<code>“外观”</code>，挑选你喜欢的编辑器主题</li></ol><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><img src="https://i-blog.csdnimg.cn/direct/bf124bb89b954ebfa2c523d50b0cb799.png" alt="在这里插入图片描述"></p><p>⌨️<strong>CentOS7一键安装脚本</strong></p><blockquote><p>url&#x3D;<a href="https://static.itdos.com/install/install-microi-centos.sh;if">https://static.itdos.com/install/install-microi-centos.sh;if</a> [ -f &#x2F;usr&#x2F;bin&#x2F;curl ];then curl -sSO $url;else wget -O install-microi-centos.sh $url;fi;bash install-microi-centos.sh</p></blockquote><p><strong>注意事项</strong>：</p><blockquote><p>• 执行上面脚本时，会提示<code>【输入 g 以公网IP安装，输入 n 以内网IP安装】</code>，请根据实际情况输入<code>g</code>或<code>n</code><br>• 如果服务器<code>没有docker环境</code>，也会提示是否按y安装，虽然博主建议使用1Panel、宝塔之类的面板工具来管理服务器并安装<code>docker</code>，但如果您想快速开始就直接<code>键入y</code>吧<br>• 安装成功后，必需开放<code>microi-api</code>端口、前端传统界面端口、前端<code>Web</code>操作系统端口、<code>MinIO</code>端口<br>• 脚本安装<code>mysql</code>默认为4G内存服务器的性能配置，2G内存服务器<code>建议下载脚本去掉性能配置再运行脚本</code><br>• 重复执行一键脚本前会提示先删除所有已安装容器，这将导致所有数据丢失</p></blockquote><p><strong>安装docker</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a --format <span class="string">&quot;&#123;&#123;.Names&#125;&#125;&quot;</span> | grep <span class="string">&quot;^microi-install-&quot;</span> | xargs -r docker <span class="built_in">rm</span> -f</span><br></pre></td></tr></table></figure><p><strong>脚本代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：当前一键脚本版本：2024-11-24 11:47&#x27;</span></span><br><span class="line"><span class="comment"># 获取局域网IP</span></span><br><span class="line">LAN_IP=$(hostname -I | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：获取局域网IP: &#x27;</span><span class="variable">$LAN_IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取公网IP</span></span><br><span class="line">PUBLIC_IP=$(curl -s ifconfig.me)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：获取公网IP: &#x27;</span><span class="variable">$PUBLIC_IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 询问用户安装类型</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：您是想在公网访问系统还是内网访问？公网请提前做好端口开放。&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：输入 g 以公网IP安装，输入 n 以内网IP安装：&#x27;</span></span><br><span class="line"><span class="built_in">read</span> -r install_type</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$install_type</span>&quot;</span> == <span class="string">&quot;g&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  ACCESS_IP=<span class="variable">$PUBLIC_IP</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：将以公网IP安装。&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$install_type</span>&quot;</span> == <span class="string">&quot;n&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  ACCESS_IP=<span class="variable">$LAN_IP</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：将以内网IP安装。&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：无效的输入，脚本退出。&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查Docker是否安装</span></span><br><span class="line"><span class="keyword">if</span> ! [ -x <span class="string">&quot;<span class="subst">$(command -v docker)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：您未安装docker，推荐使用1Panel、宝塔等面板工具来安装docker并管理您的服务器！&#x27;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：是否立即安装Docker？(y/n)&#x27;</span></span><br><span class="line">  <span class="built_in">read</span> -r answer</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$answer</span>&quot;</span> != <span class="string">&quot;y&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Microi：安装取消，脚本退出。&#x27;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 安装Docker</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：开始安装Docker...&#x27;</span></span><br><span class="line">  <span class="built_in">sudo</span> yum update -y</span><br><span class="line">  <span class="built_in">sudo</span> yum install -y yum-utils</span><br><span class="line">  <span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">  <span class="built_in">sudo</span> yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">  <span class="built_in">sudo</span> systemctl start docker</span><br><span class="line">  <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：Docker已成功安装。&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置Docker镜像加速器（现在太难找了，如果报错timeout就去阿里云申请一个自己私有的加速地址）</span></span><br><span class="line">DOCKER_ACCELERATOR=<span class="string">&quot;https://mirrors.aliyun.com/docker-ce/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：配置Docker镜像加速器&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [&quot;$&#123;DOCKER_ACCELERATOR&#125;&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机端口和密码函数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：生成随机端口和密码函数&#x27;</span></span><br><span class="line"><span class="function"><span class="title">generate_random_port</span></span>() &#123;</span><br><span class="line">  <span class="built_in">shuf</span> -i 17777-65535 -n 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">generate_random_password</span></span>() &#123;</span><br><span class="line">  openssl rand -<span class="built_in">base64</span> 12 | <span class="built_in">tr</span> -dc <span class="string">&#x27;A-Za-z0-9&#x27;</span> | <span class="built_in">head</span> -c16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机数据目录</span></span><br><span class="line"><span class="function"><span class="title">generate_random_data_dir</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> container_name=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">local</span> <span class="built_in">dir</span>=<span class="string">&quot;/home/data-<span class="variable">$&#123;container_name&#125;</span>-<span class="subst">$(openssl rand -hex 4)</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;dir&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并提示用户手动删除已有容器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：检查并提示用户手动删除已有容器&#x27;</span></span><br><span class="line"><span class="keyword">if</span> docker ps -a --format <span class="string">&#x27;&#123;&#123;.Names&#125;&#125;&#x27;</span> | grep -q <span class="string">&#x27;^microi-install-&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：脚本重复运行前，需要先通过命令【docker ps -a --format &quot;&#123;&#123;.Names&#125;&#125;&quot; | grep &quot;^microi-install-&quot; | xargs -r docker rm -f】删除所有相关容器后再重新运行，注意此操作将会删除数据库、MinIO文件，请谨慎操作&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并安装unzip</span></span><br><span class="line"><span class="keyword">if</span> ! [ -x <span class="string">&quot;<span class="subst">$(command -v unzip)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：您未安装unzip，正在为您安装...&#x27;</span></span><br><span class="line">  <span class="built_in">sudo</span> yum install -y unzip</span><br><span class="line">  <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Microi：unzip安装失败，脚本退出。&#x27;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：unzip已成功安装。&#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：unzip已安装。&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 MySQL 配置文件</span></span><br><span class="line">MYSQL_CONF_FILE=<span class="string">&quot;/tmp/my_microi.cnf&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;[mysqld]&#x27;</span> &gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;lower_case_table_names = 1&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;max_connections = 500&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;key_buffer_size = 268435456&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;query_cache_size = 268435456&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;tmp_table_size = 268435456&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;innodb_buffer_pool_size = 536870912&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;innodb_log_buffer_size = 268435456&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sort_buffer_size = 1048576&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;read_buffer_size = 2097152&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;read_rnd_buffer_size = 1048576&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;join_buffer_size = 2097152&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;thread_stack = 393216&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;binlog_cache_size = 196608&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;thread_cache_size = 192&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;table_open_cache = 1024&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;character_set_server=utf8mb4&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;collation_server=utf8mb4_unicode_ci&#x27;</span> &gt;&gt; <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MySQL 5.6</span></span><br><span class="line">MYSQL_PORT=$(generate_random_port)</span><br><span class="line">MYSQL_ROOT_PASSWORD=$(generate_random_password)</span><br><span class="line">MYSQL_DATA_DIR=$(generate_random_data_dir <span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MySQL 将在端口 &#x27;</span><span class="variable">$&#123;MYSQL_PORT&#125;</span><span class="string">&#x27; 上安装，root 密码: &#x27;</span><span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>，数据目录: <span class="variable">$&#123;MYSQL_DATA_DIR&#125;</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/microios/mysql5.6:latest</span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name microi-install-mysql56 -p <span class="variable">$&#123;MYSQL_PORT&#125;</span>:3306 \</span><br><span class="line">  -v <span class="variable">$&#123;MYSQL_DATA_DIR&#125;</span>:/var/lib/mysql \</span><br><span class="line">  -v <span class="variable">$&#123;MYSQL_CONF_FILE&#125;</span>:/etc/mysql/conf.d/my_microi.cnf \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> \</span><br><span class="line">  -e MYSQL_TIME_ZONE=Asia/Shanghai \</span><br><span class="line">  -d registry.cn-hangzhou.aliyuncs.com/microios/mysql5.6:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Redis 6.2</span></span><br><span class="line">REDIS_PORT=$(generate_random_port)</span><br><span class="line">REDIS_PASSWORD=$(generate_random_password)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：Redis 将在端口 &#x27;</span><span class="variable">$&#123;REDIS_PORT&#125;</span><span class="string">&#x27; 上安装，密码: &#x27;</span><span class="variable">$&#123;REDIS_PASSWORD&#125;</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/microios/redis6.2:latest</span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name microi-install-redis -p <span class="variable">$&#123;REDIS_PORT&#125;</span>:6379 \</span><br><span class="line">  -e REDIS_PASSWORD=<span class="variable">$&#123;REDIS_PASSWORD&#125;</span> \</span><br><span class="line">  -d registry.cn-hangzhou.aliyuncs.com/microios/redis6.2:latest redis-server --requirepass <span class="variable">$&#123;REDIS_PASSWORD&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待MySQL容器启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：等待MySQL容器启动...&#x27;</span></span><br><span class="line"><span class="built_in">sleep</span> 5 <span class="comment"># 等待5秒，可根据实际情况调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查MySQL是否可以连接</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：检查MySQL是否可以连接...&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..10&#125;; <span class="keyword">do</span></span><br><span class="line">  docker <span class="built_in">exec</span> -i microi-install-mysql56 mysql -uroot -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> -e <span class="string">&quot;SELECT 1&quot;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; <span class="built_in">break</span></span><br><span class="line">  <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果MySQL服务启动失败，则退出脚本</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$i</span> -eq 60 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Microi：MySQL服务启动失败，脚本退出。&#x27;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许root用户从任意主机连接</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：允许root用户从任意主机连接&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> -i microi-install-mysql56 mysql -uroot -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> -e <span class="string">&quot;USE mysql; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>&#x27; WITH GRANT OPTION;&quot;</span></span><br><span class="line">docker <span class="built_in">exec</span> -i microi-install-mysql56 mysql -uroot -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> -e <span class="string">&quot;FLUSH PRIVILEGES;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载并解压MySQL数据库备份</span></span><br><span class="line">SQL_ZIP_URL=<span class="string">&quot;https://static.itdos.com/download/microi/file/mysql5.6.50-bak-latest.sql.zip&quot;</span></span><br><span class="line">SQL_ZIP_FILE=<span class="string">&quot;/tmp/mysql_backup.zip&quot;</span></span><br><span class="line">SQL_DIR=<span class="string">&quot;/tmp/mysql_backup&quot;</span></span><br><span class="line">SQL_FILE=<span class="string">&quot;<span class="variable">$&#123;SQL_DIR&#125;</span>/microi_demo.sql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;SQL_DIR&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：创建目录: &#x27;</span><span class="variable">$&#123;SQL_DIR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载ZIP文件</span></span><br><span class="line">curl -o <span class="variable">$&#123;SQL_ZIP_FILE&#125;</span> <span class="variable">$&#123;SQL_ZIP_URL&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：下载ZIP文件: &#x27;</span><span class="variable">$&#123;SQL_ZIP_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压ZIP文件并覆盖现有文件</span></span><br><span class="line">unzip -o -d <span class="variable">$&#123;SQL_DIR&#125;</span> <span class="variable">$&#123;SQL_ZIP_FILE&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：解压ZIP文件到: &#x27;</span><span class="variable">$&#123;SQL_DIR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：创建数据库 microi_demo&#x27;</span></span><br><span class="line">docker <span class="built_in">exec</span> -i microi-install-mysql56 mysql -uroot -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> -e <span class="string">&quot;CREATE DATABASE IF NOT EXISTS microi_demo CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原MySQL数据库备份</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：还原MySQL数据库备份: &#x27;</span><span class="variable">$&#123;SQL_FILE&#125;</span></span><br><span class="line">docker <span class="built_in">exec</span> -i microi-install-mysql56 mysql -uroot -p<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span> microi_demo &lt; <span class="variable">$&#123;SQL_FILE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MongoDB</span></span><br><span class="line">MONGO_PORT=$(generate_random_port)</span><br><span class="line">MONGO_ROOT_PASSWORD=$(generate_random_password)</span><br><span class="line">MONGO_DATA_DIR=$(generate_random_data_dir <span class="string">&quot;mongodb&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MongoDB 将在端口 &#x27;</span><span class="variable">$&#123;MONGO_PORT&#125;</span><span class="string">&#x27; 上安装，root 密码: &#x27;</span><span class="variable">$&#123;MONGO_ROOT_PASSWORD&#125;</span>，数据目录: <span class="variable">$&#123;MONGO_DATA_DIR&#125;</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/microios/mongo:latest</span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name microi-install-mongodb -p <span class="variable">$&#123;MONGO_PORT&#125;</span>:27017 \</span><br><span class="line">  -v <span class="variable">$&#123;MONGO_DATA_DIR&#125;</span>:/data/db \</span><br><span class="line">  -e MONGO_INITDB_ROOT_USERNAME=root \</span><br><span class="line">  -e MONGO_INITDB_ROOT_PASSWORD=<span class="variable">$&#123;MONGO_ROOT_PASSWORD&#125;</span> \</span><br><span class="line">  -d registry.cn-hangzhou.aliyuncs.com/microios/mongo:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装MinIO</span></span><br><span class="line">MINIO_PORT=$(generate_random_port)</span><br><span class="line">MINIO_CONSOLE_PORT=$(generate_random_port)</span><br><span class="line">MINIO_ACCESS_KEY=$(generate_random_password)</span><br><span class="line">MINIO_SECRET_KEY=$(generate_random_password)</span><br><span class="line">MINIO_DATA_DIR=$(generate_random_data_dir <span class="string">&quot;minio&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MinIO 将在端口 &#x27;</span><span class="variable">$&#123;MINIO_PORT&#125;</span><span class="string">&#x27; 和控制台端口 &#x27;</span><span class="variable">$&#123;MINIO_CONSOLE_PORT&#125;</span><span class="string">&#x27; 上安装，access key: &#x27;</span><span class="variable">$&#123;MINIO_ACCESS_KEY&#125;</span><span class="string">&#x27;，secret key: &#x27;</span><span class="variable">$&#123;MINIO_SECRET_KEY&#125;</span>，数据目录: <span class="variable">$&#123;MINIO_DATA_DIR&#125;</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/microios/minio:latest</span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name microi-install-minio -p <span class="variable">$&#123;MINIO_PORT&#125;</span>:9000 -p <span class="variable">$&#123;MINIO_CONSOLE_PORT&#125;</span>:9001 \</span><br><span class="line">  -v <span class="variable">$&#123;MINIO_DATA_DIR&#125;</span>:/data \</span><br><span class="line">  -v <span class="variable">$&#123;MINIO_DATA_DIR&#125;</span>/config:/root/.minio \</span><br><span class="line">  -e <span class="string">&quot;MINIO_ROOT_USER=<span class="variable">$&#123;MINIO_ACCESS_KEY&#125;</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;MINIO_ROOT_PASSWORD=<span class="variable">$&#123;MINIO_SECRET_KEY&#125;</span>&quot;</span> \</span><br><span class="line">  -d registry.cn-hangzhou.aliyuncs.com/microios/minio:latest server /data --console-address <span class="string">&quot;:9001&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取并安装后端microi-api接口系统</span></span><br><span class="line">API_PORT=$(generate_random_port)</span><br><span class="line">API_IMAGE=<span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/microios/microi-api:latest&quot;</span></span><br><span class="line">API_CONTAINER_NAME=<span class="string">&quot;microi-install-api&quot;</span></span><br><span class="line">OS_CLIENT_DB_CONN=<span class="string">&quot;Data Source=<span class="variable">$&#123;LAN_IP&#125;</span>;Database=microi_demo;User Id=root;Password=<span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span>;Port=<span class="variable">$&#123;MYSQL_PORT&#125;</span>;Convert Zero Datetime=True;Allow Zero Datetime=True;Charset=utf8mb4;Max Pool Size=500;sslmode=None;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：拉取并安装后端microi-api接口系统: &#x27;</span><span class="variable">$&#123;API_IMAGE&#125;</span></span><br><span class="line">docker pull <span class="variable">$&#123;API_IMAGE&#125;</span></span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name <span class="variable">$&#123;API_CONTAINER_NAME&#125;</span> -p <span class="variable">$&#123;API_PORT&#125;</span>:80 \</span><br><span class="line">  -e <span class="string">&quot;OsClient=iTdos&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientType=Product&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientNetwork=Internal&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientDbConn=<span class="variable">$&#123;OS_CLIENT_DB_CONN&#125;</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientRedisHost=<span class="variable">$&#123;LAN_IP&#125;</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientRedisPort=<span class="variable">$&#123;REDIS_PORT&#125;</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;OsClientRedisPwd=<span class="variable">$&#123;REDIS_PASSWORD&#125;</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;AuthServer=http://<span class="variable">$&#123;LAN_IP&#125;</span>:<span class="variable">$&#123;API_PORT&#125;</span>&quot;</span> \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -v /usr/share/fonts:/usr/share/fonts \</span><br><span class="line">  -d <span class="variable">$&#123;API_IMAGE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取并安装前端传统界面</span></span><br><span class="line">VUE_PORT=$(generate_random_port)</span><br><span class="line">VUE_IMAGE=<span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/microios/microi-client:latest&quot;</span></span><br><span class="line">VUE_CONTAINER_NAME=<span class="string">&quot;microi-install-client&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：拉取并安装前端传统界面: &#x27;</span><span class="variable">$&#123;VUE_IMAGE&#125;</span></span><br><span class="line">docker pull <span class="variable">$&#123;VUE_IMAGE&#125;</span></span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name <span class="variable">$&#123;VUE_CONTAINER_NAME&#125;</span> -p <span class="variable">$&#123;VUE_PORT&#125;</span>:80 \</span><br><span class="line">  -e <span class="string">&quot;OsClient=iTdos&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;ApiBase=http://<span class="variable">$&#123;ACCESS_IP&#125;</span>:<span class="variable">$&#123;API_PORT&#125;</span>&quot;</span> \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -v /usr/share/fonts:/usr/share/fonts \</span><br><span class="line">  -d <span class="variable">$&#123;VUE_IMAGE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取并安装前端WebOS操作系统</span></span><br><span class="line">WEBOS_PORT=$(generate_random_port)</span><br><span class="line">WEBOS_IMAGE=<span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/microios/microi-os:latest&quot;</span></span><br><span class="line">WEBOS_CONTAINER_NAME=<span class="string">&quot;microi-install-os&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：拉取并安装前端WebOS操作系统: &#x27;</span><span class="variable">$&#123;WEBOS_IMAGE&#125;</span></span><br><span class="line">docker pull <span class="variable">$&#123;WEBOS_IMAGE&#125;</span></span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name <span class="variable">$&#123;WEBOS_CONTAINER_NAME&#125;</span> -p <span class="variable">$&#123;WEBOS_PORT&#125;</span>:80 \</span><br><span class="line">  -e <span class="string">&quot;OsClient=iTdos&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;ApiBase=http://<span class="variable">$&#123;ACCESS_IP&#125;</span>:<span class="variable">$&#123;API_PORT&#125;</span>&quot;</span> \</span><br><span class="line">  -v /etc/localtime:/etc/localtime \</span><br><span class="line">  -v /usr/share/fonts:/usr/share/fonts \</span><br><span class="line">  -d <span class="variable">$&#123;WEBOS_IMAGE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Watchtower</span></span><br><span class="line">WATCHTOWER_CONTAINER_NAME=<span class="string">&quot;microi-install-watchtower&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：安装Watchtower以自动更新API、Vue和WebOS容器&#x27;</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/microios/watchtower:latest</span><br><span class="line">docker run -itd --restart=always --log-opt max-size=10m --log-opt max-file=10 --privileged=<span class="literal">true</span> \</span><br><span class="line">  --name <span class="variable">$&#123;WATCHTOWER_CONTAINER_NAME&#125;</span> -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  registry.cn-hangzhou.aliyuncs.com/microios/watchtower:latest <span class="variable">$&#123;API_CONTAINER_NAME&#125;</span> <span class="variable">$&#123;VUE_CONTAINER_NAME&#125;</span> <span class="variable">$&#123;WEBOS_CONTAINER_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出所有服务的信息</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;==================================================================&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：所有服务已成功安装。&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：前端传统界面访问地址: http://&#x27;</span><span class="variable">$ACCESS_IP</span><span class="string">&#x27;:&#x27;</span><span class="variable">$VUE_PORT</span><span class="string">&#x27;，账号: admin，密码: demo123456&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：前端WebOS操作系统访问地址: http://&#x27;</span><span class="variable">$ACCESS_IP</span><span class="string">&#x27;:&#x27;</span><span class="variable">$WEBOS_PORT</span><span class="string">&#x27;，账号: admin，密码: demo123456&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：Redis: 容器名称 microi-install-redis, 端口 &#x27;</span><span class="variable">$&#123;REDIS_PORT&#125;</span><span class="string">&#x27;, 密码: &#x27;</span><span class="variable">$&#123;REDIS_PASSWORD&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MySQL: 容器名称 microi-install-mysql56, 端口 &#x27;</span><span class="variable">$&#123;MYSQL_PORT&#125;</span><span class="string">&#x27;, Root 密码: &#x27;</span><span class="variable">$&#123;MYSQL_ROOT_PASSWORD&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MongoDB: 容器名称 microi-install-mongodb, 端口 &#x27;</span><span class="variable">$&#123;MONGO_PORT&#125;</span><span class="string">&#x27;, Root 密码: &#x27;</span><span class="variable">$&#123;MONGO_ROOT_PASSWORD&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：MinIO: 容器名称 microi-install-minio, 端口 &#x27;</span><span class="variable">$&#123;MINIO_PORT&#125;</span><span class="string">&#x27;, 控制台端口 &#x27;</span><span class="variable">$&#123;MINIO_CONSOLE_PORT&#125;</span><span class="string">&#x27;, Access Key: &#x27;</span><span class="variable">$&#123;MINIO_ACCESS_KEY&#125;</span>, Secret Key: <span class="variable">$&#123;MINIO_SECRET_KEY&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：后端microi-api接口系统: 容器名称 &#x27;</span><span class="variable">$&#123;API_CONTAINER_NAME&#125;</span><span class="string">&#x27;, 端口 &#x27;</span><span class="variable">$&#123;API_PORT&#125;</span><span class="string">&#x27;, 镜像: &#x27;</span><span class="variable">$&#123;API_IMAGE&#125;</span><span class="string">&#x27;, 局域网IP: &#x27;</span><span class="variable">$&#123;LAN_IP&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：前端传统界面: 容器名称 &#x27;</span><span class="variable">$&#123;VUE_CONTAINER_NAME&#125;</span><span class="string">&#x27;, 端口 &#x27;</span><span class="variable">$&#123;VUE_PORT&#125;</span><span class="string">&#x27;, 镜像: &#x27;</span><span class="variable">$&#123;VUE_IMAGE&#125;</span><span class="string">&#x27;, API URL: http://&#x27;</span><span class="variable">$&#123;ACCESS_IP&#125;</span><span class="string">&#x27;:&#x27;</span><span class="variable">$&#123;API_PORT&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：前端WebOS操作系统: 容器名称 &#x27;</span><span class="variable">$&#123;WEBOS_CONTAINER_NAME&#125;</span><span class="string">&#x27;, 端口 &#x27;</span><span class="variable">$&#123;WEBOS_PORT&#125;</span><span class="string">&#x27;, 镜像: &#x27;</span><span class="variable">$&#123;WEBOS_IMAGE&#125;</span><span class="string">&#x27;, API URL: http://&#x27;</span><span class="variable">$&#123;ACCESS_IP&#125;</span><span class="string">&#x27;:&#x27;</span><span class="variable">$&#123;API_PORT&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Microi：Watchtower: 容器名称 &#x27;</span><span class="variable">$&#123;WATCHTOWER_CONTAINER_NAME&#125;</span><span class="string">&#x27;, 已安装以自动更新API、Vue和WebOS容器&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;==================================================================&quot;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Microi 吾码不仅是一个简单的代码编辑工具，更是一个强大的编程平台。它凭借轻量化、灵活性和强大的扩展能力，成为了越来越多开发者的首选。如果你还没有尝试过，不妨安装体验，感受编程效率的飞跃！(๑•̀ㅂ•́)و✧</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6eb35e0c86354201aa3550a967b0b65a.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Microi吾码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 低代码 </tag>
            
            <tag> vue </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++天使的灵动心跳代码：类和对象（上）</title>
      <link href="/2024/12/02/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/12/02/CPP%E5%88%9D%E9%98%B6/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h1><p>🚩<strong>面向过程</strong><br>C语言所学的内容主要都是面向过程的，核心是过程（函数），将程序看作是一系列步骤的组合。它强调的是 “怎么做”，重点在于设计函数和函数之间的调用顺序来完成任务，整个过程是围绕操作步骤（函数）展开的</p><p>例如：<code>在一个文件复制程序中，面向过程的思路是先打开源文件，然后读取源文件内容，接着打开目标文件，再将读取的内容写入目标文件，最后关闭文件</code></p><p>🚩<strong>面向对象</strong><br>核心是对象，把现实世界中的事物抽象成对象，对象包含数据（属性）和操作数据的方法。它强调的是 “有什么”，重点在于定义对象的属性和行为，通过对象之间的相互作用来完成任务</p><p>例如：<code>对于文件复制程序，面向对象的思路是创建文件对象，这些文件对象有自己的属性（如文件名、文件路径、文件内容等）和方法（如打开、读取、写入、关闭等），通过操作这些文件对象来实现文件复制</code></p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h2><p>类是一种数据类型，在<code>C语言</code>中类指的是结构体，但他只能包含<code>变量</code>；在<code>C++</code>中的类能包括<code>变量和函数</code>，清晰对一个对象进行属性行为说明，所以类和结构体十分相似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以C语言环境</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* arr = &amp;a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以C++环境</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* arr = &amp;a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面结构体的定义，在 C++ 中喜欢用<code>class</code>来代替，实际上在 C++ 中 class 和 struct 都可以用，只是 C++ 里更喜欢用 class 与 C 语言做区分</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p><strong>其语法形式为</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">className</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 类体：由成员函数和成员变量组成</span></span><br><span class="line">&#125;;  <span class="comment">// 一定要注意后面的分号</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：</p><p>• <code>class</code>为定义<code>类的关键字</code>，<code>ClassName</code>为<code>类的名字</code>，{}中为<code>类的主体</code>，注意类定义结束时后面<code>分号不能省略</code><br>• 类体中内容称为<code>类的成员</code>：类中的<code>变量</code>称为<code>类的属性</code>或<code>成员变量</code>; 类中的<code>函数</code>称为<code>类的方法</code>或者<code>成员函数</code></p><h2 id="类中的声明与定义"><a href="#类中的声明与定义" class="headerlink" title="类中的声明与定义"></a>类中的声明与定义</h2><p>假如我们要描述一个学生：</p><p>🚩<strong>定义与声明全都放在类中</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _name &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _sex &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _age &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> _name;<span class="comment">//姓名</span></span><br><span class="line">cahr _sex;<span class="comment">//性别</span></span><br><span class="line"><span class="type">int</span> _age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般我们平常没有做项目时就把成员函数的声明定义都放在一起</p><p>🚩<strong>定义与声明分开</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">char</span> _name;<span class="comment">//姓名</span></span><br><span class="line">cahr _sex;<span class="comment">//性别</span></span><br><span class="line"><span class="type">int</span> _age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">student::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; _name &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _sex &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _age &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，更期望采用<code>定义与声明分开</code>方式，因为以后在写项目通常会分多个文件。由于是在<code>类域外访问</code>成员函数，所以要加上<code>作用域限定符</code></p><h2 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h2><p><strong>类的封装</strong>：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选<br>择性的将其接口提供给外部的用户使用</p><p><strong>访问限定符分为</strong>：</p><p>• public（公有）<br>• protected（保护）<br>• private（私有）</p><p>⌨️<strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常我们把成员变量放在私有（成员函数放在私有的情况后面会讲），成员函数放在公有，私有的是无法直接访问的，放在私有的变量一般通过成员函数访问（前提是成员函数在类域内，不在类域内要使用友元函数，后面会讲）</p><p>🔥<strong>值得注意的是</strong>：</p><ol><li>public 修饰的成员在<code>类外</code>可以<code>直接被访问</code></li><li>protected 和 private 修饰的成员在<code>类外不能直接被访问</code></li><li>protected 和 private <code>目前是一样的</code>，都是私有，其区别到了继承才体现出来</li><li>访问权限<code>作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</code></li><li>如果后面没有访问限定符，<code>作用域就到 &#125; 即类结束</code></li></ol><p><strong>为什么在私有成员变量会在变量名前加个 _ ？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们看看这个函数，是不是很僵硬？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">// 这里的year到底是成员变量，还是函数形参？</span></span><br><span class="line"> year = year;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通常私有成员变量会在变量名前加个 _ ，这是为了和传参的时候的名字做区分，避免不好区分变量，导致私有变量错误访问</p><p>🔥<strong>值得注意的是</strong>：私有成员变量在<code>这里是声明</code>，就算写成<code>int _year = 0</code>也只叫作<code>给缺省参数</code>，真正区分变量是否为定义还是声明在于<code>变量有没有开空间</code></p><p><strong>C++ 中 struct 和 class 的区别是什么？</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myVariable; <span class="comment">// 默认是 private 访问权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> myVariable; <span class="comment">// 默认是 public ![请添加图片描述](https://i-blog.csdnimg.cn/direct/f4fdd1e8a3244e58a6dca3126594c320.jpeg)</span></span><br><span class="line">访问权限</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不写访问限定符，在 MyClass 中，myVariable <code>外部不能直接访问</code>，而在 MyStruct 中，myVariable <code>外部可以直接访问</code></p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>在<a href="https://blog.csdn.net/Zero_VPN/article/details/144021581?spm=1001.2014.3001.5502">C++命运石之门代码抉择：C++入门（上）</a>中我们详细介绍了域的概念</p><p>类定义了一个新的作用域，叫<code>类域</code>，类的所有成员都在类的作用域中，<code>在类体外定义成员时，需要使用 :: 作用域操作符指明成员属于哪个类域</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">PrintPersonInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line"> <span class="type">char</span> _sex[<span class="number">10</span>];</span><br><span class="line"> <span class="type">int</span>  _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintPersonInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; _sex &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要指定 PrintPersonInfo 是属于Person 这个类域</p><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>用类类型<code>创建对象的过程</code>，称为<code>类的实例化</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person._age = <span class="number">100</span>;   <span class="comment">// 编译失败：error C2059: 语法错误:“.”</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是上面的类，这种实例化方式是<code>错误的</code></p><blockquote><p>打个比方：<code>类实例化</code>出对象就像现实中使用<code>建筑设计图建造出房子</code>，<code>类</code>就像是<code>设计图</code>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</p></blockquote><p><strong>正确的实例化</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Person student;</span><br><span class="line"> student._age = <span class="number">10</span>;</span><br><span class="line"> student._name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line"> student._sex = male;</span><br><span class="line"> student.<span class="built_in">PrintPersonInfo</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>先创建对象，才能对类中的成员进行操作</p><h2 id="类的存储与大小"><a href="#类的存储与大小" class="headerlink" title="类的存储与大小"></a>类的存储与大小</h2><p><strong>类是如何存储的？</strong></p><blockquote><p>如果要把所有成员都包括在类的存储中，按照此种方式存储，当一个类创建多个对象时，每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么如何解决呢？</p></blockquote><p>⌨️所以在存储方式上类<code>只保存成员变量，成员函数存放在公共的代码段</code>，这就有效的减少了空间浪费，每个对象中成员变量是不同的，但是调用同一份函数，函数只在使用的使用的时候去公共部分调用</p><p><strong>通过对下面的不同对象分别获取大小来分析</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类中既有成员变量，又有成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中仅有成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中什么都没有---空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A3</span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>• sizeof(A1) : 4<br>• sizeof(A2) : 1<br>• sizeof(A3) : 1</p><p>🔥<strong>值得注意的是</strong>：类的大小计算也遵循内存对齐规则；为什么<code>类中仅有成员函数</code>或<code>空类</code>的内存为大小为 1 byte，内存计算不是只考虑变量吗？原因其实非常简单，如果对这两种情况的类取地址，没有空间的话就会程序报错，但是这两个类又是真实存在的，所以定义<code>这两种类的大小为 1 byte ，是为了占位，表示对象存在，不存储有效数据</code></p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><blockquote><p>this 指针是一个<code>隐含的指针</code>，它<code>指向当前对象的实例</code>。它在类的成员函数内部使用，用于区分成员函数的参数和对象的成员变量，特别是当它们名称相同时</p></blockquote><p><strong>举个日期类的例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> cout &lt;&lt;_year&lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt;_month &lt;&lt; <span class="string">&quot;-&quot;</span>&lt;&lt; _day &lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _year;     <span class="comment">// 年</span></span><br><span class="line"> <span class="type">int</span> _month;    <span class="comment">// 月</span></span><br><span class="line"> <span class="type">int</span> _day;      <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d1, d2;</span><br><span class="line"> d<span class="number">1.</span><span class="built_in">Init</span>(<span class="number">2022</span>,<span class="number">1</span>,<span class="number">11</span>);</span><br><span class="line"> d<span class="number">2.</span><span class="built_in">Init</span>(<span class="number">2022</span>,<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line"> d<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"> d<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当 d1 调用 Init 函数时，该函数是如何知道应该设置 d1 对象，而不是设置 d2 对象呢？</strong></p><blockquote><p>C++编译器给每个<code>非静态的成员函数</code>增加了一个<code>隐藏的指针参数</code>，让该指针<code>指向当前对象(函数运行时调用该函数的对象)</code>，在函数体中所有<code>成员变量</code>的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即<code>用户不需要来传递，编译器自动完成</code></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/94cf13ee85924cdd951ac3d61065dbcc.png" alt="在这里插入图片描述"><br>如图所示揭露了编译器的隐藏操作，其实在调用函数时传递了对象的地址</p><p><strong>this指针可以为空吗？</strong><br>如果 this 指针没有访问对象的成员，那么可以置空；如果 this 指针需要访问对象的成员，就不能为空，不然会导致程序报错，非法访问内存地址</p><p>🔥<strong>值得注意的是</strong>：</p><ol><li>this 指针的类型：类类型* const，即成员函数中，<code>不能给 this 指针赋值</code></li><li>只能在<code>成员函数内部使用</code></li><li>this 指针本质上是<code>成员函数的形参</code>，当对象调用成员函数时，将对象地址作为实参传递给 this 形参，所以<code>对象中不存储 this 指针</code></li><li>this 指针是<code>成员函数第一个隐含的指针形参</code>，一般情况由编译器通过 ecx 寄存器自动传递，不需要用户传递</li><li>this 指针<code>不能在实参和形参显式传递</code>，但是<code>可以在函数内部使用</code></li></ol><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/28047451037d4cc4986a8de8588a7399.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命运石之门代码抉择：C++入门（下）</title>
      <link href="/2024/11/29/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/11/29/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言过渡到C-下"><a href="#C语言过渡到C-下" class="headerlink" title="C语言过渡到C++(下)"></a>C语言过渡到C++(下)</h1><h2 id="auto-关键字-C-11"><a href="#auto-关键字-C-11" class="headerlink" title="auto 关键字(C++11)"></a>auto 关键字(C++11)</h2><h3 id="为什么要用-auto？"><a href="#为什么要用-auto？" class="headerlink" title="为什么要用 auto？"></a>为什么要用 auto？</h3><p>随着后续 C++ 语法的越来越深入，类型的长度可能会越来越长，因为在一些情境下是不允许把全部命名空间全部打开，所以在写类型时可能会遇到以下问题：</p><p>• <strong>类型难于拼写</strong><br>• <strong>含义不明确导致容易出错</strong></p><p>⌨️比如后续学到迭代器有这么个类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt;::iterator</span><br></pre></td></tr></table></figure><p>或许有聪明的人会想到直接用 typedef 给类型取别名不就好了，使用typedef给类型取别名确实可以简化代码，但是 typedef 有会遇到新的难题：</p><blockquote><p>在编程时，常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚地知道表达式的类型，然而有时候要做到这点并非那么容易，而且 typedef 只能定死变量的别名，auto 是自动推断的，因此 C++11 给 auto 赋予了新的含义</p></blockquote><h3 id="什么是-auto？"><a href="#什么是-auto？" class="headerlink" title="什么是 auto？"></a>什么是 auto？</h3><p><strong>早期的 auto</strong>：使用auto修饰的变量，是具有自动存储器的局部变量<br><strong>C++11 的新 auto</strong>：根据该变量初始化表达式的类型来自动确定变量自身的类型</p><p>🔥<strong>值得注意的是</strong>：auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAuto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">return10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> b = a;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">TestAuto</span>();</span><br><span class="line">cout&lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt;endl;</span><br><span class="line"><span class="comment">//auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 typeid().name() 用于输出类型，后续会学到。分别输出 int、char、int</p><p>🔥<strong>值得注意的是</strong>：使用 auto 定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导 auto 的实际类型<br><code>因此 auto 并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型</code></p><h3 id="auto-的使用"><a href="#auto-的使用" class="headerlink" title="auto 的使用"></a>auto 的使用</h3><p>🚩<strong>auto 与指针和引用结合起来使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>* b = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>&amp; c = x;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    *a = <span class="number">20</span>;</span><br><span class="line">    *b = <span class="number">30</span>;</span><br><span class="line">     c = <span class="number">40</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 auto 声明指针类型时，用 auto 和 auto* 没有任何区别，但用 auto 声明引用类型时则必须加&amp;</p><p>🚩<strong>在同一行定义多个变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAuto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3</span>, d = <span class="number">4.0</span>;  <span class="comment">// 该行代码会编译失败，因为c和d的初始化表达式类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译<br>器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</p><p>🚩<strong>auto 不能作为函数的参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAuto</span><span class="params">(<span class="keyword">auto</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>此处代码编译失败，auto 不能作为形参类型，因为编译器无法对 a 的实际类型进行推导</p><p>🚩<strong>auto 不能直接用来声明数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAuto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b[] = &#123;<span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组在声明时，其类型不仅仅取决于数组元素的类型，还与数组的大小有关，使用auto无法准确传达出这个数组大小的信息</p><h2 id="基于范围的-for-循环-C-11"><a href="#基于范围的-for-循环-C-11" class="headerlink" title="基于范围的 for 循环(C++11)"></a>基于范围的 for 循环(C++11)</h2><p>💻<a href="https://blog.csdn.net/Zero_VPN/article/details/142187329?spm=1001.2014.3001.5501">遍历数组的普通方法</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++i)</span><br><span class="line">     array[i] *= <span class="number">2</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* p = array; p &lt; array + <span class="built_in">sizeof</span>(array)/ <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++p)</span><br><span class="line">     cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种遍历方式写起来有点复杂，过于麻烦，于是在 C++11 开发了基于 for 循环的语法糖，什么是语法糖？<code>语法糖是编程语言中的一个术语，它指的是在编程语言中添加的某种语法，这种语法对语言的功能没有实质性的改变，但是可以让代码更加简洁、易读，更符合程序员的编程习惯</code></p><p>💻<strong>基于范围的 for 循环遍历数组</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : array)</span><br><span class="line">     e *= <span class="number">2</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : array)</span><br><span class="line">     cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读一下这个代码，就是依次取数组中的数据赋给 e，这样的代码简洁易读</p><p>🔥<strong>值得注意的是</strong>：该语法糖自动迭代，自动结束；适用于所有数组，后面的容器也会用到；与普通循环类似，可以用continue来结束本次循环，也可以用break来跳出整个循环；数组作为形参时提供的是地址，不能用语法糖</p><h2 id="指针空值-nullptr-C-11"><a href="#指针空值-nullptr-C-11" class="headerlink" title="指针空值 nullptr (C++11)"></a>指针空值 nullptr (C++11)</h2><p>在良好的C&#x2F;C++编程习惯中，声明一个变量时最好给该变量一个合适的初始值，否则可能会出现不可预料的错误，比如未初始化的指针，如果一个指针没有合法的指向，我们基本都是按照如下方式对其进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NULL <strong>实际是一个宏</strong>，在传统的 C **头文件(stddef.h)**中</p><p>⌨️NULL可能被定义为字面常量 0，或者被定义为无类型指针 void* 的常量，不论采取何<br>种定义，在使用空值的指针时，都不可避免的会遇到一些麻烦，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;f(int*)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">f</span>((<span class="type">int</span>*)<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序本意是想通过 f(NULL) 调用指针版本的 f(int*) 函数，但是由于 NULL 被定义成 0，变成调用 f(int)，所以为了避免这种情况，创建了一个指针 nullptr 专门代指空指针，之前的 NULL更多当作 0 使用</p><p>🔥<strong>值得注意的是</strong>：</p><ol><li>在使用 nullptr 表示指针空值时，不需要包含头文件，因为 nullptr 是 C++11 作为新关键字引入的</li><li>在C++11中，sizeof(nullptr) 与 sizeof((void*)0) 所占的字节数相同</li><li>为了提高代码的健壮性，在后续表示指针空值时建议最好使用 nullptr</li></ol><p>最近天气好冷，大家注意多穿衣服喝热水保暖🥶</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ad17eaac9d914875a1c807c58c2e5e4c.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命运石之门代码抉择：C++入门（中）</title>
      <link href="/2024/11/27/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/11/27/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言过渡到C-中"><a href="#C语言过渡到C-中" class="headerlink" title="C语言过渡到C++(中)"></a>C语言过渡到C++(中)</h1><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>是函数的一种特殊情况，C++允许在&#x3D;&#x3D;同一作用域&#x3D;&#x3D;中声明几个功能类似的同名函数，这<br>些同名函数的形参列表不同在于<font color="#dd0000">参数个数 或 类型 或 类型顺序</font><br />常用来处理实现功能类似数据类型不同的问题</p><h3 id="函数重载的多种情况"><a href="#函数重载的多种情况" class="headerlink" title="函数重载的多种情况"></a>函数重载的多种情况</h3><p>🚩<strong>参数类型不同</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;int Add(int left, int right)&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Add</span><span class="params">(<span class="type">double</span> left, <span class="type">double</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;double Add(double left, double right)&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数类型为 int ，一个函数类型为 double ，构成函数重载</p><p>🚩<strong>参数个数不同</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数含有不含参数，一个函数有一个参数，构成函数重载</p><p>🚩<strong>参数类型顺序不同</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(int a,char b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> b, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(char b, int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数先传 int 再传 char，一个函数先传 char 再传 int</p><p>🔥<strong>值得注意的是</strong>：函数的返回值不构成重载；一定是在<code>同一作用域内</code>的函数构成重载，因为要和学继承时的重定义概念区分</p><h3 id="函数重载的辨别"><a href="#函数重载的辨别" class="headerlink" title="函数重载的辨别"></a>函数重载的辨别</h3><p>🚩<strong>参数类型顺序混淆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(int a,char b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> b, <span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(int b, char a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种典型错误的函数重载，函数参数顺序的重载针对的是<font color="#dd0000">类型</font><br />这里只是把参数名调换了顺序，这会导致传参的时候出现歧义，不知道要调用哪一个函数，所以参数顺序重载和参数名顺序无关，只和参数类型顺序有关</p><p>🚩<strong>无参与缺省参数混淆</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;f(int a = 0)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是一种典型错误的函数重载，无参和只有一个缺省参数其实是同一种情况，这里函数调用的时候编译器不知道要不要传入缺省值，导致产生歧义</p><h3 id="函数重载原理——名字修饰"><a href="#函数重载原理——名字修饰" class="headerlink" title="函数重载原理——名字修饰"></a>函数重载原理——名字修饰</h3><p>根据 C 语言的学习，我们知道一个程序执行的过程分为<font color="#dd0000">预处理、编译、链接</font><br />在链接阶段，链接器会根据编译器生成的经过名字修饰后的函数名称，将调用和函数定义进行正确的连接</p><p>⌨️由于Windows下vs的修饰规则过于复杂，而Linux下g++的修饰规则简单易懂，下面我们使用了g++演示了这个修饰后的名字</p><p>💻<strong>C语言环境下</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0387ec13519f44278ea8bbad03dd2278.png" alt="在这里插入图片描述"></p><p>• C 语言的函数调用通常是比较直接的过程，在编译阶段，编译器会将函数调用翻译成机器指令，这些指令会在运行时按照调用约定将参数传递到栈上或者寄存器中，然后跳转到函数的入口地址执行函数体</p><p>• 在链接过程中，C 语言的函数名在目标文件中一般是简单的符号形式，例如，对于函数int func(int a)，在目标文件中函数名可能就是 func ，当链接器链接多个目标文件时，它会根据函数名来匹配函数的调用和定义</p><p>💻<strong>C++环境下</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/464f398b85254a50ba2b240cd3b64ea9.png" alt="在这里插入图片描述"></p><p>⌨️根据反汇编代码可以知道函数在 C++ 环境下进行了函数名修饰，i 是整型，d 是双精度浮点数，Pi 是整型指针，这里 “Z” 是名字修饰后的标识部分，“4” “3”可能与函数名 “func” 的长度有关</p><p>• C++ 由于有函数重载、命名空间、类等特性，其函数调用过程相对复杂。在编译阶段，除了传递参数等常规操作外，编译器还需要进行名字修饰来区分不同的函数</p><p>• 在链接阶段，C++ 的函数名经过名字修饰后，链接器才能正确地将函数调用和函数定义进行匹配。例如，对于函数int func(int a)，在不同的编译器和编译选项下，可能会被修饰成类似 _Z4funcidPi 这样复杂的名字，以区别于其他可能存在的同名函数（如不同参数类型的重载函数）</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h3><blockquote><p>引用是一种别名机制，它允许你为一个已经存在的变量创建一个新的名字，这个新名字和原来的变量共享相同的内存地址，对引用的操作实际上就是对被引用变量的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a; </span><br><span class="line"><span class="comment">// b 是 a 的别名</span></span><br></pre></td></tr></table></figure><p>🔥<strong>值得注意的是</strong>：引用与指针类似，他与指向的变量共享一块内存，引用本身不占据内存，他是指向变量的别名，引用本质上是绑定到指向变量的地址上</p><h3 id="引用的特性"><a href="#引用的特性" class="headerlink" title="引用的特性"></a>引用的特性</h3><p>🚩<strong>定义时必须初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span>&amp; b;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>指针在创建的时候可以不绑定变量地址，但是引用必须绑定指向变量</p><p>🚩<strong>一个变量可以有多个引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">int</span>&amp; c = a;</span><br></pre></td></tr></table></figure><p>a 的别名可以是多个，b 和 c 都是 a 的别名</p><p>🚩<strong>引用只能绑定一个变量</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = x;</span><br></pre></td></tr></table></figure><p>这里 b 已经绑定了 a ，就不能再绑定 x 了，举个有趣的例子，a 已经和 b 结婚了，就不能再去找小三了🤓</p><p>🔥<strong>值得注意的是</strong>：<br>• 没有 NULL 引用，但有 NULL 指针<br>• 有多级指针，但是没有多级引用<br>• 访问实体方式不同，指针需要显式解引用，引用编译器自己处理<br>• 引用比指针使用起来相对更安全</p><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><h4 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h4><p>⌨️只有左边引用的值改变会影响右边的值时候，才涉及权限的放大与缩小，权限可以平移或缩小，但是不能放大，<font color="#dd0000">普通赋值就不涉及权限的问题</font><br /></p><p>🚩<strong>权限的放大</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ra = a;  </span><br></pre></td></tr></table></figure><p>a 与 ra 的类型不匹配，需要在 int&amp; 前加一个 const，这里是权限的放大</p><p>🚩<strong>权限的平移和缩小</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; c = a；</span><br></pre></td></tr></table></figure><p>第二行是权限的平移，等号两边都是 int 类型，是权限的平移；第三行是权限的缩小，左边是 const int ，右边是 int ，是权限的缩小</p><p>🚩<strong>普通赋值不涉及权限</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br></pre></td></tr></table></figure><p>a 拷贝给 b，没有放大权限，因为这里 b 的改变不影响 a，和权限没有关系</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>⌨️在介绍常引用之前，我们要回顾一下<a href="https://blog.csdn.net/Zero_VPN/article/details/143237196?spm=1001.2014.3001.5502">算术转换</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1.11</span>;</span><br><span class="line"><span class="type">int</span> b = a;</span><br></pre></td></tr></table></figure><p>这里 int 向上转化为 double ，难道是直接进行转化吗?不是的，a 在传递给 b 的过程中产生了一个 int 的临时变量，临时变量具有常性，但这里是普通赋值，不涉及权限问题，所以直接赋给 b</p><p>💻那么就可以迁移到<font color="#dd0000">常引用类型转换</font><br /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">1.11</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = d;</span><br></pre></td></tr></table></figure><p>这里 d 先转化成 int 的临时变量，临时变量具有常性（常性就是类似于加了 const不可修改），左边的值没加 const ，所以这里是权限的放大，转换失败</p><h3 id="引用的使用"><a href="#引用的使用" class="headerlink" title="引用的使用"></a>引用的使用</h3><p>🚩<strong>引用做参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp = left;</span><br><span class="line">   left = right;</span><br><span class="line">   right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参给形参传值时，如果想要调用函数时，能够改变实参的值，通常我们会使用传址调用的方式，也就是把实参的地址传给指针形参，但这样未免太麻烦了，那么用引用代替指针未免不是一个好办法，修改引用的值就是修改原来的实参</p><p>🚩<strong>引用做返回值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">   n++;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="built_in">Count</span>()</span><br><span class="line">   cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先我们要知道什么是浅拷贝，什么是深拷贝？</strong><br>⌨️ <font color="#dd0000">浅拷贝：</font><br />浅拷贝会创建一个新的东西，这个新东西的基本内容是把原来的东西复制了一份。但是如果碰到比较复杂的内容，像一组东西，新的和旧的就都指向这同一组东西，会互相影响的</p><p> ⌨️ <font color="#dd0000">深拷贝：</font><br />与浅拷贝不同的是他不仅会把原来的东西全部复制过去，他会重新创建一份自己的地址，不会互相影响</p><p>💻<strong>如果没有引用返回和 static 的话</strong>：<br>那么他是创建一个中间变量把 n 复制过去，然后再把中间变量赋值给 ret，为什么要这么做？因为出了作用域 n 传给 ret 的值是不确定的</p><p>• 如果 Count 函数结束，栈帧销毁，没有清理栈帧，那么 ret 的结果侥幸是正确的<br>• 如果 Count 函数结束，栈帧销毁，清理栈帧，那么 ret 的结果是随机的</p><p>💻<strong>如果没有 static 的话</strong>：<br>局部变量是在函数的栈帧上分配内存的，当函数执行完毕后，其栈帧会被销毁，局部变量所占用的内存也随之被释放。在 Count 函数中，n 是一个局部变量，当 Count 函数执行完 return n; 这一步并返回后，n 所占用的内存已经被释放了，此时返回的引用实际上指向了一块已经被释放的内存区域</p><p>所以想要使用引用返回的话就要保证返回的值是没有被销毁的，或者要在返回的值前加上 static 关键字</p><h3 id="传值、传引用效率比较"><a href="#传值、传引用效率比较" class="headerlink" title="传值、传引用效率比较"></a>传值、传引用效率比较</h3><blockquote><p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。当一个函数返回引用时，它返回的是对象在内存中的地址，而不是对象的副本，有利于提高效率</p></blockquote><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><h3 id="非内联函数与内联函数比较"><a href="#非内联函数与内联函数比较" class="headerlink" title="非内联函数与内联函数比较"></a>非内联函数与内联函数比较</h3><p>⌨️以 inline 修饰的函数叫做内联函数，编译时 C++ 编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数提升程序运行的效率。假如有 1000 行代码调用非内联函数（3行），那么一共有 1000 + 3 行；假如有 1000 行代码调用内联函数（3行），那么一共有 1000 * 3 行</p><p>💻<strong>非内联函数</strong><br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a26f61fe52b849538b2759c81763e5d7.png" alt="在这里插入图片描述"><br>一个简单的加和函数，转到反汇编，是有 call 指令的，也就是调用函数</p><p>💻<strong>内联函数</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8011bbb38597463491d529e5df76cf69.png" alt="在这里插入图片描述"><br>转到反汇编可以发现已经没有 call 指令的生成了，说明内联函数不是调用的，而是在原来要使用的地方展开的，总的来说内联函数是一种用空间换时间的函数</p><p><strong>内联函数查看方法</strong>：在 debug 模式下，需要对编译器进行设置，否则不会展开，因为debug 模式下，编译器默认不会对代码进行优化，要方便调试，所以要在 release 模式下运行</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1c15400ad1744aebbe3b05d346e17dde.png" alt="请添加图片描述"></p><p>打开项目属性界面，调试信息格式中选用程序数据库</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d248e4040f2744b1ba5ea809c40198aa.png" alt="在这里插入图片描述"><br>内联函数扩展选用只适用于 _inline(&#x2F;Ob1)，再选择应用就行了</p><h3 id="内联函数的特性"><a href="#内联函数的特性" class="headerlink" title="内联函数的特性"></a>内联函数的特性</h3><p>🚩1. 内联函数适用于短小且频繁调用的函数<br>🚩2. inline 对于编译器只是个建议，最终是否成为内联函数，编译器自己决定<br>🚩3. 比较长的函数、递归函数等类似的函数即使加了 inline 也会被编译器否决<br>🚩4. inline 不建议声明和定义分离，分离会导致链接错误，因为 inline 被展开，就没有函数地址了，链接就会找不到<br>🚩5. 内联函数可以替换宏的短小函数定义</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0ae84f2c4761486ca1c7513f26851596.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++命运石之门代码抉择：C++入门（上）</title>
      <link href="/2024/11/25/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/11/25/CPP%E5%88%9D%E9%98%B6/C++%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是C"><a href="#什么是C" class="headerlink" title="什么是C++"></a>什么是C++</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aba95acab57c4f57802bb7a63515bca2.png" alt="请添加图片描述"></p><blockquote><p>C++ 是一种高级编程语言，它在 C 语言的基础上发展而来的面向对象的语言，C++ 最初是由丹麦计算机科学家本贾尼・斯特劳斯特卢普（Bjarne Stroustrup）在 20 世纪 80 年代初期开发的，当时，C 语言已经在系统编程等领域广泛应用，但对于大型软件项目的开发，缺乏一些如代码复用、数据抽象等方便的机制，简单来说就是对一些自定义类型的完善，C++ 应运而生，它增加了类和对象等面向对象的概念，使得程序可以更好地组织和维护</p></blockquote><h2 id="C-的发展"><a href="#C-的发展" class="headerlink" title="C++的发展"></a>C++的发展</h2><p>语言的开发都是在原先基础上增加新的语法规则，而不是删掉过去的语法规则，不然会导致以前编程环境下的代码都无法运行（python除外），于是在C语言的基础上进行扩展，增加了类的机制，称之为C with classes</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c1b3ef39ba824263bf99dce36fd8b3a5.png" alt="在这里插入图片描述"></p><p>刚开始是每五年更新一次语法规则，但随着生产力的需要，加快了语法规则的更新，变为三年</p><p><font color="#dd0000">现在主流使用还是C++98和C++11，所有不用追求最新</font><br />重点将C++98和C++11掌握好，随着对C++理解不断加深，有时间可以去琢磨下更新的特性</p><h2 id="C-的重要性"><a href="#C-的重要性" class="headerlink" title="C++的重要性"></a>C++的重要性</h2><p>图片计算机语言排名来自<a href="https://www.tiobe.com/tiobe-index/">TIOBE编程语言社区</a><br>2024年7月最新的排行榜</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/746e984dfa5c4433bbc340facfec021c.png" alt="在这里插入图片描述"></p><p>近几年 C++ 的上涨趋势还是比较明显的，虽然说还比不上 python 泛用性强大，但是 C++作为常年排名前几的语言，学习起来还是特别有价值的</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a9dd08246f684e34a275ab18d654af8a.png" alt="在这里插入图片描述"><br>就拿现在发展较🔥的人工智能来说，大家首先想到的就是 python ，认为学习人工智能就要学习python，这个是误区，python 中库比较丰富，使用 python 可以快速搭建神经网络、填入参数导入数据就可以开始训练模型了，但人工智能背后深度学习算法等核心还是用 C++ 写的</p><h2 id="如何学习C"><a href="#如何学习C" class="headerlink" title="如何学习C++"></a>如何学习C++</h2><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ff080800ee6f467dbcfd79fbce930d93.png" alt="在这里插入图片描述"><br>首先不要把 C++ 学会当成一个短期目标，而是一个长期目标，要精通这门语言还是需要花费很久的时间的</p><p>🚩1. 写博客总结<br>🚩2. 画思维导图整理思路<br>🚩3. 深入C++后，借鉴大佬的书刊或文章<br>🚩4. 多刷题！多刷题！多刷题！重要的事情说三遍</p><h2 id="C-要学什么"><a href="#C-要学什么" class="headerlink" title="C++要学什么"></a>C++要学什么</h2><p>C++ 的重点可以大致分为封装、多态、继承</p><p>其中重点学习：</p><p>🔥C++的基本语法<br>🔥STL库<br>🔥高阶的数据结构</p><h1 id="C语言过渡到C-上"><a href="#C语言过渡到C-上" class="headerlink" title="C语言过渡到C++(上)"></a>C语言过渡到C++(上)</h1><p>那么接下来正式开始C++内容的学习，但在学习前要先介绍一些知识点便于过渡到 C++ 的重点内容——<font color="#dd0000">类与对象</font><br /></p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>域可以<strong>理解为一个围栏</strong>，把这些代码给围起来，分为<font color="#dd0000">全局域、局部域、类域、命名空间域</font><br />这里重点介绍一下命名空间</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>C语言中经常会出现命名冲突的现象，变量或函数的名字不能相同，但是在处理项目的时候，不可能互相去确认各自的文件中有没有出现命名冲突的现象，所以引入了<font color="#dd0000">命名空间域的概念</font><br /></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在C&#x2F;C++中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突，使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，<strong>namespace关键字</strong>的出现就是针对这种问题的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std</span><br><span class="line"><span class="comment">//表示打开标准库命名空间 std</span></span><br></pre></td></tr></table></figure><p>每个命名空间都是封锁的，只有打开了才能使用里面的变量及函数，<strong>这解释为什么域可以防止命名冲突的原因</strong></p><p>定义命名空间，需要使用到 namespace 关键字，后面跟命名空间的名字，然后接一对{ }即可，{ }中即为命名空间的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bit</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 命名空间中可以定义变量/函数/类型</span></span><br><span class="line"> <span class="type">int</span> rand = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>值得注意的是</strong>：在 { } 后和结构体不一样，不用加；</p><h4 id="作用域限定符"><a href="#作用域限定符" class="headerlink" title="作用域限定符"></a>作用域限定符</h4><p><strong>::</strong> 是作用域解析运算符，它用于明确指定变量、函数或类型所属的作用域。这个作用域可以是全局作用域、类作用域(后面介绍)或者命名空间作用域</p><p>🚩<strong>访问全局域</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,::a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打印出来是 0 和 1，作用域解析运算符前面是空的就<font color="#dd0000">表示访问全局域的 a</font><br /></p><p>🚩<strong>访问命名空间域</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N::a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里打印出来是 0 和 1 ，作用域解析运算符前面是命名空间的名字就<font color="#dd0000">表示访问命名空间域的 a</font><br /></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>🚩<strong>命名空间的嵌套</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> left + right;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">namespace</span> N2</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> c;</span><br><span class="line">     <span class="type">int</span> d;</span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">Sub</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> left - right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里命名空间 N1 里又嵌套了一个命名空间 N2，这两个命名空间也可以定义同名变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N1::N2::a);</span><br><span class="line"><span class="comment">//访问 N2 的 a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N1::a);</span><br><span class="line"><span class="comment">//访问 N1 的 a</span></span><br></pre></td></tr></table></figure><p>🚩<strong>命名空间的合并</strong>：<br>同一个工程中允许存在多个相同名称的命名空间,编译器最后会合成同一个命名空间中<br>一个工程中的 test.h 和 test.cpp 中两个 N1 会被合并成一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="keyword">namespace</span> N1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> N1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个命名空间会合并，直接把它们两个当成同一个空间使用就行了</p><h3 id="域的使用优先级"><a href="#域的使用优先级" class="headerlink" title="域的使用优先级"></a>域的使用优先级</h3><blockquote><p>优先级：局部域 → 全局域 → 命名空间域</p></blockquote><p>🚩<strong>局部域和全局域</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出 2 ，局部域优先</p><p>🚩<strong>命名空间域</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"></span><br><span class="line">namesapce N</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 2;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出 1 ，只有在<font color="#dd0000">打开命名空间域 or 指定访问命名空间域</font><br /><br>才能访问里面的 a ，打开命名空间域相当于把里面的 a 暴露在全局域里了，所以此时 int a &#x3D; 0 仍然存在的话会造成命名冲突</p><h2 id="输入及输出"><a href="#输入及输出" class="headerlink" title="输入及输出"></a>输入及输出</h2><h3 id="std-命名空间及自定义命名空间"><a href="#std-命名空间及自定义命名空间" class="headerlink" title="std 命名空间及自定义命名空间"></a>std 命名空间及自定义命名空间</h3><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b48a31aebe494414bae831e3ab9c4c7e.png" alt="在这里插入图片描述"><br>一般 C++ 编译器都自带了一些命名空间，这些命名空间里都存放了一些供我们使用的函数，<font color="#dd0000">比如 std 命名空间里有 STL 库和 C++ 标准库</font><br /><br>但这些不足以满足项目开发使用，所以还有些程序员自定义的命名空间</p><p>🔥<strong>值得注意的是</strong>：在项目开发的时候，直接展开命名空间会有风险，我们的定义如果跟库重名就报错了，所以一般用作用域限定符访问自己想用的，但是在学习语法的时候我们一般不会出现这种问题，为了方便使用直接展开就好了</p><h3 id="C-输入-输出"><a href="#C-输入-输出" class="headerlink" title="C++输入&amp;输出"></a>C++输入&amp;输出</h3><blockquote><p>在老版本编译器，如：VC6.0，没有命名空间的概念，引用库头文件还是包含 .h 的，但是随着命名空间的引入，为了和 C 语言区分，引用库头文件写成 #include &lt; iostream &gt;，就是把 .h 去掉了，该头文件包含了输入输出</p></blockquote><p><strong>eg</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// std是C++标准库的命名空间名，C++将标准库的定义实现都放到这个命名空间中</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">// endl 为换行符，相当于 \n ，但 \n 在字符串中使用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩1. 使用cout标准输出对象(控制台)和cin标准输入对象(键盘)时，必须包含&lt; iostream &gt;头文件以及按命名空间使用方法使用std</p><p>🚩2.  cout和cin是全局的流对象，endl是特殊的C++符号，表示换行输出，他们都包含在包含&lt; iostream &gt;头文件中</p><p>🚩3. &lt;&lt;是流插入运算符，&gt;&gt;是流提取运算符</p><p>🚩4. 使用C++输入输出更方便，不需要像printf&#x2F;scanf输入输出时那样，需要手动控制格式，C++的输入输出可以自动识别变量类型</p><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>缺省参数是指在函数声明或定义时为参数指定一个默认值。当调用函数时，如果没有为这个带有缺省参数的参数提供实际的值，函数就会使用默认值</p><h3 id="全缺省"><a href="#全缺省" class="headerlink" title="全缺省"></a>全缺省</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Func1</span>();</span><br><span class="line"><span class="built_in">Func2</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Func1 为10、20、30，Func2 为1、2、3</p><p>• 没有传参时，如果函数在传参的时候无法确定要传的参数的值时，可以使用参数的默认值暂时代替</p><p>• 传参时，使用指定的实参</p><h3 id="半缺省"><a href="#半缺省" class="headerlink" title="半缺省"></a>半缺省</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;a = &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;b = &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Func1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Func2</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">Func3</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Func1 为1、20、30；Func2 为1、2、30；Func3 为1、2、3</p><p>🔥<strong>值得注意的是</strong>：传参必须从左往右传；缺省参数必须从右向左依次设置，也就是说，一个参数如果有缺省值，那么它右边的所有参数都必须有缺省值</p><h3 id="函数声明和定义中的缺省参数"><a href="#函数声明和定义中的缺省参数" class="headerlink" title="函数声明和定义中的缺省参数"></a>函数声明和定义中的缺省参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> a = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意：如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值</span></span><br></pre></td></tr></table></figure><p>所以一般把缺省值放在声明，这样在编译过程中能让程序知道有个默认值能够初始化，在链接阶段才会知道有个能够使用的默认值。放在定义的时候编译阶段就会报错</p><p>🔥<strong>值得注意的是</strong>：缺省值必须是常量或者全局变量，且C语言不支持（编译器不支持）</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/300efafcc91a46e497fa46c9cac28061.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++初阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 开发语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.22——动态内存管理dě查缺补漏</title>
      <link href="/2024/11/23/C%E8%AF%AD%E8%A8%80/vlog22/"/>
      <url>/2024/11/23/C%E8%AF%AD%E8%A8%80/vlog22/</url>
      
        <content type="html"><![CDATA[<p>本篇是对上一篇动态内存管理的总结提升，能够更好地帮助你理解使用动态内存管理😎</p><h1 id="动态内存的魔鬼细节"><a href="#动态内存的魔鬼细节" class="headerlink" title="动态内存的魔鬼细节"></a>动态内存的魔鬼细节</h1><h2 id="对空指针解引用"><a href="#对空指针解引用" class="headerlink" title="对空指针解引用"></a>对空指针解引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX/<span class="number">4</span>);</span><br><span class="line"> *p = <span class="number">20</span>;<span class="comment">//如果p的值是NULL，就会有问题</span></span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>其分配的大小为 INT_MAX&#x2F;4 字节，然而系统可能无法提供如此巨大的内存块以满足分配请求，所以在<strong>系统无法满足分配请求时，malloc 会返回一个空指针</strong>，直接对 *p 进行赋值操作，如果 p 的值是 NULL，那么这个赋值操作就会导致程序出现段错误（访问非法内存地址），即指向不存在的内存</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX / <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在这里添加一些处理内存分配失败的逻辑，比如打印错误信息等</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在内存分配后添加对 p 是否为 NULL 的判断</p><h2 id="动态内存越界访问"><a href="#动态内存越界访问" class="headerlink" title="动态内存越界访问"></a>动态内存越界访问</h2><p>这里先介绍 exit 函数，<strong>用于终止当前正在执行的程序</strong>，EXIT_FAILURE 是一个<strong>预定义的宏</strong>，它通常被定义为一个非零值，当 exit 函数以 EXIT_FAILURE 作为参数被调用时，<strong>这表示程序是以一种错误状态退出的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *(p+i) = i;<span class="comment">//当i是10的时候越界访问</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>通过 malloc 分配的内存空间是用于存储 10 个 int 类型数据的，但是却输入了 11 个整数，当 i 的值达到 10 时，*(p + i) 这个操作就会超出所分配内存空间的边界，<strong>导致越界访问</strong>，可能导致程序出现程序崩溃、数据错误等</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环在有效范围内对所分配内存空间中的元素进行赋值操作</p><h2 id="对非动态内存-free"><a href="#对非动态内存-free" class="headerlink" title="对非动态内存 free"></a>对非动态内存 free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//ok?</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>这里没有开辟动态内存，只是创建了指针变量，并不是说只要是内存都能被 free 释放，free 函数在 C 语言中是用于<strong>释放通过动态内存分配函数</strong>（如 malloc、calloc、realloc 等）分配的内存空间</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 使用完分配的内存后</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 malloc 函数动态分配了能够容纳一个 int 类型数据的内存空间，将其赋值给指针 p，在对该内存进行了必要的操作（如赋值等）之后，再使用 free 函数来释放这块动态分配的内存</p><h2 id="使用-free-只释放一部分动态内存"><a href="#使用-free-只释放一部分动态内存" class="headerlink" title="使用 free 只释放一部分动态内存"></a>使用 free 只释放一部分动态内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> p++;</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>指针 p 进行自增操作（p++），使其不再指向所分配动态内存的起始位置，free 函数要求<strong>传入的指针必须指向通过动态内存分配函数所分配的内存块的起始位置</strong>，当传入不符合要求的指针给 free 函数时，可能会导致程序崩溃、内存泄漏等问题</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> *original_p = p;  <span class="comment">// 保存起始指针</span></span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用p进行其他操作后，当需要释放内存时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(original_p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入一个新的指针 original_p 来保存最初通过 malloc 分配内存时得到的起始指针，在对 p 进行了自增等可能改变其指向的操作之后，当需要释放内存时，就使用 original_p 来调用 free 函数，这样就能正确地释放所分配的动态内存了</p><h2 id="对同一块动态内存多次-free"><a href="#对同一块动态内存多次-free" class="headerlink" title="对同一块动态内存多次 free"></a>对同一块动态内存多次 free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//重复释放</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>p 开辟的动态空间已经被 free 函数释放过一次了，<strong>重复释放</strong>同一块内存是不合法的</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 进行相关操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// 将指针置为NULL，避免后续误操作指向已释放内存的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="忘记-free-动态内存"><a href="#忘记-free-动态内存" class="headerlink" title="忘记 free 动态内存"></a>忘记 free 动态内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line"> &#123;</span><br><span class="line"> *p = <span class="number">20</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> test();</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里进入一个无限循环 while(1)，使得程序在<strong>执行完 test 函数后不会立即退出</strong><br>后续没有对开辟的动态内存进行进一步的有效利用，由于没有调用 free 函数来归还这块动态分配的内存给系统的堆内存管理系统，随着程序的运行，如果<strong>多次调用 test 函数或者类似的函数进行大量的动态内存分配操作而不释放</strong>，就会导致<strong>内存泄漏</strong></p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>!= p)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 完成赋值操作后，释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用 test 函数时，在对动态分配的内存进行赋值操作后，就会及时将这块内存归还给系统的堆内存管理系统，避免了内存泄漏的问题</p><h1 id="动态内存经典试题解析"><a href="#动态内存经典试题解析" class="headerlink" title="动态内存经典试题解析"></a>动态内存经典试题解析</h1><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line"> &#123;</span><br><span class="line"> p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(str);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/81037d25bc1c42e3bd11362e77519de6.png" alt="在这里插入图片描述"></p><blockquote><ol><li>首先创建了指针变量 str ，置为空指针，将 str 作为实参传给形参 p，此时 p 也为空指针，将开辟的 100 个字节的空间地址放在形参 p 中，但是此时是传值调用，在 p 上的操作并没有实际作用在 str 上，所以 <strong>str 依然是空指针</strong></li><li>然后把“hello world” 拷贝到 str 里时，<strong>需要对 str 解引用操作</strong>，向 NULL 指针所指向的空间进行字符串复制操作会导致程序崩溃，产生段错误等未定义行为</li><li>此时最危险的是当函数执行完毕返回时，这个局部变量 p 就会被销毁，<strong>它所指向的刚分配的内存地址也就丢失了</strong>，那么可能会造成内存泄漏</li></ol></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str);</span><br><span class="line">    <span class="keyword">if</span> (str!= <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">free</span>(str);  <span class="comment">// 使用完内存后要记得释放</span></span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建二级指针，实现传址调用，并且在 Test 函数使用完内存后，通过 free 释放所分配的内存，避免内存泄漏，并将 str 重新赋值为 NULL 以防止野指针出现</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> str = GetMemory();</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/768141bdcae2407584b304a47ea7ac78.png" alt="在这里插入图片描述"></p><blockquote><ol><li>当函数GetMemory执行完毕并返回时，其栈帧会被销毁，这也就意味着字符数组 p 所占用的内存空间已经被释放掉了，尽管函数返回了p的地址，但这个<strong>地址所指向的内容已经是无效的了</strong></li><li>调用 GetMemory 函数期望获取一个有效的字符串指针并赋值给str，然后通过 printf 输出该字符串，然而，由于前面提到的 GetMemory 函数返回的<strong>指针指向的是已经被释放的栈内存</strong>，所以在执行 printf(str) 时，就会出现未定义行为</li></ol></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetMemory();</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符数组p定义为静态数组，静态数组在程序的整个生命周期内都存在，不会随着函数的结束而被销毁</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line"> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><blockquote><p>这题和题1修改后的代码基本差不多，最重要的一点就是<strong>没有释放动态内存空间</strong>，导致了<strong>内存泄漏</strong>，即随着程序的运行，不断地分配内存但从不释放，最终耗尽系统的可用内存资源</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line"> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保程序在使用完动态分配的内存后能够及时释放，避免内存泄漏和野指针相关的问题</p><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="built_in">free</span>(str);</span><br><span class="line"> <span class="keyword">if</span>(str != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><blockquote><p>在释放内存之后，紧接着进行了 if(str!&#x3D; NULL) 的判断，这里存在一个误区，虽然直观上感觉释放内存后 str 应该变为 NULL ，但实际上 <strong>free 函数只是释放了 str 所指向的内存块</strong>，并<strong>不会自动将 str 指针本身设置为 NULL</strong>，所以此时 str 指针的值仍然是之前指向的那块已释放内存的地址（虽然<strong>这块内存已经被释放，不能再正常使用了</strong>），即 if 条件依然成立，执行语句导致未定义行为</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (str!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(str);</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配内存用于新的操作</span></span><br><span class="line">        str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (str!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(str);</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放内存后及时将 str 指针设置为 NULL，并且当需要再次进行存储字符串等操作时，重新通过 malloc 分配了新的内存空间，这样可以保证操作的安全性和正确性</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a67638884c24d0fa74b7d3ac065884f.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.21——动态内存管理</title>
      <link href="/2024/11/20/C%E8%AF%AD%E8%A8%80/vlog21/"/>
      <url>/2024/11/20/C%E8%AF%AD%E8%A8%80/vlog21/</url>
      
        <content type="html"><![CDATA[<h1 id="内存的开辟与释放"><a href="#内存的开辟与释放" class="headerlink" title="内存的开辟与释放"></a>内存的开辟与释放</h1><p>过去我们开辟空间的方式有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">20</span>;<span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure><p>但是这种方式存在缺点：</p><blockquote><p>空间开辟大小是固定的数组在申明的时候，必须指定数组的长度，数组空间一旦确定了大小不能调整</p></blockquote><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>malloc 是一种常用的开辟空间的函数，它适用于各种类型的内存开辟。这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8991eda226e4ecb8b9770e569e26de9.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/malloc/?kw=malloc">malloc-C++参考</a></p></blockquote><p><strong>参数</strong>：size-表示需要分配的字节数</p><p><strong>返回值</strong>：返回一个指向所分配内存块起始地址的指针</p><p><strong>值得注意的是</strong>：</p><p>• 如果开辟成功，则返回⼀个指向开辟好空间的指针</p><p>• 如果开辟失败，则返回⼀个 NULL 指针，因此 malloc 的返回值⼀定要做检查</p><p>• 返回值的类型是 void* ，所以 malloc 函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定</p><p>• 如果参数 size 为0，malloc 的行为是标准是未定义的，取决于编译器</p><p><strong>eg</strong>：开辟100个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一般开辟了空间，就要检查该空间是否开辟成功</p><blockquote><p>malloc 或许还可以开辟 INT_MAX 的内存大小，但是在实际运行中，当你试图使用malloc(INT_MAX) 时，几乎肯定会导致内存分配失败，这只是一个理论上存在的值，malloc 函数会返回 NULL ，这是因为系统没有足够的连续空闲内存来满足这样大的请求</p></blockquote><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>malloc 开辟的内存是动态的，也就是说在程序结束时如果不释放的话，会一直占用空间，造成内存泄漏</p><h3 id="为什么要释放内存？"><a href="#为什么要释放内存？" class="headerlink" title="为什么要释放内存？"></a>为什么要释放内存？</h3><p>首先我们要知道什么是<strong>内存泄漏</strong></p><blockquote><p>&#x3D;&#x3D;内存泄漏&#x3D;&#x3D;是指程序动态分配的内存空间在使用完毕后没有被释放，导致这部分内存一直被占用。当程序中存在内存泄漏时，随着程序的运行，被泄漏的内存会不断累积</p></blockquote><p>所以长时间运行的程序，内存泄漏可能会导致系统内存逐渐被耗尽。当系统内存不足时，程序可能会出现性能下降、运行缓慢甚至崩溃的情况</p><h3 id="free的使用"><a href="#free的使用" class="headerlink" title="free的使用"></a>free的使用</h3><p>释放和回收动态内存的函数为 free ，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e3cedf97589c4b49bef07cfae28aed70.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/free/?kw=free">free-C++参考</a></p></blockquote><p><strong>参数</strong>：指向先前使用或分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• 如果参数 ptr 指向的空间不是动态开辟的，那 free 函数的行为是未定义的</p><p>• 如果参数 ptr 是 NULL 指针，则函数什么事都不做</p><p>• free 的内存释放可以理解为这块内存的使用权被取消掉了，而内存的回收销毁是栈实现的</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"> <span class="type">int</span> arr[num] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line"> ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != ptr)<span class="comment">//判断ptr指针是否为空</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *(ptr+i) = <span class="number">0</span>；</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(ptr);<span class="comment">//释放ptr所指向的动态内存</span></span><br><span class="line"> ptr = <span class="literal">NULL</span>;<span class="comment">//是否有必要？</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptr &#x3D; NULL 是有必要的，此时的 ptr 仍然指向该内存，但是这个内存已经被释放了，如果后续代码中错误地访问*p（比如试图修改或读取这个已经释放的内存空间中的值），就会导致程序出现未定义行为，可能会出现程序崩溃、数据错误等情况</p><h1 id="内存的初始化和修改"><a href="#内存的初始化和修改" class="headerlink" title="内存的初始化和修改"></a>内存的初始化和修改</h1><blockquote><p>malloc 提供的功能是开辟内存空间，万一我们想要增加使用的空间，可以再次使用 malloc开辟空间，但这又得创建一个变量存储，释放空间就要多次释放，这不免容易忘记，而且多次使用 malloc 开辟的空间通常是不连续的，哪里有空间他就在哪里开辟，那么就需要 realloc 函数提供修改动态空间的功能了</p></blockquote><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>calloc 函数也用来动态内存分配，但是它可以初始化动态内存的内容，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3a4d4b3825b44b42b291abef68e8c178.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/calloc/?kw=calloc">calloc-C++参考</a></p></blockquote><p><strong>参数</strong>：num-元素个数，size-元素大小</p><p><strong>返回值</strong>：指向函数分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为 0</p><p>• 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全 0</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line"> &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> p = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的内容为 10 个 0，证明 calloc 确实初始化开辟的空间为 0</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>realloc函数的出现让动态内存管理更加灵活，可以修改原先开辟的动态内存，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ad8ced63e2ef4b18a65528097595d2dd.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/realloc/?kw=realloc">realloc-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr-指向先前使用或分配的内存块的指针，size-元素大小</p><p><strong>返回值</strong>：指向重新分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• ptr 是要调整的内存地址</p><p>• size 调整之后新大小(包含原来的大小)</p><p>• 返回值为调整之后的内存起始位置</p><p>• 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间</p><p>• realloc 在调整内存空间的是存在<strong>两种情况</strong>：</p><p> <strong>情况1</strong>：原有空间之后有足够大的空间</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a38d5e3054c40538318ad79e152d35e.png" alt="在这里插入图片描述"><br>直接在原有空间后面加上新的空间</p><p> <strong>情况2</strong>：原有空间之后没有足够大的空间<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c4be8f8576b2465ebe685d5de1e290c5.png" alt="在这里插入图片描述"><br>如果后续空间不够， realloc 函数直接在内存的堆区找一块新的满足大小的空间，将旧的数据拷贝到新的空间，原来的空间则自动释放，返回新的地址</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码1 - 直接将realloc的返回值放到ptr中</span></span><br><span class="line">ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">1000</span>);<span class="comment">//这样可以吗？(如果申请失败会如何？)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2 - 先将realloc函数的返回值放在p中，不为NULL，在放ptr中</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">p = <span class="built_in">realloc</span>(ptr, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptr = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码1</strong>：</p><blockquote><p>如果内存重新<strong>分配失败</strong>（例如，系统没有足够的连续内存来满足 1000 个 int 类型数据的内存需求），realloc 函数会返回 NULL，但这里的问题是，当它返回 NULL 时，<strong>原始的 ptr 所指向的内存块已经被释放</strong>（因为 realloc 在尝试重新分配失败时，会释放掉原始的内存块以避免内存泄漏），这就导致 ptr 变为 NULL，并且之前通过 <strong>ptr 可访问的原始数据也丢失了</strong>，后续若再尝试使用 ptr 就会导致程序出错</p></blockquote><p><strong>代码2</strong>：</p><blockquote><ol><li>先将 realloc 函数的返回值赋给 p ，然后进行判断的做法<strong>更为稳妥</strong>，同样执行 p &#x3D; realloc(ptr, 1000)，当重新分配成功时，通过判断 p!&#x3D; NULL 能确认重新分配成功，然后再将 p 的值赋给 ptr，使得 ptr 正确<strong>指向新的内存块</strong></li><li>如果重新<strong>分配失败</strong>，realloc 会返回 NULL，此时 p 为 NULL，由于没有直接将 NULL 赋给 ptr，所以 ptr <strong>仍然指向原来的内存块</strong>（前提是原来的内存块还未被 realloc 释放，在这种情况下，原来的内存块未被释放是因为重新分配失败后没有进行释放原始内存块的操作），这样就可以<strong>避免丢失原始数据以及出现空指针错误</strong></li></ol></blockquote><h1 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h1><h2 id="什么是柔性数组？优势是什么？"><a href="#什么是柔性数组？优势是什么？" class="headerlink" title="什么是柔性数组？优势是什么？"></a>什么是柔性数组？优势是什么？</h2><blockquote><p>柔性数组是 C99 标准中引入的一个特性，它是在一个结构体的最后一个成员位置定义的数组，并且这个数组的大小是可以灵活变化的，大小是未知的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个结构体my_struct中，data就是一个柔性数组</p><p><strong>值得注意的是</strong>：</p><p>• 结构中的柔性数组成员前面<strong>必须至少一个其他成员</strong></p><p>• sizeof 返回的这种结构大小<strong>不包括柔性数组的内存</strong></p><p>• 包含柔性数组成员的结构用 malloc () 函数进行内存的动态分配，并且<strong>分配的内存应该大于结构的大小</strong>，以适应柔性数组的预期大小</p><h2 id="柔性数组的使用"><a href="#柔性数组的使用" class="headerlink" title="柔性数组的使用"></a>柔性数组的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">0</span>];<span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> type_a *p = (type_a*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> p-&gt;i = <span class="number">100</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> p-&gt;a[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次将 i 的值赋值给柔性数组，柔性数组能被赋多少，那他的空间一般就为多少，这样柔性数组成员 a，相当于获得了 100 个整型元素的连续空间</p><p>但是不提倡在结构体里进行内存的二次分配，用户调用 free 可以释放结构体，但是用户并不知道这个结构体内的成员也需要 free，所以你不能指望用户来发现这个事</p><h1 id="C-C-内存分配"><a href="#C-C-内存分配" class="headerlink" title="C&#x2F;C++内存分配"></a>C&#x2F;C++内存分配</h1><p>以一段代码做例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">5</span>] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">char</span> *sh = <span class="string">&quot;zxcv&quot;</span></span><br><span class="line"><span class="type">int</span> *ptr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> *ptr2 = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *ptr3 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般程序中内存区域划分为：</p><ol><li><p><strong>内核空间（用户代码不能读写）</strong></p></li><li><p><strong>栈（向下增长）</strong>：<br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放，栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限，<strong>栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] ,<span class="type">char</span> ch[<span class="number">5</span>] ,<span class="type">char</span> *sh </span><br><span class="line"><span class="type">int</span> *ptr1 ,<span class="type">int</span> *ptr2 ,<span class="type">int</span> *ptr3 </span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>内存映射段（文件映射、动态库、匿名映射）</strong></p></li><li><p><strong>堆（向上增长）</strong>：<br>⼀般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方<br>式类似于链表，<strong>堆区主要存放动态开辟的内存空间等</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">(<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">(<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>数据段（全局数据、静态数据）</strong></li></ol><p>（static）<strong>存放全局变量、静态数据</strong>，程序结束后由系统释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num , <span class="type">static</span> <span class="type">int</span> ret</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>代码段（可执行代码&#x2F;只读常量）</strong></li></ol><p>存放函数体（类成员函数和全局函数）的<strong>二进制代码</strong></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b770db5fe7fe458db493a3056649c243.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.20——自定义类型：联合&amp;&amp;枚举</title>
      <link href="/2024/11/17/C%E8%AF%AD%E8%A8%80/vlog20/"/>
      <url>/2024/11/17/C%E8%AF%AD%E8%A8%80/vlog20/</url>
      
        <content type="html"><![CDATA[<h1 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h1><p><strong>什么是联合体？</strong>联合体也称<strong>共用体</strong>，顾名思义，共用共用就有节省空间的意思，它允许在相同的内存位置存储不同的数据类型，就是个<strong>缩小内存的结构体</strong></p><h2 id="联合体的声明及定义"><a href="#联合体的声明及定义" class="headerlink" title="联合体的声明及定义"></a>联合体的声明及定义</h2><p>联合体的声明，定义与结构体相同，只是类型不同，<strong>其语法形式为</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>声明就是去掉 variable-list ，保留剩下的，可以在结构体上定义，也可以另起一行定义对象<br>上一篇结构体声明与定义有详细介绍</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143783658?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.19——自定义类型：结构体</a></p></blockquote><p>联合体的<strong>初始化</strong>也有<strong>特殊之处</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//联合类型的声明</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//联合变量的定义</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un1</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un2</span> =</span> &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, un1.i); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, un2.i); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照联合体初始化规则，<strong>初始化赋值时将值赋给第一个成员</strong></p><blockquote><ol><li>&#x3D;&#x3D;<strong>赋值为 0 的情况</strong>&#x3D;&#x3D;：这是一种特殊情况，通常情况下只会将初始化的值赋给第一个变量，但是初始化为 0 在编译器的角度下是一种自然状态，编译器会将这个全 0 的状态自然地扩展到整个联合体的内存空间。这就好比在一个容器中倒入了无色无味的清水，清水会自然地填满整个容器。所以整个 un1 结构体都初始化为 0，<strong>即 un1.i &#x3D; 0</strong></li><li>&#x3D;&#x3D;<strong>赋值为其他值的情况</strong>&#x3D;&#x3D;：当用 ‘a’ 初始化联合体的第一个成员（如 char 类型）时，只会将 ‘a’ 的 ASCII 码值 97 存储在第一个成员对应的内存位置（即将 01100001 存在字符 c 中）<br>那如果用个很大的数，比如 9999 ，对于 9999 的二进制表示 00000000 00000000 00100111 00011111，实际存储到 c 中的就是 00011111，所以其余 3 个字节是未初始化的垃圾数据，如果访问整型 i 得到的结果是不可预测的，<strong>即 un2.i &#x3D; 随机值</strong></li></ol></blockquote><h2 id="联合体的内存计算"><a href="#联合体的内存计算" class="headerlink" title="联合体的内存计算"></a>联合体的内存计算</h2><p>联合体与结构体最大的不同就是不会浪费内存，尽可能节省空间，这样⼀个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d32d2c1b27264304a975bc895b87796c.jpeg" alt="请添加图片描述"><br><strong>代码1 输出</strong>：001BC63F、001BC63F、001BC63F<br><strong>代码2 输出</strong>：11223355</p><p>不难发现联合体的部分或整体地址都一样，整型 i 的数据被字符 c 覆盖，这是为什么呢？</p><blockquote><p>地址从高到低存放 44332211 ，而联合体是共用空间的，所以把 55 覆盖在 44上。有人就会有疑惑了，为什么不是地址从低到高存放 44332211，把 55 覆盖在 11上，这就和数据的字节存储方式有关了，马上就会介绍到。<br>言归正传，把字符 c 覆盖在 整型 i 上，i 就无法使用了，所以联合体就是一种能够使用多种类型的集合体，但每次想要使用就要对要使用的值赋值，覆盖之前的数据，使想要的数据有完整的值，处于能正常访问的状态</p></blockquote><p><strong>那么联合体的大小究竟如何计算呢？</strong></p><p>• 联合的大小至少是最大成员的大小<br>• 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</p><h2 id="1-3-联合体和结构体比较"><a href="#1-3-联合体和结构体比较" class="headerlink" title="1.3 联合体和结构体比较"></a>1.3 联合体和结构体比较</h2><p>对比结构体和联合体的空间存储情况就能清楚地知道为什么联合体能节省空间了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">S</span>//<span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;<span class="comment">//struct S s = &#123;0&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>分别在空间中的存储情况</strong>：<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f119066238e941a0bc3fedd930634dc8.png" alt="在这里插入图片描述"><br>黄色部分是浪费的空间，明显结构体为了能完整存储每个变量，会采取空间换时间的方式</p><h2 id="大小端介绍"><a href="#大小端介绍" class="headerlink" title="大小端介绍"></a>大小端介绍</h2><p><strong>什么是大小端？</strong></p><blockquote><ol><li>大端也叫大端序或大字节序，数据的高位字节存于低地址，低位字节存于高地址</li><li>叫小端序或小字节序，与大端相反，数据的低位字节存于低地址，高位字节存于高地址</li></ol></blockquote><p>这就可以解答我们上面的疑惑了，”地址从低到高存放 44332211，把 55 覆盖在 11上” 是因为机器采用了小端存储的方式，不同的机器的存储方式各有不同，根据其所处的环境和需求决定</p><p><strong>如何通过代码判断大小端？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> &#125;un;</span><br><span class="line"> un.i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> un.c;<span class="comment">//返回1是⼩端，返回0是⼤端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合体的应用"><a href="#联合体的应用" class="headerlink" title="联合体的应用"></a>联合体的应用</h2><p>比如，我们要搞⼀个活动，要上线一个礼品兑换单<br>礼品兑换单中有三种商品：图书、杯子、衬衫<br>每一种商品都有：库存量、价格、商品类型和商品类型<strong>相关的其他信息</strong></p><blockquote><ol><li>图书：书名、作者、页数</li><li>杯子：设计</li><li>衬衫：设计、可选颜色、可选尺寸</li></ol></blockquote><p>如果使用结构体就要把所有物品，不论是公共属性，还是特殊属性都要表示出来<br>如果使用结构体就可以把特殊属性作为结构体放在联合体里，要用哪个就赋值哪个，能省下不少空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gift_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> stock_number;<span class="comment">//库存量</span></span><br><span class="line"> <span class="type">double</span> price; <span class="comment">//定价</span></span><br><span class="line"> <span class="type">int</span> item_type;<span class="comment">//商品类型</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> title[<span class="number">20</span>];<span class="comment">//书名</span></span><br><span class="line"> <span class="type">char</span> author[<span class="number">20</span>];<span class="comment">//作者</span></span><br><span class="line"> <span class="type">int</span> num_pages;<span class="comment">//⻚数</span></span><br><span class="line"> &#125;book;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> design[<span class="number">30</span>];<span class="comment">//设计</span></span><br><span class="line"> &#125;mug;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> design[<span class="number">30</span>];<span class="comment">//设计</span></span><br><span class="line"> <span class="type">int</span> colors;<span class="comment">//颜⾊</span></span><br><span class="line"> <span class="type">int</span> sizes;<span class="comment">//尺⼨</span></span><br><span class="line"> &#125;shirt;</span><br><span class="line"> &#125;item;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><strong>什么是枚举？</strong>枚举用于定义一组命名的常量，例如，在一个表示星期的程序中，我们可以定义一个枚举类型来代表一周的七天，而不是使用数字 0 - 6 来分别表示星期一到星期日</p><h2 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h2><p><strong>表示星期</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>//星期</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Mon,</span><br><span class="line"> Tues,</span><br><span class="line"> Wed,</span><br><span class="line"> Thur,</span><br><span class="line"> Fri,</span><br><span class="line"> Sat,</span><br><span class="line"> Sun</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>表示颜色</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>//颜⾊</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> RED,</span><br><span class="line"> GREEN,</span><br><span class="line"> BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>{}中的内容是枚举类型的可能取值，也叫 枚举常量，这些可能取值都是有值的，默认从0开始，依次递增1，当然在声明枚举类型的时候也可以赋初值</p></blockquote><p>比如颜色枚举常量，从上到下默认为RED、GREEN、BLUE赋值0、1、2</p><p><strong>为什么非要用枚举常量，用宏定义(#define)不也可以吗？</strong></p><p>• 增加代码的可读性和可维护性</p><p>• 和 #define 定义的标识符比较枚举有类型检查，更加严谨</p><p>• 便于调试，预处理阶段会删除 #define 定义的符号</p><p>• 使用方便，一次可以定义多个常量</p><p>• 枚举常量是遵循作用域规则的，枚举声明在函数内，只能在函数内使用</p><blockquote><p>这里只要知道枚举常量在各种意义上来说，表示一系列常量时是优于宏定义，关于预处理阶段的宏定义，会在后续进行详细介绍</p></blockquote><h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>//颜⾊</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> RED=<span class="number">1</span>,</span><br><span class="line"> GREEN=<span class="number">2</span>,</span><br><span class="line"> BLUE=<span class="number">4</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="title">clr</span> =</span> GREEN;</span><br></pre></td></tr></table></figure><p>枚举量可以作为常量给变量赋值，这里提醒一下，在 switch 语句中，case 后面也可以接枚举量，这能使代码的可读性更高</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0ecf2d4f72c40e6ba7a4442ede0bd8b.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.19——自定义类型：结构体</title>
      <link href="/2024/11/15/C%E8%AF%AD%E8%A8%80/vlog19/"/>
      <url>/2024/11/15/C%E8%AF%AD%E8%A8%80/vlog19/</url>
      
        <content type="html"><![CDATA[<p>前面在学习操作符的时候，已经对结构体有了初步了解，结构体不仅在C语言中经常使用，也为C++学习类和对象打下基础，本篇 vlog 将对结构体进行详细的解析</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143237196?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.10——进制转化&amp;&amp;操作符进阶</a></p></blockquote><h1 id="结构体的声明与初始化"><a href="#结构体的声明与初始化" class="headerlink" title="结构体的声明与初始化"></a>结构体的声明与初始化</h1><p>数组用于存放同类型的数据，而结构体是用于存放不同类型变量的函数的集合</p><p><strong>其语法形式为</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="普通声明"><a href="#普通声明" class="headerlink" title="普通声明"></a>普通声明</h2><p>比如我们想要描述一个学生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"> <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"> <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号</span></span><br><span class="line">&#125;; <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure><p>声明只需要写出返回类型，参数，函数名<br>返回类型是 struct ，参数是学生的信息，函数名是 Stu</p><h2 id="创建及初始化"><a href="#创建及初始化" class="headerlink" title="创建及初始化"></a>创建及初始化</h2><p>struct 是一种自定义类型，那么就规定需要为其<strong>创建对象</strong>，那么如何理解对象呢？</p><blockquote><p>假设类是一个大房子，struct 就是房子的类型，Stu就是房子的名字，房子里入住的人就是对象，对象能够在同一种类中，但是他们的个人信息可以不同</p></blockquote><p><strong>初始化的方式有两种</strong>：</p><p>1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"> <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"> <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号</span></span><br><span class="line">&#125;s1，s2;</span><br></pre></td></tr></table></figure><p>在 variable-list 处写出对象名</p><p>2）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//按照结构体成员的顺序初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;20230818001&quot;</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, s.name);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;age : %d\n&quot;</span>, s.age);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sex : %s\n&quot;</span>, s.sex);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;id : %s\n&quot;</span>, s.id);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//按照指定的顺序初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s2</span> =</span> &#123; .age = <span class="number">18</span>, .name = <span class="string">&quot;lisi&quot;</span>, .id = <span class="string">&quot;20230818002&quot;</span>, .sex = </span><br><span class="line"><span class="string">&quot;⼥&quot;</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, s2.name);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;age : %d\n&quot;</span>, s2.age);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sex : %s\n&quot;</span>, s2.sex);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;id : %s\n&quot;</span>, s2.id);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在结构体外创建对象，根据之前讲过的操作符，可以按结构体的默认顺序来初始化，也可以用结构体成员访问操作符直接或间接访问，这里不涉及指针，所以不用 -&gt;</p><h2 id="特殊声明"><a href="#特殊声明" class="headerlink" title="特殊声明"></a>特殊声明</h2><p>声明结构体可以不完全声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">float</span> c;</span><br><span class="line">&#125;x;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">float</span> c;</span><br><span class="line">&#125;a[<span class="number">20</span>], *p;</span><br></pre></td></tr></table></figure><p>这两个结构体省略了函数名，编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的，匿名的结构体类型，如果没有对结构体类型重命名的话，基本上只能使用一次</p><h2 id="结构体的自引用"><a href="#结构体的自引用" class="headerlink" title="结构体的自引用"></a>结构体的自引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码是错误的</p><blockquote><p>要确定一个 struct Node 实例的大小，就需要先确定它内部成员 next 的大小（因为结构体成员是依次排列在内存中的），但 next 本身又是 struct Node 类型，要确定它的大小又得先确定它内部 next 的大小…… 这样就陷入了无限循环的困境，编译器无法准确计算出 struct Node 结构体到底应该占用多少内存空间，所以这种写法在内存布局上就是不合理且无法实现的</p></blockquote><p><strong>修改后</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过让 next 指针指向另一个 Node 结构体，就可以实现数据元素之间的链式存储关系</p><p><strong>那如果夹杂了 typedef 对匿名结构体类型重命名呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>答案是错误的，他在对 struct 重命名完成之前就在内部使用了重命名后的名字</p><h1 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h1><p>那么结构体的大小该如何计算呢？<br>这也是近几年面试题竞赛题常考的点</p><h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><blockquote><ol><li>结构体的第⼀个成员对齐到和结构体变量起始位置<strong>偏移量为 0 的地址处</strong></li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的<strong>地址处</strong><br>• <strong>对齐数</strong> &#x3D; 编译器默认的⼀个对齐数与该成员变量大小的<strong>较小值</strong><br> • VS 中<strong>默认的值为 8</strong>（可修改）<br> • Linux中 gcc 没有默认对齐数，对齐数就是成员自身的大小</li><li>结构体总大小为<strong>最大对齐数</strong>（结构体中每个成员变量都有⼀个对齐数，所有对齐数中最大的）<strong>的整数倍</strong></li><li>如果嵌套了结构体的情况，<strong>嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处</strong>，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍</li></ol></blockquote><p>是不是看的感觉有些迷糊？举个例子你就明白了</p><p><strong>代码1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br></pre></td></tr></table></figure><p>本题的答案是 12</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b5f6049dbe104dfd842a479de49a4b73.png" alt="在这里插入图片描述"></p><blockquote><p>刚开始 c1 对其到地址为 0 处，然后比较 i 和 8 发现 i 小，所以这里对齐数为 4 ，所以在 4 的尽可能最小倍数处对齐，即地址为 4 处，同理 c2 与 8比较发现 c2 小，所以这里对齐数为 1，所以在 1 的尽可能最小倍数处对齐，则总体大小为最大对齐数的尽可能最小倍数，即最大对齐数为 4，则总体大小为 12</p></blockquote><p><strong>代码2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">s1</span>;</span></span><br><span class="line"> <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S4));</span><br></pre></td></tr></table></figure><p>答案是 24</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ff487e10e97c47c4ac0fc2b1b4cb3349.png" alt="在这里插入图片描述"></p><p>这里说一下 struct S1 的最大对齐数为 4 ，大小为 12 ，其他都与代码 1 的处理方式同理</p><h2 id="结构体对齐存在的重要性"><a href="#结构体对齐存在的重要性" class="headerlink" title="结构体对齐存在的重要性"></a>结构体对齐存在的重要性</h2><p>结构体的内存对齐是拿空间来换取时间的做法</p><h3 id="平台原因"><a href="#平台原因" class="headerlink" title="平台原因"></a>平台原因</h3><blockquote><p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p></blockquote><h3 id="性能原因"><a href="#性能原因" class="headerlink" title="性能原因"></a>性能原因</h3><blockquote><p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐，原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要⼀次访问，假设⼀个处理器总是从内存中取8个字节，则地址必须是8的倍数，如果我们能保证将所有的 double 类型的数据的地址都对齐成8的倍数，那么就可以用⼀个内存操作来读或者写值了，否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中</p></blockquote><p>比如刚才的代码1</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e97ac5cd06e94ef0b2efcbbe9792c0fe.png" alt="在这里插入图片描述"><br>如果没有内存对齐，假设一个机器是 4 位读取，那么 int i 就需要分两次才能得到这个数据，或许你觉得这没什么，但是在大型的项目的数据里，这种方式是十分低效率的，按照对齐规排序能够保证读取能够读取一个完整数据</p><h2 id="修改默认对齐数"><a href="#修改默认对齐数" class="headerlink" title="修改默认对齐数"></a>修改默认对齐数</h2><p>结构体在对齐方式不合适的时候，我们可以自己更改默认对齐数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">//设置默认对⻬数为1</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的对⻬数，还原为默认</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//输出的结果是什么？</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#pragma 这个预处理指令，可以改变编译器的默认对齐数</p><h1 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ps)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> print1(s); <span class="comment">//传结构体</span></span><br><span class="line"> print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过我前面介绍传值调用和传址调用的uu们应该知道，传地址的效果明显好很多</p><p><strong>原因</strong>：</p><p> • 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销<br> • 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导 致性能的下降</p><h1 id="位段的实现"><a href="#位段的实现" class="headerlink" title="位段的实现"></a>位段的实现</h1><h2 id="什么是位段"><a href="#什么是位段" class="headerlink" title="什么是位段"></a>什么是位段</h2><p>位段的声明和结构与结构体类似</p><p><strong>不同的是</strong>：</p><ol><li>位段的成员必须是 int、unsigned int 或signed int ，在C99中位段成员的类型也可以选择其他类型</li><li>位段的成员名后边有一个冒号和一个数字</li></ol><p><strong>举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> _a:<span class="number">2</span>;</span><br><span class="line"> <span class="type">int</span> _b:<span class="number">5</span>;</span><br><span class="line"> <span class="type">int</span> _c:<span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 A 就是一种位段，后面的数字表示其所占的位数，单位是比特<br>可是一个 int 类型所占的比特位不应该是32位吗？</p><h2 id="位段的内存分配"><a href="#位段的内存分配" class="headerlink" title="位段的内存分配"></a>位段的内存分配</h2><p>位段的内存分配准确来说和结构体内存分配不同的地方在于位段尽可能压缩了内存的占用，但其局限性在于限制了比特位，只能输出特定范围的数据</p><blockquote><ol><li>位段的成员可以是 int unsigned int signed int 或者是 char 等类型</li><li>位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li></ol></blockquote><p><strong>举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> a:<span class="number">3</span>;</span><br><span class="line"> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line"> <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line"> <span class="type">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">s.a = <span class="number">10</span>;</span><br><span class="line">s.b = <span class="number">12</span>;</span><br><span class="line">s.c = <span class="number">3</span>;</span><br><span class="line">s.d = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>这里设置 a b c d 的内存占用比特位为 3 4 5 4（注意不要将其误认为初始化），为这几个数赋值 10 12 3 4<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d42b11c04e9648debc09dd4e5dfc9ea4.png" alt="在这里插入图片描述"></p><p>VS2013测试数据：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ed325a1e2d645a0887a6f49da2d0d0f.png" alt="VS2013测试数据"></p><p>由分析可得，冒号后的位数表示占用比特位，放进去的数由于位数的限制，会导致其只能输出限制位所能表达的二进制数</p><h2 id="位段的跨平台问题"><a href="#位段的跨平台问题" class="headerlink" title="位段的跨平台问题"></a>位段的跨平台问题</h2><blockquote><ol><li>int 位段被当成有符号数还是无符号数是不确定的</li><li>位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题</li><li>位段中的成员在内存中从左向右分配，还是从右向左分配，标准尚未定义</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的</li></ol></blockquote><p>所以跟结构体相比，位段能够起到很好的节省空间的效果，但是其平台移植性差，其他的机器不一定能够适应其结构</p><h2 id="4-4位段的使用"><a href="#4-4位段的使用" class="headerlink" title="4.4位段的使用"></a>4.4位段的使用</h2><p>首先我们要知道内存中每个字节分配一个地址，一个字节内部的 bit 位是没有地址的，而位段的地址不在某个字节处，所以我们不能在 scanf 函数中使用 &amp; 进行取地址赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> _a : <span class="number">2</span>;</span><br><span class="line"> <span class="type">int</span> _b : <span class="number">5</span>;</span><br><span class="line"> <span class="type">int</span> _c : <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> _d : <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">sa</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sa._b);<span class="comment">//这是错误的</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//正确的⽰范</span></span><br><span class="line"> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line"> sa._b = b;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法是先对某一个变量进行初始化赋值，然后再将该变量赋值给位段，进行二进制位数的处理，从而达到位段的效果</p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=rjfiwit5a9zh">https://cloud.tencent.com/developer/support-plan?invite_code=rjfiwit5a9zh</a></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aa3ce00fb59849e7b76f5acb6b510772.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.18——内存函数</title>
      <link href="/2024/11/13/C%E8%AF%AD%E8%A8%80/vlog18/"/>
      <url>/2024/11/13/C%E8%AF%AD%E8%A8%80/vlog18/</url>
      
        <content type="html"><![CDATA[<h1 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h1><p><strong>memcpy</strong> 主要用于将一段内存中的数据完整地复制到另一段内存中，在很多场景下都非常有用，例如在处理数组、结构体等数据结构时，从源内存地址 src 复制 n 个字节的数据到目标内存地址 destination</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/195affa979924dcb84ca89d8c09a2d71.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memcpy/?kw=memcpy">memcpy-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-目标内存地址，它是一个 void* 类型的指针，source-源内存地址，同样是 void* 类型(不可修改)，num-要复制的字节数</p><p><strong>返回值</strong>：返回指向目标内存地址 destination 的指针</p><p><strong>值得注意的是</strong>：函数 memcpy 从 source 的位置开始向后复制 num 个字节的数据 destination 指向的内存位置，这个函数在遇到 ‘\0’ 的时候并不会停下来，如果 source 和destination 有任何的重叠，复制的结果都是未定义的</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>memcpy 函数将 src 数组中的字符串（包括字符串结束符 \0 ）复制到 dest 数组中 strlen(src)+1 是为了把 \0 也复制过去</p></blockquote><p><strong>memcpy 的模拟实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ret = dst;</span><br><span class="line">assert(dst);</span><br><span class="line">assert(src);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* copy from lower addresses to higher addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将dst和src先强制转换为char*类型，实现了以字节为单位的访问和赋值操作，因为 char类型在内存中占用一个字节，所以这样可以逐个字节地复制数据，而不管原始数据的类型是什么，分别将目标地址 dst 和源地址 src 向后移动一个字节的位置，以便在下一次循环中复制下一个字节的数据</p></blockquote><h1 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h1><p><strong>memmove</strong> 和 memcpy 类似，也是从源内存地址 source 复制 num 个字节的数据到目标内存地址destination ，但是 memmove 函数<strong>能够处理源内存区域和目标内存区域重叠的情况</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/578a0946815a4ea0b1c3743968fdeab8.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memmove/?kw=memmove">memmove-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-目标内存地址，它是一个 void* 类型的指针，source-源内存地址，同样是 void* 类型(不可修改)，num-要复制的字节数</p><p><strong>返回值</strong>：返回指向目标内存地址 destination 的指针</p><p><strong>值得注意的是</strong>：和 memcpy 的差别就是 memmove 函数处理的源内存块和目标内存块是可以重叠的，如果源空间和目标空间出现重叠，就得使用 memmove 函数处理</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串中的后3个字符向前移动2个位置</span></span><br><span class="line">    memmove(str + <span class="number">2</span>, str + <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str + 3 是源地址，str + 2 是目标地址，存在重叠部分，memmove 函数可以正确地完成复制操作，而 memcpy 函数不能完成有重叠的操作</p><p><strong>mememove 的模拟实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ret = dst;</span><br><span class="line"><span class="keyword">if</span> (dst &lt;= src || (<span class="type">char</span>*)dst &gt;= ((<span class="type">char</span>*)src + count)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Non-Overlapping Buffers</span></span><br><span class="line"><span class="comment">* copy from lower addresses to higher addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Overlapping Buffers</span></span><br><span class="line"><span class="comment">* copy from higher addresses to lower addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dst = (<span class="type">char</span>*)dst + count - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先判断源内存区域和目标内存区域是否有重叠情况，然后就是分为非重叠和重叠的情况和 memcpy 模拟实现类似的操作</p></blockquote><h1 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h1><p>memset 能将指定内存区域 ptr 的前 num 个字节<strong>设置为指定的值 value</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fa7d76805e8a4a30b7ccc34a335d7a97.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memset/?kw=memset">memset-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr-要设置的内存区域的起始地址，是 void* 类型，value-要设置的值，这个值会被转换为 unsigned char 类型后进行设置，num-要设置的字节数</p><p><strong>返回值</strong>：返回指向设置后的内存区域 ptr 的指针</p><p><strong>值得注意的是</strong>：设置完内容后，记得在后面加上 \0</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    buffer[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memset 将 buffer 数组的前 5 个字节设置为字符A，然后手动添加字符串结束符 \0 ，以便能够正确地使用 printf 输出字符串</p><h1 id="memcmp函数"><a href="#memcmp函数" class="headerlink" title="memcmp函数"></a>memcmp函数</h1><p>memcmp 用于<strong>比较两个内存区域</strong> ptr1 和 ptr2 的前 num 个字节<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/87ad2ce236224c7688ee9ce5d6c911f6.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memcmp/?kw=memcmp">memcmp-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr1、ptr2-要比较的两个内存区域的起始地址，都是 const void* 类型，num-要比较的字节数</p><p><strong>返回值</strong>：<br>• 如果 ptr1 所指向的内存区域的前 num 个字节大于 ptr2 所指向的内存区域的前 num 个字节，返回一个大于 0 的值<br>• 如果 ptr1 所指向的内存区域的前 num 个字节小于 ptr2 所指向的内存区域的前 num 个字节，返回一个小于 0 的值<br>• 如果 ptr1 所指向的内存区域的前 num 个字节等于 ptr2 所指向的内存区域的前 num 个字节，返回 0</p><p><strong>值得注意的是</strong>：比较从 ptr1 和 ptr2 指针指向的位置开始，向后的 num 个字节，遇到第一个不一样的比较就行了</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;abd&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">memcmp</span>(str1, str2, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memcmp 比较 str1 和 str2 的前 3 个字节，因为 c 的 ASCII 码小于 d 的 ASCII 码，所以返回一个小于 0 的值 </p><p>以上就是主要使用的内存函数，过几天就参加全国计挑了，希望可以拿个奖，没拿到就当练手了吧，毕竟竞赛经验更重要🤩</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ee65acb7681b439fbf6fef55b8ae83c4.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.17——字符函数&amp;&amp;字符串函数</title>
      <link href="/2024/11/11/C%E8%AF%AD%E8%A8%80/vlog17/"/>
      <url>/2024/11/11/C%E8%AF%AD%E8%A8%80/vlog17/</url>
      
        <content type="html"><![CDATA[<h1 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h1><blockquote><p>字符函数通常是针对单个字符进行操作的函数，它们接受一个字符作为参数，并返回与该字符相关的某种属性或经过特定处理后的结果</p></blockquote><h2 id="字符分类函数"><a href="#字符分类函数" class="headerlink" title="字符分类函数"></a>字符分类函数</h2><p>此类函数主要用于字符的分类，需要包含头文件 &#x3D;&#x3D;#include &lt;ctype.h&gt;&#x3D;&#x3D;<br>以下介绍一个常用的字符分类函数</p><h3 id="islower"><a href="#islower" class="headerlink" title="islower"></a>islower</h3><p>islower 用于检查字符是否为小写字母， isupper 作用与其相反<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b09e05f80aea46358ace61baf971e31d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cctype/islower/?kw=islower">islower-C++参考</a></p></blockquote><p><strong>参数</strong>：要检查的参数，即大小写字母</p><p><strong>返回值</strong>：如果 c 确实是小写字母，则该值不为零（即 true），否则为 0（即 false）</p><p>举个例子：将字符串中的小写字母都转成大写字母，其他字符不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Test String.\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (str[i])</span><br><span class="line">&#123;</span><br><span class="line">c = str[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">islower</span>(c))</span><br><span class="line">c -= <span class="number">32</span>; </span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符转换函数"><a href="#字符转换函数" class="headerlink" title="字符转换函数"></a>字符转换函数</h2><p>此类函数主要用于字符的转换，需要包含头文件 &#x3D;&#x3D;#include &lt;ctype.h&gt;&#x3D;&#x3D;<br>以下介绍一个常用的字符转换函数</p><h3 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a>tolower</h3><p>tolower 用于将参数传进去的大写字母转小写，与 islower 不同的是，islower 只是判断，tolower是直接转换。toupper 用于将参数传进去的小写字母转大写，与 tolower 同理<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8dfd76c988c4f6dbe2c20b2558b916b.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cctype/tolower/?kw=tolower">tolower-C++参考</a></p></blockquote><p><strong>参数</strong>：要检查的参数，即大小写字母</p><p>还是和上面相同的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Test String.\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (str[i])</span><br><span class="line">&#123;</span><br><span class="line">c = str[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">islower</span>(c))</span><br><span class="line">c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 c &#x3D; toupper( c ) 把 c -&#x3D; 32 替代了，省去了记 ASC|| 值的麻烦，以后修改值直接使用转换字符函数就行了</p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><blockquote><p>字符串函数则是对字符串（由零个或多个字符组成的序列）进行各种操作的函数，比如获取字符串长度、查找子字符串、替换字符串内容等</p></blockquote><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>看过我往期 vlog 的同学，该函数相信大家已经烂熟于心了，这里就不再过多赘述<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bc18bff128b84cdd8ee2d71b8621decc.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen">strlen-C++参考</a></p></blockquote><h2 id="strcpy和strncpy"><a href="#strcpy和strncpy" class="headerlink" title="strcpy和strncpy"></a>strcpy和strncpy</h2><p>strcpy 用于将一个字符串复制到另一个字符串中，即 copy<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c1c61d39a2c84ad69cad9c2d98d6cc69.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy">strcpy-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-指向要复制内容的目标数组的指针，source-要复制的 C 字符串(注意原字符串不可修改)</p><p><strong>返回值</strong>：destination 的起始地址</p><p><strong>值得注意的是</strong>：源字符串必须以 ‘\0’ 结束，拷贝会将源字符串中的 ‘\0’ 拷贝到目标空间，且目标空间必须足够大，以确保能存放源字符串，目标空间必须可修改</p><p><strong>strcpy 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* ret = dest;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((*dest++ = *src++))</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将 dest 的起始地址存储到变量 ret，以便返回值返回，对两个形参进行断言操作，避免空指针的使用 while 循环里的两个变量先各自++，然后从右向左赋值，直到 src 遇到 \0 循环才停止</p></blockquote><p><strong>和 strcpy 相像的是 strncpy</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/97af51217ba04c8fa5d877fcbac1c460.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncpy/?kw=strncpy">strncpy-C++参考</a></p></blockquote><p>唯一与 strcpy 不同的是它可以固定复制的个数，不只是以 \0 为标准停下来</p><p><strong>值得注意的是</strong>：在指定的连接字符个数中是不包括\0的，拷贝num个字符从源字符串到目标空间，如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个</p><h2 id="strcat和strncat"><a href="#strcat和strncat" class="headerlink" title="strcat和strncat"></a>strcat和strncat</h2><p>strcat 用于将一个字符串连接到另一个字符串的末尾，即 concatenate，需要包含头文件     &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dd07ab4ea9f04a35acec58d389c2cf17.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcat/?kw=strcat">strcat-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-指向要复制内容的目标数组的指针，source-要复制的 C 字符串(注意 destination 和 source 不能重合)</p><p><strong>返回值</strong>：destination 的起始地址</p><p><strong>值得注意的是</strong>：源字符串必须以 ‘\0’ 结束，目标字符串中也得有 \0 ，否则没办法知道追加从哪里开始，目标空间必须有足够的大，能容纳下源字符串的内容，目标空间必须可修改，追加过程中是会覆盖掉目标字符串末尾的 \0 的</p><p><strong>如果自己给自己追加呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(str, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原字符串str初始化为 “Hello”，它所占用的内存空间是按照初始化时设定的长度来分配的<br>• 理论上：追加过程中是会覆盖掉目标字符串末尾的 \0 的，但是不会把原字符串的 \0 复制过去，而是复制完后编译器自动在末尾加上一个 \0<br>• 实际上：自己给自己追加这个操作是无法让编译器到达添加 \0 这一步的，所以 “Hello” 会一直追加，无限循环下去，直到数组栈溢出报错为止</p></blockquote><p><strong>strcat 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* ret = dest;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*dest)</span><br><span class="line">&#123;</span><br><span class="line">dest++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((*dest++ = *src++))</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实就是在 strcpy 模拟实现的的基础上加了个循环，让指针指向目标字符串的末尾再开始</p></blockquote><p><strong>和 strcat 相像的是 strncat</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/62c28cecd1b043899763e015a824bf33.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncat/?kw=strncat">strncat-C++参考</a></p></blockquote><p>唯一与 strcat 不同的是它可以固定追加的个数，不只是以 \0 为标准停下来</p><p><strong>值得注意的是</strong>：在指定的连接字符个数中是不包括\0的，将 source 指向字符串的前 num 个字符追加到 destination 指向的字符串末尾，再追加⼀个 \0 字符，如果 source 指向的字符串的长度小于 num 的时候，只会将字符串中到 \0 的内容追加到 destination 指向的字符串末尾</p><h2 id="strcmp和strncmp"><a href="#strcmp和strncmp" class="headerlink" title="strcmp和strncmp"></a>strcmp和strncmp</h2><p>strcmp 用于比较两个字符串的函数，即 compare，需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83d6d9cb8c184d78a14ef4caaa7b5b7a.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcmp/?kw=strcmp">strcmp-C++参考</a></p></blockquote><p><strong>参数</strong>：str1、str2-要比较的字符串</p><p><strong>返回值规定</strong>：<br>• 第一个字符串大于第二个字符串，则返回大于 0 的数字<br>• 第一个字符串等于第二个字符串，则返回 0<br>• 第一个字符串小于第二个字符串，则返回小于 0 的数字</p><p><strong>如何判断两个字符串？</strong></p><blockquote><p>比较两个字符串中对应位置上字符ASCII码值的大小</p></blockquote><p><strong>strcmp 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*str1 == *str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*str1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>str1 和 str2分别逐个向后一个一个比较，直到遇到第一个大小不同的字符，立马停下，后面都不比较了，无论这个字符串多长，都只看第一个遇到的不同的字符谁大谁小，以ASC|| 的差值作返回值</p></blockquote><p><strong>和 strcmp 相像的是 strnccmp</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0eb3ff77aef248d8b9b0b39de9375ced.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncmp/?kw=strncmp">strncmp-C++参考</a></p></blockquote><p>唯一与 strcmp 不同的是它可以固定比较的个数</p><p><strong>值得注意的是</strong>：比较 str1 和 str2 的前 num 个字符，如果相等就继续往后比较，最多比较 num 个字母，如果提前发现不⼀样，就提前结束，大的字符所在的字符串大于另外一个，如果 num 个字符都相等，就是相等返回 0</p><h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p>strstr 用于查找在一个字符串中查找另一个指定字符串（子字符串）的首次出现位置<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a1666f20b4f54d4994e9e644dc9ca51d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strstr/?kw=strstr">strstr-C++参考</a></p></blockquote><p><strong>参数</strong>：str1-要扫描的字符串，str2-包含要匹配的字符序列</p><p><strong>返回值</strong>：指向 str2 中指定的整个字符序列在 str1 中第一次出现的指针，如果 str1 中不存在序列，则为空指针</p><p><strong>strstr 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* cp = (<span class="type">char</span>*)str1;</span><br><span class="line"><span class="type">char</span>* s1, * s2;</span><br><span class="line"><span class="keyword">if</span> (!*str2)</span><br><span class="line"><span class="keyword">return</span>((<span class="type">char</span>*)str1);</span><br><span class="line"><span class="keyword">while</span> (*cp)</span><br><span class="line">&#123;</span><br><span class="line">s1 = cp;</span><br><span class="line">s2 = (<span class="type">char</span>*)str2;</span><br><span class="line"><span class="keyword">while</span> (*s1 &amp;&amp; *s2 &amp;&amp; !(*s1 - *s2))</span><br><span class="line">s1++, s2++;</span><br><span class="line"><span class="keyword">if</span> (!*s2)</span><br><span class="line"><span class="keyword">return</span>(cp);</span><br><span class="line">cp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>外层循环遍历 str1 字符串，内层循环在每个可能的起始位置上对 str2 进行逐个字符比对</p></blockquote><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p>strtok 是用于字符串分割的函数，需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ceface0b5970479ea2f909dade9adec3.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strtok/?kw=strtok">strtok-C++参考</a></p></blockquote><p><strong>参数</strong>：str-是要进行分割操作的字符串，可以是字符数组形式存在的字符串，delimiters-是用于指定分割字符的字符串，即按照 delim 中包含的字符来对 str 进行分割</p><p><strong>返回值</strong>：返回一个指向被分割出的下一个子字符串的指针或空指针</p><p><strong>值得注意的是</strong>：sep 参数指向一个字符串，定义了用作分隔符的字符集合，第⼀个参数指定⼀个字符串，它包含了 0 个或者多个由 sep 字符串中⼀个或者多个分隔符分割的标记 strtok 函数找到 str 中的下⼀个标记，并将其用  \0 结尾，返回⼀个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以被strtok函数切分的字符串⼀般都是临时拷贝的内容并且可修改），strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok 函数将保存它在字符串中的位置，strtok 函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记，如果字符串中不存在更多的标记，则返回 NULL 指针</p><p><strong>这个函数有点难理解，举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;192.168.6.111&quot;</span>;</span><br><span class="line"><span class="type">char</span>* sep = <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (str = strtok(arr, sep); str != <span class="literal">NULL</span>; str = strtok(<span class="literal">NULL</span>, sep))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段 C 语言代码的主要目的是使用strtok函数对一个表示 IP 地址的字符串进行分割，并逐个输出分割后的子字符串，也就是将 IP 地址中的每个数字部分单独提取并打印出来</p></blockquote><h2 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h2><p>strerror 用于将一个错误码（由 errno 表示）转换为对应的、人类可读的错误描述字符串<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/875e869f0fbb4ceca990d220e8c45812.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strerror/?kw=strerror">strerror-C++参考</a></p></blockquote><p><strong>参数</strong>：errnum-错误码</p><blockquote><p>在不同的系统和C语言标准库的实现中都规定了一些错误码，一般是放在 errno.h 这个头文件中说明的，C语言程序启动的时候就会使用一个全局的变量 errno 来记录程序的当前错误码，只不过程序启动的时候 errno 是0，表示没有错误，当我们在使用标准库中的函数的时候发生了某种错误，就会将对应的错误码，存放在 errno 中，而⼀个错误码的数字是整数很难理解是什么意思，所以每一个错误码都是有对应的错误信息的，strerror 函数就可以将错误对应的错误信息字符串的地址返回</p></blockquote><p><strong>返回值</strong>：向描述 errnum 的错误字符串的指针</p><p>比如我们打印⼀下0~10这些错误码对应的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc4291ab8e4a4c6cbe614df13a92ca50.png" alt="在这里插入图片描述"><br>可以看到每个数字都有对应的错误信息</p><p><strong>和 strerror 相像的是 perror</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Error opening file unexist.ent: %s\n&quot;</span>, strerror(errno))</span><br><span class="line">perror(<span class="string">&quot;Error opening file unexist.ent&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这两段代码是等价的，perror函数打印完参数部分的字符串后，再打印一个冒号和一个空格，再打印错误信息</p></blockquote><p>本篇到这就结束了，涉及的函数很多，及时理解总结才能更好的掌握本篇的知识哦😋</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/849236c66dd6499792b05c75fe1f7772.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.16——万字详解指针概念及技巧</title>
      <link href="/2024/11/08/C%E8%AF%AD%E8%A8%80/vlog16/"/>
      <url>/2024/11/08/C%E8%AF%AD%E8%A8%80/vlog16/</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof-和-strlen"><a href="#sizeof-和-strlen" class="headerlink" title="sizeof 和 strlen"></a>sizeof 和 strlen</h1><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>在初学C语言时就提到过 sizeof 的概念，这也是个常用的关键字，想必已经大家已经烂熟于心<br>回顾提示：<strong>sizeof（类型）、sizeof 表达式</strong></p><blockquote><ol><li>sizeof 是操作符</li><li>sizeof 计算操作数所占内存的大小，单位是字节</li><li>不关注内存中存放什么数据</li></ol></blockquote><p>这里不做过多赘述，忘记的可以去看我往期的文章回顾:</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142828273?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.2——C语言数据类型和变量</a></p></blockquote><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>前面在举指针的例子的时候，提到过 strlen ，是用来计算字符串长度的<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/79867d2c7b444adab18dd9be2bdde503.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen">strlen-C++参考</a></p></blockquote><p>头文件为 #include &lt;string.h&gt; , strlen 是专门用于计算字符串长度的，strlen 从 str 这个参数的地址开始向后，统计 \0 之前的字符串个数，只要没遇到 \0 就不会停止，直到找到为止，所以可能存在越界查找的情况</p><p>通过一个例子就能明白：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> arr1[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"> <span class="type">char</span> arr2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr1));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr2));</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr1));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr2));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后可以发现结果为 35，3，3，4<br>字符没有 \0 ，所以 strlen 找不到停止的标志，就会产生一个随机值</p><p>可以总结出以下几点：</p><blockquote><ol><li>strlen是库函数，使用需要包含头文件 string.h</li><li>srtlen是求字符串长度的，统计的是 \0 之前字符的个数</li><li>关注内存中是否有 \0 ，如果没有 \0 ，就会持续往后找，可能会越界</li></ol></blockquote><h1 id="数组和指针结合的试题深入解析"><a href="#数组和指针结合的试题深入解析" class="headerlink" title="数组和指针结合的试题深入解析"></a>数组和指针结合的试题深入解析</h1><p>以下代码均在 x64 环境下运行，地址大小为 8 ，地址保持不变</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">1</span>]));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*&amp;a));</span><br><span class="line"><span class="number">8.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a+<span class="number">1</span>));</span><br><span class="line"><span class="number">9.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));</span><br><span class="line"><span class="number">10.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>16 数组名放在sizeof内部表示整个数组 ，单位是字节</li><li>8 这里 a 是数组名，表示首元素地址，加 0 后不变</li><li>4 这里 a 是数组名，表示首元素地址，解引用后就是首元素，即 a[0]<br> 所以*a – *(a + 0) – a[0]</li><li>8 这里 a + 1 是第二个元素的地址</li><li>4 第二个元素类型为 int</li><li>8 这里取整个数组的地址</li><li>16 这里的 * 和 &amp; 抵消了，也就是 sizeof(a) ,访问整个数组</li><li>8 这里 &amp;a + 1 跳过整个数组取地址</li><li>8 取第一个元素的地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="number">1.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="number">2.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="number">4.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 数组名放在sizeof内部表示整个数组</li><li>8 这里 arr 是数组名，表示首元素地址，加 0 后不变</li><li>1 这里 arr 是数组名，表示首元素地址，解引用后就是首元素</li><li>1 表示第二个元素</li><li>8 这里取整个数组的地址</li><li>8 这里 &amp;a + 1 跳过整个数组取地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>随机值 没有 \0</li><li>随机值 没有 \0</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 访问第二个元素，即 ‘b’ &#x3D; 98 ，会把 98 当成地址去访问</li><li>随机值 arr数组的地址，没有 \0</li><li>随机值 跳过整个数组取地址，没有 \0 </li><li>随机值 取第二个元素的地址，没有 \0</li></ol></blockquote><h3 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>7 数组名放在sizeof内部表示整个数组</li><li>8 arr是首元素地址，加 0 后不变</li><li>1 访问首元素，即 a</li><li>1 访问第二个元素，即 b</li><li>8 这里是数组的地址，和首元素地址一样</li><li>8 跳过整个数组取地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码4"><a href="#代码4" class="headerlink" title="代码4"></a>代码4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 arr是首元素地址，统计 \0 之前的字符长度</li><li>6 arr是首元素地址，统计 \0 之前的字符长度，加 0 后不变</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 访问第二个元素，即 ‘b’ &#x3D; 98 ，会把 98 当成地址去访问</li><li>6 &amp;arr是数组的地址，即首元素地址，统计 \0 之前的字符长度</li><li>随机值 跳过整个数组取地址，没有 \0 </li><li>5 取第二个元素的地址，统计 \0 之前的字符长度</li></ol></blockquote><h3 id="代码5"><a href="#代码5" class="headerlink" title="代码5"></a>代码5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p+<span class="number">1</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>8 p 是指针变量，计算的是指针变量的大小</li><li>8 p+1是第二个元素地址</li><li>1 p 的大小是 char* ，所以 *p 只能访问一个字节</li><li>1 p[0] – *(p + 0) – *p ,访问一个字节</li><li>8 指针变量 p 的地址</li><li>8 跳过 p 变量取后面的地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码6"><a href="#代码6" class="headerlink" title="代码6"></a>代码6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p+<span class="number">1</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 p 是指针变量，存放字符串的地址，统计 \0 之前的字符长度</li><li>5 指向第二个元素的地址</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 p[0] – *(p + 0) – *p，访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>随机值 取指针变量 p 的地址，没有 \0</li><li>随机值 跳过 p 变量取后面的地址，没有 \0</li><li>5 取第二个元素的地址，统计 \0 之前的字符长度</li></ol></blockquote><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(a[<span class="number">0</span>]+<span class="number">1</span>)));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(a+<span class="number">1</span>)));</span><br><span class="line"><span class="number">8.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line"><span class="number">9.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>]+<span class="number">1</span>)));</span><br><span class="line"><span class="number">10.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="number">11.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">3</span>]));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>48 数组名放在sizeof内部表示整个数组</li><li>4 第一行第一个元素</li><li>16 第一行数组名，计算第一行大小</li><li>8 a[0]+1则是将这个指针向后移动一个元素的位置<br>所以 a[0] + 1 – &amp;a[0][0] + 1 – &amp;a[0][1]  </li><li>4 第一行第二个元素</li><li>8 第二行的地址</li><li>16 解引用第二行</li><li>8 第二行的地址</li><li>16 第二行解引用</li><li>16 第一行解引用</li><li>16 第四行</li></ol></blockquote><h1 id="指针运算的试题深入解析"><a href="#指针运算的试题深入解析" class="headerlink" title="指针运算的试题深入解析"></a>指针运算的试题深入解析</h1><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序的结果是什么？</span></span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出 2，5<br>1.首先，&amp;a 取的是整个数组a的地址，数组的地址和数组首元素的地址在数值上是相同的，但类型不同，数组首元素的地址类型是 int <em>，而数组的地址类型是 int (</em>)[5]（因为a是一个包含 5 个元素的数组）<br>2.然后，&amp;a + 1 表示将指针向后移动一个数组的大小，由于数组 a 包含 5 个 int 类型的元素，每个int类型元素占 4 个字节，那么整个数组a在内存中所占字节数为 5×4 &#x3D; 20字节，所以 &amp;a + 1 实际上是指向了数组 a 所占内存空间之后的下一个位置<br>3.最后，(int *)(&amp;a + 1) 将这个指向数组a之后位置的指针强制转换为 int * 类型的指针，也就是将其看作是指向一个int类型元素的指针，赋值给了ptr</p></blockquote><p><em><em>对于 <em>(a + 1)：</em></em><br>数组名a在大多数情况下会被隐式转换为指向数组首元素的指针，所以 a + 1 就是将指向首元素的指针向后移动一个元素的位置，</em>(a + 1) 则是获取这个移动后指针所指向的元素，也就是数组a的第二个元素，其值为 2</p><p><em><em>对于 <em>(ptr - 1)：</em></em><br>ptr 是指向数组a所占内存空间之后的下一个位置，那么 ptr - 1 就是将这个指针向前移动一个元素的位置，</em>(ptr - 1) 就是获取这个移动后指针所指向的元素，也就是数组a的最后一个元素，其值为 5</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在X86环境下</span></span><br><span class="line"><span class="comment">//假设结构体的⼤⼩是20个字节</span></span><br><span class="line"><span class="comment">//程序输出的结果是啥？</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> Num;</span><br><span class="line"> <span class="type">char</span> *pcName;</span><br><span class="line"> <span class="type">short</span> sDate;</span><br><span class="line"> <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line"> <span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p = (<span class="keyword">struct</span> Test*)<span class="number">0x100000</span>;</span><br><span class="line"><span class="comment">//定义了一个指向 Test 结构体的指针 p，并将其初始化为内存地址 0x100000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：0x100014，0x100001，0x100004</p></blockquote><p><strong>第一次输出：</strong><br>将各成员所占字节数相加：4 + 4 + 2 + 2 + 8 &#x3D; 20 字节<br>所以当 p + 0x1 时，指针会按照结构体大小移动，即从初始地址 0x100000 移动到 0x100000 + 20×1 &#x3D; 0x100014，这里输出的结果应该是 0x100014</p><p><strong>第二次输出：</strong><br>这里将结构体指针 p 强制转换为 unsigned long 类型，然后进行加法运算，当把指针转换无符号长整型后，就不再按照结构体的大小进行指针移动的运算了，而是单纯的数值加法，因为 p 被初始化为 0x100000，将其视为无符号长整型并加上 0x1，得到的结果就0x100001，这里输出的结果应该是 0x100001</p><p><strong>第三次输出：</strong><br>这里将结构体指针 p 强制转换为 unsigned int* 类型的指针，然后进行加法运算，当 unsigned int* 类型的指针进行算术运算时，指针移动的步长是根据 unsigned int 类型的大小来确定的，在一般情况下，unsigned int 类型占 4 个字节，所以当 (unsigned int*)p + 0x1 时，指针会从初始地址 0x100000 移动到 0x100000 + 4×1 &#x3D; 0x100004，这里输出的结果应该是 0x100004</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line"> <span class="type">int</span> *p;</span><br><span class="line"> p = a[<span class="number">0</span>];</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：1<br>a[0] 可以看作是指向二维数组 a 第一行，这里将 a[0] 赋值给指针 p，此时 p 就指向了数组 a 的第一行的第一个元素，也就是值为 1 的那个元素</p></blockquote><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设环境是x86环境，程序输出的结果是啥？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"> <span class="type">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line"> p = a;</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：0xFFFFFFFC,-4</p></blockquote><p> int(*p)[4], p &#x3D; a 的图示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d176ba6ea41849cdbfc2a913bdcf8c49.png" alt="请添加图片描述"></p><blockquote><p>p[4][2] &#x3D; <em>(</em>(p+4)+2)<br>所以地址减地址得到的是元素个数，又因为这里打印地址，所以以补码的形式打印</p></blockquote><h2 id="题5"><a href="#题5" class="headerlink" title="题5"></a>题5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line"> <span class="type">int</span> *ptr2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：10，5</p></blockquote><p>int *ptr1 &#x3D; (int *)(&amp;aa + 1)， int *ptr2 &#x3D; (int <em>)(</em>(aa + 1)) 如图所示</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/74eedf2ea94c4a32ae8a65fd2f812754.png" alt="请添加图片描述"></p><blockquote><ol><li>首先，&amp;aa 取整个二维数组 aa 的地址加一</li><li>然后，aa + 1 指向了二维数组 aa 的第二行，*(aa + 1) 就是获取这个指针所指向的内容，也就是二维数组 aa 的第二行</li></ol></blockquote><p><em><em>对于 <em>(ptr1 - 1)：</em></em><br>ptr1 是指向数组 aa 所占内存空间之后的下一个位置，那么 ptr1 - 1 就是将这个指针向左移动一个元素的位置，</em>(ptr1 - 1) 就是获取这个移动后指针所指向的元素，也就是数组 aa 的最后一个元素，其值为 10</p><p><em><em>对于 <em>(ptr2 - 1)：</em></em><br>ptr2 是指向二维数组 aa 的第二行，那么 ptr2 - 1 就是将这个指针向左移动一个元素的位置，</em>(ptr2 - 1) 就是获取这个移动后指针所指向的元素，也就是二维数组 aa 的第一行的第五个元素，其值为 5</p><h2 id="题6"><a href="#题6" class="headerlink" title="题6"></a>题6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *a[] = &#123;<span class="string">&quot;work&quot;</span>,<span class="string">&quot;at&quot;</span>,<span class="string">&quot;alibaba&quot;</span>&#125;;</span><br><span class="line"> <span class="type">char</span>**pa = a;</span><br><span class="line"> pa++;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：at</p></blockquote><p>char *a[ ] &#x3D; {“work”,”at”,”alibaba”}， char**pa &#x3D; a 如图所示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45389f0d30c14161b87b6b992f511fd4.png" alt="请添加图片描述"></p><blockquote><p>a 数组里分别存放三个字符串的地址，然后将该数组的地址存放到二级指针里，即第一个字符串的地址，pa++ 指向第二个字符串，然后解引用得到 at 的地址，但是这里使用 %s 占位符，所以当把 *pa 作为 %s 的参数传递给 printf 函数时，printf 函数会按照字符串的格式来处理它，即从这个指针所指向的位置开始，依次输出字符，直到遇到空字符（\0）为止，这样就输出了完整的字符串 “at”，而不是它的地址</p></blockquote><h2 id="题7"><a href="#题7" class="headerlink" title="题7"></a>题7</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>,<span class="string">&quot;NEW&quot;</span>,<span class="string">&quot;POINT&quot;</span>,<span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line"> <span class="type">char</span>**cp[] = &#123;c+<span class="number">3</span>,c+<span class="number">2</span>,c+<span class="number">1</span>,c&#125;;</span><br><span class="line"> <span class="type">char</span>***cpp = cp;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：POINT，EW，ST，NT</p></blockquote><p> 如图所示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e8fd3cc212fa417299f2d7c81a29e83b.png" alt="请添加图片描述"></p><p><strong>第一次输出：</strong></p><ol><li>首先，++cpp 会使 cpp 指针自增，它现在指向 cp 数组中的第二个元素（也就是原来 cp[1] 的地址）。</li><li>然后，*cpp 会取出 cpp 所指向的元素，即 cp[1]，它是指向 c + 2 的指针（也就是指向字符串 “POINT” 的指针）。</li><li>最后，**cpp 再次间接访问，得到的就是字符串 “POINT”，所以这个 printf 语句会输出 “POINT”</li></ol><p><strong>第二次输出：</strong></p><ol><li>先看 ++cpp，这会使 cpp 再次自增，现在它指向 cp 数组中的第三个元素（原来 cp[2] 的地址）</li><li>然后 *++cpp 取出 cpp 所指向的元素，即 cp[2]，它是指向 c + 1 的指针（指向字符串 “NEW” 的指针）</li><li>接着 –*++cpp 会对 cp[2] 所指向的指针（也就是指向字符串 “NEW” 的指针）进行自减操作，此时它指向了字符串 “NEW” 中的倒数第二个字符（假设字符串以 \0 结尾，那么就是指向 ‘W’ 的指针）</li><li>最后 <em>–</em>++cpp + 3 会先取出这个新指向的字符（’W’），然后再往后偏移 3 个字符，此时就指向了字符串 “NEW” 中的倒数第一个字符（’W’ 往后 3 个字符，也就是 ‘W’ 本身，因为字符串 “NEW” 较短），所以这个 printf 语句会输出 “EW”</li></ol><p><strong>第三次输出：</strong></p><ol><li>cpp[-2] 相当于 *(cpp - 2)，因为前面 cpp 经过两次自增，现在要往回找两个位置，所以 cpp[-2] 指向的是原来 cp[0] 的地址</li><li>*cpp[-2] 取出 cpp[-2] 所指向的元素，即 cp[0]，它是指向 c + 3 的指针（指向字符串 “FIRST” 的指针）</li><li>*cpp[-2] + 3 会在指向字符串 “FIRST” 的指针基础上往后偏移 3 个字符，所以会指向字符串 “FIRST” 中的第 4 个字符，因此这个 printf 语句会输出 “ST”</li></ol><p><strong>第四次输出：</strong></p><ol><li>cpp[-1] 相当于 *(cpp - 1)，因为前面 cpp 经过两次自增，现在往回找一个位置，所以 cpp[-1] 指向的是原来 cp[1] 的地址</li><li>cpp[-1][-1] 相当于 <em>(</em>(cpp - 1) - 1)，也就是先找到 cp[1]（指向 c + 2 的指针，指向字符串 “POINT” 的指针），然后再对这个指针进行自减操作，此时它指向了字符串 “POINT” 中的倒数第二个字符</li><li>cpp[-1][-1] + 1 会在指向 ‘N’ 的指针基础上往后偏移 1 个字符，所以会指向字符串 “POINT” 中的倒数第一个字符（’N’ 往后 1 个字符，也就是 ‘T’ 的指针），因此这个 printf 语句会输出 “NT”</li></ol><blockquote><p>今天的博客属实不易，有些题博主也想了很久才理解，也尽量用最简易易懂的方式给大家讲解每一道题，希望看完这篇 vlog ，以后不再害怕指针类型的题目，冬天到了，祝大家立冬快乐！</p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c0688a7b3efc46d5956d24ab490ce77d.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.15——深入理解指针(4)</title>
      <link href="/2024/11/06/C%E8%AF%AD%E8%A8%80/vlog15/"/>
      <url>/2024/11/06/C%E8%AF%AD%E8%A8%80/vlog15/</url>
      
        <content type="html"><![CDATA[<h1 id="回调函数的介绍"><a href="#回调函数的介绍" class="headerlink" title="回调函数的介绍"></a>回调函数的介绍</h1><blockquote><p>回调函数就是一个通过函数指针调用的函数</p></blockquote><p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数</p><p>正如我们在上一篇 vlog 中讲到的转移表，就是经典的回调函数，<strong>回调函数不是函数本身自己实现的，而是在特定的事件或条件发生的时候由另一方调用，对该事件或条件进行响应</strong></p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143477683?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.14——常见C语言算法</a></p></blockquote><p>还是以一个简易的计算器做例子</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/743964a7b1b015e93393bde039b80025.png" alt="请添加图片描述"></p><p>每写一个计算方法都要写一种情况，不断地 scanf 输入，printf 输出，显得过于啰嗦</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e3485dd3aab716a3b734c7d73db4c8d2.png" alt="请添加图片描述"></p><p>把每种情况的函数统一由一个函数管理，把这些函数以参数的形式传给该函数，这些函数就被称为回调函数</p><blockquote><p>值得注意的是，在上一篇 vlog 中的优化方案是使用函数指针数组，这里使用的是回调函数</p></blockquote><h1 id="qsort使用实例"><a href="#qsort使用实例" class="headerlink" title="qsort使用实例"></a>qsort使用实例</h1><h2 id="qsort函数介绍"><a href="#qsort函数介绍" class="headerlink" title="qsort函数介绍"></a>qsort函数介绍</h2><p>什么是qsort函数？</p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/qsort/?kw=qsort">qsort-C++参考</a></p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e8843a50b86ae9391a5da2f6c3e6b3d.png" alt="在这里插入图片描述"><br><strong>qsort函数的作用</strong>：对数组的元素进行排序，对指向的数组的元素进行排序，每个元素字节长，使用函数确定顺序，此函数使用的排序算法通过调用指定的函数来比较元素对，并将指向它们的指针作为参数，该函数不返回任何值，但通过按照 定义对其元素重新排序来修改指向的数组的内容</p><p>包含头文件 #include &lt;stdlib.h&gt;， 其<strong>语法形式</strong>为：</p><blockquote><p>void qsort (void* base, size_t num, size_t size,<br>            int (<em>compar)(const void</em>,const void*));</p></blockquote><p>base：指向要排序的数组的第一个对象的指针，转换为 .void*<br>num：指向的数组中的元素数，是无符号整型<br>size：数组中每个元素的大小（以字节为单位），是无符号整型<br>&#x3D;&#x3D;<strong>compare</strong>&#x3D;&#x3D;：指向比较两个元素的函数的指针，此函数被重复调用以比较两个元素</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0da691737a654e23e86e9d670c3caf.png" alt="在这里插入图片描述"><br>假设第一个指针为p1，第二个指针为p2，那么有以下结论：</p><blockquote><p>1.如果p1指向的元素小于p2，则返回小于0的数字<br>2.如果二者相等，则返回0<br>3.如果p1指向的元素大于p2，则返回大于0的数字<br>4.默认排序为升序，若想降序以上结论反转即可</p></blockquote><p>那么 qsort 函数是如何一个一个比较的呢？<br>只是单纯两个比较吗？需要加循环结构吗？</p><p><strong>当qsort函数在执行排序过程中，每当需要比较两个数组元素以确定它们的相对顺序时，就会调用用户提供的这个比较函数</strong></p><blockquote><p>1.在划分步骤中，通常会选择一个基准元素（pivot），并通过设置两个指针（比如一个从数组开头，一个从数组结尾）来对数组进行划分，这两个指针的初始范围是从数组的起始地址和结束地址开始<br>2.例如，对于一个整数数组int arr[] &#x3D; {1, 2, 3, 4,&gt; 5}，如果选择第一个元素作为基准元素，那么一个指针可能从&amp;arr[0]开始（指向首元素），另一个指针可能从&amp;arr[sizeof(arr) &#x2F; sizeof(arr[0]) - 1]开始（指向尾元素）<br>3.然后这两个指针会根据与基准元素的比较结果（通过调用比较函数）进行移动，在移动过程中，它们的范围会不断变化，直到完成划分操作，使得数组被分成两部分，一部分元素小于基准元素，另一部分元素大于基准元素。此时这两个指针的最终范围就是划分后两部分数组的边界地址，比如一个指针可能停留在小于基准元素那部分数组的最后一个元素地址处，另一个指针可能停留在大于基准元素那部分数组的第一个元素地址处</p></blockquote><h2 id="使用-qsort-函数排序整型数据"><a href="#使用-qsort-函数排序整型数据" class="headerlink" title="使用 qsort 函数排序整型数据"></a>使用 qsort 函数排序整型数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> * p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*( <span class="type">int</span> *)p1 - *(<span class="type">int</span> *) p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    qsort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span> (<span class="type">int</span>), int_cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;强调 p1 和 p2 必须是 const void* 类型的指针&#x3D;&#x3D;</p><blockquote><p>这里定义了int_cmp函数，qsort函数在对数组进行排序时，需要一个能比较数组元素大小关系的函数作为参数，int_cmp函数接受两个const void *类型的指针p1和p2，这种通用指针类型使得qsort函数可以处理各种类型数据的排序（虽然这里实际只用于整数数组），在函数内部，先将p1和p2这两个通用指针转换为int *类型指针，以便能解引用获取到对应的整数，然后通过计算这两个整数的差值并返回，返回值的正负情况决定了qsort函数对数组元素的排序顺序：返回值小于 0，表示p1所指向的整数小于p2所指向的整数，那么在排序结果中p1对应的元素会排在p2对应的元素之前；返回值大于 0，意味着p1所指向的整数大于p2所指向的整数，p1对应的元素会排在p2对应的元素之后；若返回值等于 0，则表明这两个整数相等，此时元素的相对顺序在排序中可保持原有顺序或按其他默认规则处理</p></blockquote><h2 id="使用-qsort-排序结构数据"><a href="#使用-qsort-排序结构数据" class="headerlink" title="使用 qsort 排序结构数据"></a>使用 qsort 排序结构数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> //学⽣</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//假设按照年龄来⽐较</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp_stu_by_age</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">struct</span> Stu*)e1)-&gt;age - ((<span class="keyword">struct</span> Stu*)e2)-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设按照名字来⽐较</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp_stu_by_name</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(((<span class="keyword">struct</span> Stu*)e1)-&gt;name, ((<span class="keyword">struct</span> Stu*)e2)-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照年龄来排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>[] =</span> &#123; &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">15</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">    qsort(s, sz, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp_stu_by_age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照名字来排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span>[] =</span> &#123; &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">15</span>&#125; &#125;;</span><br><span class="line">    <span class="type">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">    qsort(s, sz, <span class="keyword">sizeof</span>(s[<span class="number">0</span>]), cmp_stu_by_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>strcmp - 是库函数，是专门用来比较两个字符串的大小的</p></blockquote><p>该函数也和整数排列类似，只不过指针类型有所区别</p><h1 id="qsort的模拟实现"><a href="#qsort的模拟实现" class="headerlink" title="qsort的模拟实现"></a>qsort的模拟实现</h1><p>使用回调函数，模拟实现qsort，<br>qsost底层采用的是快速排序的方法，在这里我们使用更简单的冒泡排序的排序算法来模拟实现 qsort 函数，对快排想要了解更多的，在上一篇 vlog 讲到了冒泡排序</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143477683?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.14——常见C语言算法</a></p></blockquote><p>首先是要实现排序模拟，那么运用冒泡排序就行，然后对两个数进行对比：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(<span class="type">char</span>* buf1, <span class="type">char</span>* buf2, <span class="type">size_t</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = *buf1;</span><br><span class="line">        *buf1 = *buf2;</span><br><span class="line">        *buf2 = tmp;</span><br><span class="line"></span><br><span class="line">        buf1++;</span><br><span class="line">        buf2++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> sz, <span class="type">size_t</span> width, <span class="type">int</span> (*cmp)(<span class="type">const</span> <span class="type">void</span>* p1, <span class="type">const</span> <span class="type">void</span>* p2))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//趟数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//一趟内部的两两比较</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span> - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if (arr[j] &gt; arr[j + 1])</span></span><br><span class="line">            <span class="comment">//比较两个元素</span></span><br><span class="line">            <span class="keyword">if</span> (cmp((<span class="type">char</span>*)base + j * width, (<span class="type">char</span>*)base + (j + <span class="number">1</span>) * width) &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//交换两个元素</span></span><br><span class="line">                Swap((<span class="type">char</span>*)base + j * width, (<span class="type">char</span>*)base + (j + <span class="number">1</span>) * width, width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于不知道用户排序的数据类型，传过来的数组首元素地址我们必须使用void*指针接收，不能进行解引用，且数据类型不能传参的，那我们该怎么找到相邻元素比较呢？</p><blockquote><p>因为不知道接收数据的类型所以我们用char* 来一个字节一个字节移动，同样对比两个数也是如此，这就保证了这个模拟的函数能够接受各种类型的数据</p></blockquote><p>使用 void* 指针实现了对不同数据排序，这种编程也叫做泛型编程</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4cf50236316e52211e9a35a3fc0bc57.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.14——常见C语言算法</title>
      <link href="/2024/11/04/C%E8%AF%AD%E8%A8%80/vlog14/"/>
      <url>/2024/11/04/C%E8%AF%AD%E8%A8%80/vlog14/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序不对则进行交换，并一直重复这样的走访操作，直到没有要交换的数据元素为止</p></blockquote><p>核心思想：&#x3D;&#x3D;两两元素进行比较交换&#x3D;&#x3D;</p><blockquote><p>基本原理<br>1.比较相邻的元素，如果第一个比第二个大（假设是按照升序排序，若为降序则相反），就交换它们两个<br>2.对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对，这样在经过第一轮比较后，最大的元素就会 “浮” 到数列的末尾<br>3.针对所有的元素重复以上的步骤，除了最后已经排好序的元素（因为每一轮都会把当前未排序部分的最大元素移到最后，所以每轮结束后末尾的元素数量会增加，这些元素就不需要再参与后续排序了）<br>4.持续重复上述过程，直到整个数列都按照要求的顺序排列好</p></blockquote><p>理论知识介绍完，举个例子或许你就完全明白了<br>假设我们有一个数组 [5, 4, 3, 2, 1] 要进行升序排序：</p><blockquote><p><strong>第一轮排序</strong><br>1.比较第 1 个元素 5 和第 2 个元素 4，因为 5 &gt; 4，所以交换它们，数组变为 [4, 5, 3, 2, 1]<br>2.接着比较第 2 个元素 5 和第 3 个元素 3，因为 5 &gt; 3，交换后数组变为 [4, 3, 5, 2, 1]<br>3.再比较第 3 个元素 5 和第 4 个元素 2，交换得到 [4, 3, 2, 5, 1]<br>4.最后比较第 4 个元素 5 和第 5 个元素 1，交换后数组变为 [4, 3, 2, 1, 5]。此时第一轮排序结束，最大的元素 5 已经 “浮” 到了数组的末尾</p></blockquote><blockquote><p><strong>第二轮排序</strong><br>1.对除了最后一个元素 5 之外的数组部分 [4, 3, 2, 1] 进行同样操作<br>2.先比较第 1 个元素 4 和第 2 个元素 3，交换得 [3, 4, 2, 1]<br>3.再比较第 4 个元素 4 和第 3 个元素 2，交换得 [3, 2, 4, 1]<br>4.最后比较第 3 个元素 4 和第 4 个元素 1，交换得 [3, 2, 1, 4]。第二轮排序结束，此时未排序部分的最大元素 4 也 “浮” 到了合适位置</p></blockquote><p><strong>……以此类推</strong></p><p>可以发现每次都将最大的那个数送到最右边，假设有 n 个数，那么<strong>需要运送的趟数就为 (n-1)</strong><br>每一轮，每两个数都要进行比较，已经被运送到最右边的就不需要比较<br>那么<strong>需要比较 (n-1-已经运送到右边的数的个数)</strong></p><p>所以交换的函数可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span><span class="comment">//参数接收数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz<span class="number">-1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;sz-i<span class="number">-1</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                     arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                     arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">       bubble_sort(arr, sz);</span><br><span class="line">       <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明一下<strong>时间复杂度</strong>的概念，这里只需要理解概念即可，如何计算到了C数据结构会讲解</p><blockquote><ol><li>时间复杂度是用来衡量算法运行时间随着输入规模增长而增长的趋势的一个重要指标 </li><li>时间复杂度通常用大 O 表示法来表示,大 O 表示法描述的是算法在最坏情况下的时间复杂度，也就是当输入对算法运行造成最大困难时的运行时间增长趋势</li></ol></blockquote><p>对于该冒泡排序<br><strong>最坏情况</strong>：当输入的数组是完全逆序时，第一轮需要比较 n-1 次，第二轮需要比较 n-2 次，以此类推，总共需要比较的次数为 (n-1)+(n-2)+…+1，这个和等于 n (n-1)&#x2F;2，所以需要进行 &#x3D;&#x3D;n(n-1)&#x2F;2&#x3D;&#x3D; 次比较和交换操作，所以时间复杂度为 &#x3D;&#x3D;O(n^2)&#x3D;&#x3D;，其中 n 是数组的元素个数</p><p><strong>最好情况</strong>：当输入的数组已经是有序的，只需要进行一轮比较（每个元素都和它相邻的元素比较一次），此时时间复杂度为 &#x3D;&#x3D;O(n)&#x3D;&#x3D;</p><p>假设有多个序列需要排列，所以为了提高效率，对最好情况进行快速排序，对代码可进行如下优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span><span class="comment">//参数接收数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz<span class="number">-1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//假设这⼀趟已经有序了</span></span><br><span class="line">           <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;sz-i<span class="number">-1</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                     flag = <span class="number">0</span>;<span class="comment">//发⽣交换就说明，⽆序</span></span><br><span class="line">                     <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                     arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                     arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(falg == <span class="number">1</span>)<span class="comment">//这⼀趟没交换就说明已经有序，后续⽆序排序了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">       bubble_sort(arr, sz);</span><br><span class="line">       <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序虽然简单易懂，但由于其时间复杂度较高，在处理大规模数据排序时效率相对较低，通常会被更高效的排序算法如快速排序、归并排序等所替代,但在一些数据量较小且对排序效率要求不是特别高的场景下，仍然可以使用冒泡排序</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>二分查找（Binary Search），也叫折半查找，是一种用于在有序数组（或其他有序数据结构）中快速查找特定元素的高效查找算法</p></blockquote><p>核心思想：&#x3D;&#x3D;不断对半查找&#x3D;&#x3D;</p><blockquote><p>基本原理<br>1.每次查找时都将待查找的区间分成两部分<br>2.然后根据要查找元素与中间元素的比较结果，确定下一次查找应该在左半部分还是右半部分继续进行<br>3.如此反复，直到找到目标元素或者确定目标元素不存在为止</p></blockquote><p>还是通过举例来说明，假设我们有一个有序数组 [1, 3, 5, 7, 9, 11, 13, 15]，&#x3D;&#x3D;要查找元素 7&#x3D;&#x3D;</p><blockquote><p><strong>首先</strong>，确定整个数组为待查找区间，计算中间元素的索引，对于长度为 n 的数组，中间元素索引 mid 计算公式为：mid &#x3D; (left + right) &#x2F; 2（这里 left 表示区间的左端点，right 表示区间的右端点，在初始时 left &#x3D; 0，right &#x3D; n - 1）。在这个例子中，n &#x3D; 8，所以 mid &#x3D; (0 + 7) &#x2F; 2 &#x3D; 3，中间元素就是 7</p></blockquote><blockquote><p><strong>然后</strong>，将目标元素 7 与中间元素 7 进行比较，发现它们相等，这就找到了目标元素，查找过程结束</p></blockquote><p>再假设要&#x3D;&#x3D;查找元素 4&#x3D;&#x3D;</p><blockquote><ol><li>同样先确定整个数组为待查找区间，计算中间元素索引 mid &#x3D; (0 + 7) &#x2F; 2 &#x3D; 3，中间元素是 7</li><li>将目标元素 4 与中间元素 7 进行比较，因为 4 &lt; 7，所以目标元素如果存在，一定在左半部分。此时更新待查找区间为左半部分，即 left &#x3D; 0，right &#x3D; mid - 1 &#x3D; 2</li><li>再次计算新的中间元素索引 mid &#x3D; (0 + 2) &#x2F; 2 &#x3D; 1，新的中间元素是 3<br>将目标元素 4 与新的中间元素 3 进行比较，因为 4 &gt; 3，所以目标元素如果存在，一定在右半部分，更新待查找区间为右半部分，即 left &#x3D; mid + 1 &#x3D; 2，right &#x3D; 2</li><li>第三次计算中间元素索引 mid &#x3D; (2 + 2) &#x2F; 2 &#x3D; 2，中间元素是 5</li><li>将目标元素 4 与中间元素 5 进行比较，因为 4 &lt; 5，所以目标元素如果存在，一定在左半部分，更新待查找区间为左半部分，即 left &#x3D; 2，right &#x3D; mid - 1 &#x3D; 1，此时 left &gt; right，说明目标元素在这个有序数组中不存在，查找过程结束</li></ol></blockquote><p>可以发现每次折中查找，然后和目标元素比较，以此往复完成二分查找</p><p>对于二分查找<br>二分查找每次查找都会将搜索范围缩小一半，最多需要查找的次数为以 2 为底，n（数组元素个数）的对数次<br>即 &#x3D;&#x3D;log 2^n&#x3D;&#x3D; ，所以二分查找的时间复杂度为 &#x3D;&#x3D;O(log n)&#x3D;&#x3D;，这使得它在处理较大规模的有序数组时，查找速度比顺序查找（时间复杂度为 O(n)）快得多</p><blockquote><p>例如，当数组有 1024 个元素时，二分查找最多只需要查找 10 次（因为 ）就可以确定目标元素是否存在<br>如果是顺序查找就要找 1024 次，往往查找的数目还不止这么多，甚至更加庞大</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 计算中间元素的索引</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> result = binary_search(arr, n, target);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中的索引为 %d\n&quot;</span>, target, result);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中不存在\n&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找是一种非常高效的查找算法，但它的前提是数组必须是有序的。如果数组未排序，则需要先对数组进行排序，再使用二分查找</p><h1 id="转移表"><a href="#转移表" class="headerlink" title="转移表"></a>转移表</h1><p>转移表是一种数据结构和编程技巧，用于实现根据不同的条件或输入值快速跳转到相应的代码段执行</p><blockquote><p>例如：写一个简单的计算器程序，它可以执行加、减、乘、除四种运算。你可以创建一个转移表，表中包含四个元素，分别对应四种运算的处理函数的指针，当用户输入一个运算符号后，程序可以根据这个符号在转移表中快速找到对应的处理函数并执行，而不需要使用一长串的 if-else 或 switch 语句来逐个判断运算符号并调用相应函数</p></blockquote><p>根据前面所学的 switch 结构和 加法函数，可以写出一个简易的四则运算计算器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> x, y;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    1:add          2:sub \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    3:mul          4:div \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    0:exit               \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">switch</span> (input)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = add(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = sub(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = mul(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = div(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;退出程序\n&quot;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;选择错误\n&quot;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法过于重复啰嗦，可以运用<strong>函数数组指针</strong>来简化代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> x, y;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span>(*p[<span class="number">5</span>])(<span class="type">int</span> x, <span class="type">int</span> y) = &#123;<span class="number">0</span>, add, sub, mul, div &#125;;<span class="comment">//转移表</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    1:add          2:sub \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    3:mul          4:div \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    0:exit               \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))</span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;输⼊操作数：&quot;</span> );</span><br><span class="line">               <span class="built_in">scanf</span>( <span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">               ret = (*p[input])(x, y);</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;退出计算器\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;输⼊有误\n&quot;</span> ); </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">while</span> (input);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就通过函数指针数组实现了根据不同的索引值灵活调用不同函数的功能，这在很多需要根据条件或情况动态选择执行不同函数的场景中非常有用</p><p>如果还有不懂可以私信博主或回顾往期 vlog 查缺补漏</p><blockquote><p>主页传送门：<a href="https://blog.csdn.net/Zero_VPN?type=lately">DARLING Zero two♡ 的 blog</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ed29ea1478f3b975f82f1fb539e7a3f.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.13——深入理解指针(3)</title>
      <link href="/2024/11/01/C%E8%AF%AD%E8%A8%80/vlog13/"/>
      <url>/2024/11/01/C%E8%AF%AD%E8%A8%80/vlog13/</url>
      
        <content type="html"><![CDATA[<h1 id="字符指针变量"><a href="#字符指针变量" class="headerlink" title="字符指针变量"></a>字符指针变量</h1><p>字符指针变量，顾名思义就是字符类型的指针，即 char*<br>常见的输出格式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> ch = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line"> <span class="type">char</span> *pc = &amp;ch;</span><br><span class="line"> *pc = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是存放一个字符的情况，如果存放字符串呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello bit.&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pstr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看是存放字符串在指针变量中，但我们要记住指针变量是用来存放地址的<br>所以这里本质是把字符串 hello bit. 首字符的地址放到了pstr中，即字符 h 的地址</p><h1 id="数组指针变量"><a href="#数组指针变量" class="headerlink" title="数组指针变量"></a>数组指针变量</h1><p>上一篇 vlog 学到了指针数组，就是存放指针的数组，也可以理解为存放指针的集合(元素相同)，那么数组指针就可以得出是存放数组地址的指针，是一种指针变量，指向数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>那么以上哪种是数组指针？<br>答案是下面那个<br>分析：&#x3D;&#x3D;[ ] 的优先级大于 * ，所以必须加上 （）来保证 p 和 * 优先结合&#x3D;&#x3D;</p><p>p先和 * 结合，说明p是一个指针变量，然后指针指向的是一个大小为10个整型的数组<br>所以 p 是一个指针，指向一个数组，叫&#x3D;&#x3D;数组指针&#x3D;&#x3D;</p><p>int 表示 p指向的数组的元素类型， p 是数组指针变量名，10是指向数组的元素个数</p><h1 id="函数指针变量"><a href="#函数指针变量" class="headerlink" title="函数指针变量"></a>函数指针变量</h1><p>根据前面学过的类比，不难发现，函数指针变量应该是用来存放函数地址的，通过地址能够调用函数的<br>那么函数真的有地址吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;test: %p\n&quot;</span>, test);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;test: %p\n&quot;</span>, &amp;test);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以发现函数确实有地址，&#x3D;&#x3D;用函数名就能代表其地址&#x3D;&#x3D;，当然也可以通过 &amp;函数名 的方<br>式获得函数的地址，为了方便一般就不写取地址符<br>其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*pf3)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line"><span class="type">int</span>(*pf3)(<span class="type">int</span> x, <span class="type">int</span> y) = &amp;Add;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;函数参数的变量名可写可不写&#x3D;&#x3D;，取地址符也是<br>int 是指向函数的返回类型，pf3 是函数指针变量名，int x，int y 是 pf3 指向函数的参数类型和个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>(*pf3)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pf3)(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pf3(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将通过函数指针调用指针指向的函数写一个我们之前写过的加法函数</p><blockquote><p>这里通过解引用函数指针 pf3 的方式来调用它所指向的函数（也就是 Add 函数），传入参数 2 和 3，然后将返回的结果使用 printf<br>函数输出。实际上，在这种情况下，解引用操作符 * 在这里是可选的，因为在 C<br>语言中，函数名本身在求值时就会转换为指向该函数的指针，所以也可以直接写成 pf3(2, 3)</p></blockquote><h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><p>在学习了指针数组的基础上，我们引入函数指针放入数组<br>那么以下哪种为正确的形式？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*parr1[<span class="number">3</span>])();</span><br><span class="line"><span class="type">int</span> *parr2[<span class="number">3</span>]();</span><br><span class="line"><span class="type">int</span> (*)() parr3[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>答案是第一个</p><blockquote><p>定义形式如下：返回值类型 (*数组名[数组大小])(参数列表)</p></blockquote><p>parr1 先和 [ ] 结合，说明 parr1是数组，是 int (*)() 类型的函数指针<br>那么参数如何理解？其实就是每个元素代表的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func_array[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;add, subtract&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，func_array 数组的两个元素分别被初始化为 add 函数和 subtract 函数的指针</p><h1 id="二维数组传参本质"><a href="#二维数组传参本质" class="headerlink" title="二维数组传参本质"></a>二维数组传参本质</h1><p>讲数组的时候说过二维数组其实可以看做是每个元素是一维数组的数组，也就是二维数组的每个元素是一个一维数组，那么二维数组的首元素就是第一行，是个一维数组<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5fe059216cb9645764968a491d4b117.png" alt="在这里插入图片描述"><br>第一行的一维数组的类型就是 int [5] ，所以第一行的地址的类型就是数组指针类型 int(*)[5] ，那就意味着二维数组传参本质上也是传递了地址，传递的是第一行这个一维数组的地址，那么形参也是可以写成指针形式的，&#x3D;&#x3D;总的来说就是把二维数组当一维数组理解，第一行看成一维数组的第一个元素，首元素就是第一行一整行的地址&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> r, <span class="type">int</span> c)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;r; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;c; j++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(p+i)+j));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"> test(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的遍历数组传参也可以这样写</p><blockquote><p>这里的 *(p+i) 相当于获取二维数组的第 i 行的首地址（因为 p 是指向包含 5 个整数的数组的指针，p+i 就指向了第 i 行），然后 *(p+i)+j 就是指向第 i 行第 j 列元素的指针，最后 <em>(</em>(p+i)+j) 就是获取该位置的元素值并输出</p></blockquote><p>虽然解引用通常是获取元素本身，但在指向二维数组行的指针这种特殊情况下，&#x3D;&#x3D;由于指针所指向的对象本身就是一个数组，解引用得到的就是这个数组的首地址&#x3D;&#x3D;，这是由 C 语言的指针和数组特性共同决定的</p><blockquote><p>二维数组传参，形参的部分可以写成数组，也可以写成指针形式</p></blockquote><h1 id="拓展补充"><a href="#拓展补充" class="headerlink" title="拓展补充"></a>拓展补充</h1><p>补充一个关键字 typedef ，是用来类型重命名的，可以将复杂的类型，简单化</p><p><strong>普通类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="comment">//将unsigned int 重命名为uint</span></span><br></pre></td></tr></table></figure><p><strong>普通指针类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* ptr;</span><br></pre></td></tr></table></figure><p><strong>数组函数指针类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*parr)</span>[5]; <span class="comment">//新的类型名必须在*的右边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*pfun)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//新的类型名必须在*的右边</span></span><br></pre></td></tr></table></figure><p>下一期 vlog 将对二分查找，转移表，冒泡排序等常见算法题目进行练习解析<br>建议对前面的知识都有系统性的理解后再来写题</p><blockquote><p>主页传送门：<a href="https://blog.csdn.net/Zero_VPN?type=blog">DARLING Zero two♡ 的 blog</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/59b74dc7fa200c95b948b4b9094715c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.12——深入理解指针(2)</title>
      <link href="/2024/10/30/C%E8%AF%AD%E8%A8%80/vlog12/"/>
      <url>/2024/10/30/C%E8%AF%AD%E8%A8%80/vlog12/</url>
      
        <content type="html"><![CDATA[<h1 id="数组名与地址"><a href="#数组名与地址" class="headerlink" title="数组名与地址"></a>数组名与地址</h1><p>有这么一个数组，数组名为 arr </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="type">int</span> *p = &amp;arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在这里 &amp;arr[0] 指的是首元素地址，其实本质上数组名就代表的是数组首元素地址<br>接下来我们将对以下几个名字进行区分</p><blockquote><p>1.arr<br>2.sizeof(arr)<br>3.&amp;arr</p></blockquote><h2 id="arr"><a href="#arr" class="headerlink" title="arr"></a>arr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上保留取地址符&amp;和只用数组名，打印对应的地址可以发现<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/98a8ebf2eab0205fff01de1b924f3cd.png" alt="在这里插入图片描述"><br>两个的地址都相同，这就说明了 &amp;arr[0] &#x3D; arr，即数组名就是首元素地址</p><h2 id="sizeof-arr"><a href="#sizeof-arr" class="headerlink" title="sizeof(arr)"></a>sizeof(arr)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键字 sizeof 计算 arr 的大小，你可能会觉得应该输出首元素的大小？<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fc3bebaa5fc315b87c942214733234d.png" alt="在这里插入图片描述"><br>不，这里的 arr 不代表首元素大小，而是表示整个数组，计算整个数组的大小，单位是字节</p><h2 id="arr-1"><a href="#arr-1" class="headerlink" title="&amp;arr"></a>&amp;arr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 &amp;arr 和 &amp;arr+1 地址，假设他是跳过一个字节的地址<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/191e061e0225b00fcc5b7003ad9b19b.png" alt="在这里插入图片描述"><br>很显然，根据代码结果，两段代码地址相差40，那么假设就是错的，所以 &amp;arr 表示的是整个数组的大小</p><p>总结：<strong>只有  &amp;arr 和 sizeof(arr) 有特殊含义，其他情况下的数组名都代表数组首元素地址</strong></p><h1 id="指针访问数组"><a href="#指针访问数组" class="headerlink" title="指针访问数组"></a>指针访问数组</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="type">int</span>* p = arr;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p+i);</span><br><span class="line"> <span class="comment">//scanf(&quot;%d&quot;, arr+i);//也可以这样写</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指针访问数组在一些环境下，会更接近本质，更加简洁易懂<br>将 *(p+i) 换成 p[i] 也是能够正常打印的<br>在这里解引用操作符和下标引用符产生的效果相同</p><p>本质上p[i] 是等价于 *(p+i)，数组元素的访问在编译器处理的时候，也是转换成首元素的地址+偏移<br>量求出元素的地址，然后解引用来访问的</p><h1 id="一维数组传参本质"><a href="#一维数组传参本质" class="headerlink" title="一维数组传参本质"></a>一维数组传参本质</h1><p>在前面学习的函数篇章中，数组可以传递给自定义函数，那么数组传递的本质是什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> sz2 = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sz2 = %d\n&quot;</span>, sz2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz1 = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sz1 = %d\n&quot;</span>, sz1);</span><br><span class="line"> test(arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码调试后可以发现，sz1 &#x3D; 10，sz2 &#x3D; 1，同样的算法应该 sz1 &#x3D; sz2 &#x3D;10 ，但穿过去的形参根据结果 sizeof(arr) 只计算出一个元素的大小，前面我们提到 arr 表示首元素的地址，那么在数组传参的时候，传递的是数组名，也就是数组传参的时候传递的是首元素的地址</p><p>所以函数的形参应该用指针变量来接收一个地址，这也证实了<strong>数组传参的本质是传递首元素地址</strong><br><strong>形参部分既可以写成 int * arr 的指针形式，也可以写成 arr[ ] 的数组形式</strong></p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><p>什么是数组指针？什么是指针数组？这里我们重点介绍一下指针数组<br>指针数组是一个数组，比如整型数组存放的数组，字符数组存放的是字符，那么指针数组存放的就是指针</p><blockquote><p>int* arr[5] &#x3D; 5个int*</p></blockquote><p>每一个数组里的指针都指向一个地址                     </p><h1 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h1><p>正常的一个常见的指针是一级指针，那么在一个指针里面再嵌套一个指针就是二级指针<br>是变量就有地址，指针变量也不例外，比如把指针变量的地址需要存放在另一个指针变量里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> * pi = &amp;i;</span><br><span class="line">  <span class="type">int</span> ** pii = &amp;pi;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>*pii 通过对 pii 中的地址进行解引用，这样找到的是 pi ， *pii 其实访问的就是 pi<br>**pii 先通过 *pii 找到 pi ,然后对 pi 进行解引用操作： *pi ，那找到的是 i</p></blockquote><p>博主最近在准备蓝桥杯的校内比赛，更新可能会有所减缓，大家多多谅解！:)</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/32e5ef8b3198c777f6565b4d21b5e7c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.11——深入理解指针(1)</title>
      <link href="/2024/10/28/C%E8%AF%AD%E8%A8%80/vlog11/"/>
      <url>/2024/10/28/C%E8%AF%AD%E8%A8%80/vlog11/</url>
      
        <content type="html"><![CDATA[<h1 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h1><blockquote><p>内存是用于暂时存储 CPU（中央处理器）正在处理的数据以及与硬盘等外部存储设备交换的数据的硬件设备。它充当了 CPU 和其他设备之间数据传输的中转站，使得计算机各个部件能够高效协同工作</p></blockquote><p>我们在买电脑时，有 8GB&#x2F;16GB&#x2F;32GB等内存选择，读取数据和处理后的放回数据都是经过内存处理的，读取数据和放回数据也要找到相应的地址放回，电脑也像人一样，要进行高效的内存空间管理，所以电脑把<strong>每一个字节的空间作为一个内存单元</strong></p><p>每个内存单元，就好比一间间酒店房间，每个房间能住 8 个比特位，房间（内存单元）都有一个门牌编号(地址)，有了门牌号，就能快速找到相应的房间，即CPU能通过地址快速找到内存空间，在C语言中，<strong>给地址起了个名字叫指针</strong></p><blockquote><p>内存单元编号&#x3D;地址&#x3D;指针</p></blockquote><p>CPU访问内存中的某个字节空间，必须知道这个字节空间在内存的什么位置，而因为内存中字节很多，所以需要给内存进行编址，计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的，在硬件层面上就设计好了</p><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><blockquote><p>int a &#x3D; 5<br>int * p &#x3D; &amp;p</p></blockquote><p>这里的 int* 是变量 p 的类型，也就是一个整型指针，*就是说明 p 是一个指针变量，前面的 int 表示 p 指向的是整型类型的对象，p 中存放的是 a 的地址</p><p>注意指针变量是有大小的</p><blockquote><p>• 32位平台下地址是32个bit位，指针变量大小是4个字节<br>• 64位平台下地址是64个bit位，指针变量大小是8个字节<br>• 注意指针变量的大小和类型是无关的，只要指针类型的变量，在相同的平台下，大小都是相同的</p></blockquote><h1 id="指针操作符"><a href="#指针操作符" class="headerlink" title="指针操作符"></a>指针操作符</h1><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符 &amp;"></a>取地址操作符 &amp;</h2><p>通过取地址操作符取出的地址是一个数值，比如：0x004AAC78,取地址这一操作就是为了把地址取出放在指针变量中，方便后期使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> * pa = &amp;a;<span class="comment">//取出a的地址并存储到指针变量pa中</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符 *"></a>解引用操作符 *</h2><p>那么我们把地址存储在指针变量后要如何将存放在里面的东西取出使用呢？<br>在知道地址的前提下，可以通过解引用操作符找到指针指向的对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"> <span class="type">int</span>* pa = &amp;a;</span><br><span class="line"> *pa = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pa 通过解引用找到 a 并将他的值改成 0 ，就好像通过门牌号找到特定酒店房间里的特定物品，并将其替换了，但这是就会产生一个疑惑，为什么不直接通过对 a 进行赋值改变它的值，不一定非要用指针吧，确实在当前情况下使用指针略显麻烦，但是在程序代码更加复杂，或者是不同的操作情景下，指针是一种妙用，后续的实例将会逐步深入理解指针的必要性和实用性</p><h1 id="指针变量类型的意义"><a href="#指针变量类型的意义" class="headerlink" title="指针变量类型的意义"></a>指针变量类型的意义</h1><p>指针变量的大小与类型无关，只与操作平台有关，在同一平台下，大小都是一样的，那么指针类型的意义在哪儿呢？</p><h2 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0x11223344</span>;</span><br><span class="line"> <span class="type">int</span> *pi = &amp;n; </span><br><span class="line"> *pi = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试我们可以看到，代码会将n的4个字节全部改为0，如果把指针类型改成 char 呢？答案是代码只是将n的第⼀个字节改为0，这说明了指针类型决定了解引用的权限，也就是指针解引用的访问权限</p><h2 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针 + - 整数"></a>指针 + - 整数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"> <span class="type">char</span> *pc = (<span class="type">char</span>*)&amp;n;</span><br><span class="line"> <span class="type">int</span> *pi = &amp;n;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;n);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc+<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>%p用来打印地址，我们可以通过调试查看地址变化</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0f16c385fa1b7f808479b6a43521e23.png" alt="请添加图片描述"></p><p>由图显而易见，char* 类型的指针变量+1跳过1个字节， int* 类型的指针变量+1跳过了4个字节<br>所以指针类型决定了指针加减整数时一步走多大距离</p><h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h2><p>void* 指针是一种特殊的指针，他没有特定的类型，不像int<em>、char</em>那样指向特定的数据所在的内存地址，但也是有指向地址的，不过是对其指向的内容类型，或进行操作时的方式不明确，即void*指针不能进行解引用操作和加减整数操作<br>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span>* pa = &amp;a;</span><br><span class="line"> <span class="type">char</span>* pc = &amp;a;</span><br><span class="line"> *pa = <span class="number">10</span>;</span><br><span class="line"> *pc = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：void*指针接收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">void</span>* pa = &amp;a;</span><br><span class="line"> <span class="type">void</span>* pc = &amp;a;</span><br><span class="line"> *pa = <span class="number">10</span>;</span><br><span class="line"> *pc = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调试可以发现 void<em>指针可以接收不同类型的地址，但无法运算，所以void</em>指针一般用于函数参数部分，用于接受不同类型数据的地址</p><h1 id="const-的修饰"><a href="#const-的修饰" class="headerlink" title="const 的修饰"></a>const 的修饰</h1><p>const是一个关键字，用于声明常量一旦一个变量被声明为const，它的值就不能被修改，<strong>const放在 * 的左边或右边有不同的意义</strong></p><blockquote><p>int * p     没有const修饰<br>int a &#x3D; 10<br>int   const<em>p &#x3D; &amp;a     const 放在 * 的左边做修饰<br>int</em> const p &#x3D; &amp;a      const 放在 * 的右边做修饰</p></blockquote><p><strong>const如果放在*的左边</strong>，修饰的是指针指向的内容<br>保证指针指向的内容不能通过指针来改变，但是指针变量本身的内容可变<br><strong>即 a&#x3D;10 这个值不能改变，变量 p 指向 a 可以改成指向别的变量</strong></p><p><strong>const如果放在*的右边</strong>，修饰的是指针变量本身，保证了指针变量的内容不能修改<br>但是指针指向的内容，可以通过指针改变<br><strong>即 a&#x3D;10 这个值能改变，变量 p 指向 a 不可以改成指向别的变量</strong></p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><h2 id="指针-整数-1"><a href="#指针-整数-1" class="headerlink" title="指针 +- 整数"></a>指针 +- 整数</h2><p>比如打印数组可以用指针打印，更加清晰有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));<span class="comment">//p+i 这⾥就是指针+整数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的分析在我“打印数组的多种方式”的一篇博客有提到</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142187329?spm=1001.2014.3001.5502">打印数组的多种方式</a></p></blockquote><h2 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针 - 指针"></a>指针 - 指针</h2><p>代替 strlen 函数(计算字符或字符串长度)，实现一个自定义的函数 my_strlen 来计算输入字符串的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *p = s;</span><br><span class="line"> <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line"> p++;</span><br><span class="line"> <span class="keyword">return</span> p-s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, my_strlen(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在 main 函数中调用 my_strlen(“abc”) 时，传给 my_strlen 函数的是字符串 “abc” 的首字符的地址</p><p>在 C 语言中，字符串常量（如这里的 “abc”）在内存中是以字符数组的形式存储的，并且会在末尾自动添加一个字符串结束标志 ‘\0’ ,当把字符串常量作为参数传递给函数时，实际上传递的就是这个字符数组的首元素（也就是首字符）的地址</p><p>在 my_strlen 函数内部，通过这个接收到的地址（形参 s），就可以从字符串的开头开始逐个访问字符，直到遇到字符串结束标志 ‘\0’，从而实现对字符串长度的计算</p><h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>野指针是指程序中指向一块已释放内存或未初始化的内存区域的指针，指向的位置是随机的，不可知的<br>它可能指向任意的内存地址，这个随机地址就可能是系统正在使用的或者不允许访问的内存区域</p><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><h3 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> *p;<span class="comment">//局部变量指针未初始化，默认为随机值</span></span><br><span class="line"> *p = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int * p 没有对应的地址存放，那他可能就会存放一个随机的地址</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">11</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span></span><br><span class="line"> *(p++) = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当循环执行到 i &#x3D; 10 及之后时，指针 p 已经超出了数组 arr 的范围。数组 arr 在内存中是连续分配的一段空间，大小刚好能容纳 10 个整数。当 p 不断递增并超出这个范围后，它就指向了数组 arr 所占用内存空间之外的未知区域，此时 p 就变成了野指针</p><h3 id="指向的空间释放"><a href="#指向的空间释放" class="headerlink" title="指向的空间释放"></a>指向的空间释放</h3><p>这部分我们放在后续的动态内存部分讲解，目前知道这种情况会造成野指针形成即可</p><h2 id="如何规避"><a href="#如何规避" class="headerlink" title="如何规避"></a>如何规避</h2><blockquote><p>1.对指针变量都进行初始化操作<br>2.注意数组等变量的范围，小心指针越界<br>3.指针不使用时，及时置之为NULL空指针(定义用来表示指针不指向任何有效的内存地址，也就是指针为        空的情况,当一个指针被赋值为 NULL 时，意味着该指针当前没有指向任何有意义的对象或者内存区域)<br>4.不要返回局部变量的地址</p></blockquote><h1 id="assert-的断言"><a href="#assert-的断言" class="headerlink" title="assert 的断言"></a>assert 的断言</h1><p>assert.h 头文件定义了宏 assert() ，用于在运行时确保程序符合指定条件，如果不符合，就报<br>错终止运行，这个宏常常被称为“断言”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(p != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>p 等于 NULL 程序终止运行，p 不等于 NULL 程序继续执行</p><blockquote><p>使用assert有好有坏<br>好处是它不仅能自动标识文件和出问题的行号，还有⼀种无需更改代码就能开启或关闭 assert() 的机制，如果已经确认程序没有问题，不需要再做断言，就在 #include &lt;assert.h&gt; 语句的前⾯，定义⼀个宏 NDEBUG<br>坏处是因为引入了额外的检查，增加了程序的运行时间</p></blockquote><p>这里拓展一下不同版本的发布环境</p><p><strong>Debug 称为调试版本</strong>，它包含调试信息，并且不作任何优化，便于程序员调试程序，程序员在写代码的时候，需要经常性的调试代码，就将这里设置为 Debug ，这样编译产生的是 Debug 版本的可执行序，其中包含调试信息，是可以直接调试的</p><p><strong>Release 称为发布版本</strong>，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用，当程序员写完代码，测试再对程序进行测试，直到程序的质量符合交付给用户使用标准，这个时候就会设置为 Release ，编译产生的就是 Release 版本的可执行程序，这个版本是用户使的，无需包含调试信息等为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d616a1dba18730630345ea4100816ce.png" alt="请添加图片描述"></p><p>一般宏是在 Debug 中使用的，在VS环境下的 Release 版本不影响用户使用</p><h1 id="指针的应用"><a href="#指针的应用" class="headerlink" title="指针的应用"></a>指针的应用</h1><p>这里介绍两个概念：<strong>传值调用</strong>和<strong>传址调用</strong></p><p>传值调用：当调用一个函数并传递参数时，实际传递给函数的是参数值的副本，也就是说，函数内部对参数进行操作，不会影响到函数外部原来的变量值</p><p>传址调用：当调用一个函数并传递参数时，传递的是变量的地址（在一些语言中也可能表述为传递指向变量的指针等类似含义），这意味着函数内部通过该地址可以直接访问和操作函数外部的原始变量，对参数的任何修改都会反映到原始变量上</p><p>具体实例理解可以参考“交换变量的多种方法(面试题)”这篇博客</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142233884?spm=1001.2014.3001.5502">交换变量的多种方法(面试题)</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e9969227c057594fd439edc9067494e.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.10——进制转化&amp;&amp;操作符进阶</title>
      <link href="/2024/10/26/C%E8%AF%AD%E8%A8%80/vlog10/"/>
      <url>/2024/10/26/C%E8%AF%AD%E8%A8%80/vlog10/</url>
      
        <content type="html"><![CDATA[<h1 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h1><blockquote><p>• 算术操作符：+ 、- 、* 、&#x2F; 、%<br>• 移位操作符：&lt;&lt;、&gt;&gt;<br>• 位操作符：&amp;、|、^<br>• 赋值操作符：&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;<br>• 单目操作符：！、++、–、&amp;、* 、+ 、- 、~ 、sizeof、(类型)<br>• 关系操作符：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、！&#x3D;<br>• 逻辑操作符：&amp;&amp;、||<br>• 条件操作符：？：<br>• 逗号表达式：，<br>• 下标引用：[ ]<br>• 函数调用：( )<br>• 结构体成员访问：. 、-&gt;</p></blockquote><p>上述操作符中，除了单目操作符中的&amp;、*将会在后续指针的vlog中介绍，高亮部分操作符是该篇要重点介绍的，操作符中有些操作符与二进制及其转化有关系，我们先拓展一些相关的基础知识</p><h1 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h1><p>计算机主流的数值表示形式为2进制、8进制、10进制、16进制<br><strong>2进制中满2进1<br>2进制的数字每⼀位都是0~1的数字组成()</strong><br>其余进制同理</p><blockquote><p> 12的2进制：1100<br>    12的8进制：14<br>    12的10进制：12<br>    12的16进制：C<br>   &#x2F;&#x2F;16进制的数值之前写:0x<br>  &#x2F;&#x2F;8进制的数值之前写:0 </p></blockquote><p>进制转化都是以 2 进制为转接点，所以重点介绍 2 进制与其他进制的转换</p><h2 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h2><p>10进制中的123，从右到左依次是个位，十位，百位<br>每一位都有自己的权重，每一位各自乘以各自的权重然后加和就是表示的值</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/76b097aec155a89809486f81db6013f.png" alt="在这里插入图片描述"><br>2进制表示的10进制的12也同理</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/87d352a4a8abc3d9a65c1a72d292321.png" alt="在这里插入图片描述"></p><h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p>假设有个十进制数125转化为2进制，利用短除法可以快速得到转化后的结果</p><blockquote><p>125 % 2 &#x3D; 1<br>62 % 2 &#x3D; 0<br>31 % 2 &#x3D; 1<br>15 % 2 &#x3D; 1<br>7 % 2 &#x3D; 1<br>3 % 2 &#x3D; 1<br>1 % 2 &#x3D; 1 </p></blockquote><p>由下往上依次所得的余数就是125转化的2进制数，即1111101</p><h2 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h2><p>以在2进制转8进制数的时候，从2进制序列中右边低位开始向左每3个2进制位会换算一个8进制位<br>剩余不够3个2进制位的直接换算</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8c7c4a01b056c50ac4b0721880f6898.png" alt="请添加图片描述"><br>如：2进制的01101011，换成8进制：0153，0开头的数字，会被当做8进制</p><p><strong>8 进制转 2 进制也同理，按三个三个转换，去掉转换后前面多出的 0 就是 2 进制了</strong> </p><h2 id="2-4-二进制转十六进制"><a href="#2-4-二进制转十六进制" class="headerlink" title="2.4 二进制转十六进制"></a>2.4 二进制转十六进制</h2><p>在16进制中，两位数用字母表示（大小写都可以）</p><blockquote><p>10 &#x3D; A&#x2F;a<br>11 &#x3D; B&#x2F;b<br>12 &#x3D; C&#x2F;c<br>13 &#x3D; D&#x2F;d<br>14 &#x3D; E&#x2F;e<br>15 &#x3D; F&#x2F;f</p></blockquote><p>在2进制转16进制数的时候，从2进制序列中右边低位开始向左每4个2进制位会换算一个16进制位<br>剩余不够4个2进制位的直接换算</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/71ee74dd78d9fb1099078e89510ef00.png" alt="请添加图片描述"><br>如：2进制的01101011，换成16进制：0x6b，16进制表示的时候前面加0x</p><p><strong>16 进制转 2 进制也同理，按四个四个转换，去掉转换后前面多出的 0 就是 2 进制了</strong></p><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><p>整数的2进制表示方法有三种：原码、反码、补码</p><p>我们知道 int 类型占 32 比特位，有符号整数前提下，<strong>第一位是符号位，后面三十一位是数值位</strong><br><strong>符号位用 0 表示正，1 表示负</strong></p><p>正整数：原反补都<strong>相同</strong><br>负整数：<br><strong>原码</strong>：直接将数值按照正负数的形式翻译成二进制得到<br><strong>反码</strong>：将原码的<strong>符号位不变</strong>，其他位依次按位取反就可以得到反码<br><strong>补码</strong>：<strong>反码+1</strong>就得到补码</p><p>注意：<strong>原码取反＋1即可得到补码，补码取反+1也能得到原码</strong></p><p>计算机内存中以补码的形式保存</p><blockquote><p>在补码运算中，符号位可以和数值位一起参与运算，不需要额外的判断和处理。例如，在进行加法运算时，不管是正数相加还是正数和负数相加，或者负数相加，都可以按照相同的加法规则进行运算，而不需要单独考虑符号位的处理，这种特性使得计算机在进行算术运算时更加高效和准确</p></blockquote><h1 id="操作符进阶"><a href="#操作符进阶" class="headerlink" title="操作符进阶"></a>操作符进阶</h1><h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><p>移位操作符分为右移操作符 &gt;&gt; ,左移操作符 &lt;&lt; ,<strong>其操作数只能是整数</strong>，<strong>不要移动负数位</strong></p><h3 id="左移操作符"><a href="#左移操作符" class="headerlink" title="左移操作符"></a>左移操作符</h3><p><strong>左边抛弃，右边补0</strong><br>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8075a2fc42a4d48608739a4edb7de11.png" alt="在这里插入图片描述"></p><h3 id="右移操作符"><a href="#右移操作符" class="headerlink" title="右移操作符"></a>右移操作符</h3><p><strong>逻辑右移：左边补0，右边抛弃</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9258338e1b347bdf2a5fa277740c58d.png" alt="在这里插入图片描述"><br><strong>算术右移：左边用原值的符号位补充，右边抛弃</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/65b27ec3b60b0530a95ebb575c96fa8.png" alt="在这里插入图片描述"></p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>位操作符的操作数必须是整数</p><blockquote><p>按位与：&amp;<br>按位或：|<br>按位异或：^<br>按位取反：~</p></blockquote><p>以下举例a &#x3D; 5,b &#x3D; 3</p><h3 id=""><a href="#" class="headerlink" title="&amp;"></a>&amp;</h3><p>当两个对应的二进制位都为 1 时，结果位才为 1，否则为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000000 01   <strong>a &amp; b</strong></p></blockquote><h3 id="-1"><a href="#-1" class="headerlink" title="|"></a>|</h3><p>当两个对应的二进制位中有一个为 1，结果位就为 1<br>当两个位都为 0 时，结果位才为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000001 11   <strong>a | b</strong></p></blockquote><h3 id="-2"><a href="#-2" class="headerlink" title="^"></a>^</h3><p>当两个对应的二进制位不同（一个为 0，另一个为 1）时，结果位为 1<br>当两个位相同（都为 0 或都为 1）时，结果位为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000001 10   <strong>a ^ b</strong></p></blockquote><h3 id="-3"><a href="#-3" class="headerlink" title="~"></a>~</h3><p>将每个二进制位中的 0 变为 1，1 变为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 1111 1111 11 1111 1111 11 1111 1111 10 10   <strong>~a</strong><br> 1111 1111 11 1111 1111 11 1111 1111 11 00   <strong>~b</strong></p></blockquote><h2 id="结构体访问操作符"><a href="#结构体访问操作符" class="headerlink" title="结构体访问操作符"></a>结构体访问操作符</h2><h3 id="结构体的简单介绍"><a href="#结构体的简单介绍" class="headerlink" title="结构体的简单介绍"></a>结构体的简单介绍</h3><p>结构是⼀些值的集合，这些值称为成员变量<br>结构的每个成员可以是不同类型的变量，如：标量、数组、指针，甚至是其他结构体</p><p><strong>结构体的语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><strong>比如想要描述一名学生：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line">   <span class="type">int</span> age;<span class="comment">//年龄 </span></span><br><span class="line">   <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line">   <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号 </span></span><br><span class="line"> &#125;; <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure><p><strong>结构体的定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   <span class="type">int</span> y;</span><br><span class="line"> &#125;p1;        <span class="comment">//声明类型的同时定义变量p1        </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p2</span>;</span>    <span class="comment">//定义结构体变量p2 </span></span><br></pre></td></tr></table></figure><p><strong>结构体的初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p3</span> =</span> &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>        </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="type">char</span> name[<span class="number">15</span>];  </span><br><span class="line">  <span class="type">int</span> age;   </span><br><span class="line">&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s2</span> =</span> &#123;.age=<span class="number">20</span>, .name=<span class="string">&quot;lisi&quot;</span>&#125;;<span class="comment">//指定顺序初始化</span></span><br></pre></td></tr></table></figure><h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>语法结构：结构体变量.成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x: %d y: %d\n&quot;</span>, p.x, p.y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h3><p>语法结构：结构体指针-&gt;成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> struct Point </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span> =</span> &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> *<span class="title">ptr</span> =</span> &amp;p;</span><br><span class="line">ptr-&gt;x = <span class="number">10</span>;</span><br><span class="line">ptr-&gt;y = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d y = %d\n&quot;</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分如果看不太明白的话可以先了解一下后面的指针部分，再来理解代码会容易很多</p><h1 id="操作符的优先级，结合性"><a href="#操作符的优先级，结合性" class="headerlink" title="操作符的优先级，结合性"></a>操作符的优先级，结合性</h1><p>优先级指的是，如果⼀个表达式包含多个运算符，哪个运算符应该优先执行<br>各种运算符的优先级是不⼀样的</p><p>如果两个运算符优先级相同，优先级没办法确定先计算哪个了，这时候就看结合性了，则根据运算符<br>是左结合，还是右结合，决定执行顺序</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/daa8aae6b4482d75e3b86b390c625ef.png" alt="请添加图片描述"></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cf8ddae9fb79303b2b55ecfb69b151c.png" alt="请添加图片描述"></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0a202ab80069a8d8ab7fda4d8a27d8.png" alt="请添加图片描述"><br>一般来说，可以这样记</p><blockquote><p>！&gt; 算术运算符 &gt; 关系运算符 &gt; 逻辑运算(&amp;&amp; &gt; ||) &gt; 赋值运算符</p></blockquote><h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><h2 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h2><p>C语言中整型算术运算总是以<strong>普通整型</strong>进行的<br>为了确保每个整型都是普通类型的便于系统运算，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为<strong>整型提升</strong></p><p><strong>保证计算精度</strong><br>例如，在一个 8 位系统中，char类型的取值范围是 - 128 到 127。假设有两个char类型变量a &#x3D; 120和b &#x3D; 10，它们的二进制表示分别是01111000和00001010，如果直接以char类型进行相加，结果可能会溢出，因为char类型的结果可能无法正确存储130这个值。而整型提升将它们转换为int类型（通常是 32 位，有足够的空间来存储运算结果），可以避免这种溢出情况，保证运算结果的准确性</p><p><strong>符合 CPU 运算习惯</strong><br>例如，在很多现代处理器架构中，加法指令可能是针对 32 位或 64 位整数设计的。当对char或short类型进行加法运算时，将它们提升为int类型可以直接使用这些高效的指令，而不需要专门为较小的数据类型设计特殊的、可能效率较低的运算指令</p><p><strong>提升方式：</strong></p><blockquote><ol><li>有符号整数提升是按照变量的数据类型的符号位来提升的</li><li>无符号整数提升，高位补0</li></ol></blockquote><h2 id="算术转化"><a href="#算术转化" class="headerlink" title="算术转化"></a>算术转化</h2><p>如果某个操作符的各个操作数属于不同的类型，那么除非其中⼀个操作数的转换为另⼀个操作数的类<br>型，否则操作就无法进行，下面的层次体系称为<strong>寻常算术转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="type">int</span></span><br></pre></td></tr></table></figure><p>如果某个操作数的类型在上面这个列表中排名靠后<br>那么首先要转换为另外一个操作数的类型后执行运算</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da5c088aaed8c19be39c25e1ce4fde2.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.9——青蛙跳台阶、汉诺塔</title>
      <link href="/2024/10/24/C%E8%AF%AD%E8%A8%80/vlog9/"/>
      <url>/2024/10/24/C%E8%AF%AD%E8%A8%80/vlog9/</url>
      
        <content type="html"><![CDATA[<h1 id="青蛙跳台阶专题"><a href="#青蛙跳台阶专题" class="headerlink" title="青蛙跳台阶专题"></a>青蛙跳台阶专题</h1><blockquote><p>题目介绍： 一共有 n 阶台阶，有一只青蛙能向上跳一阶台阶或两阶台阶<br>问：当青蛙跳到第n阶台阶时，有多少种跳法？</p></blockquote><p>这个问题乍一看有些摸不着头脑，我们可以通过举例的方式来找到问题的规律<br>这里我们设青蛙跳上第 n 阶台阶有 Fib(n) 种方法</p><blockquote><p>n &#x3D; 1 时，青蛙跳上第 1 阶台阶的方法：1 种<br>n &#x3D; 2 时，青蛙跳上第 2 阶台阶的方法：2 种<br>n &#x3D; 3 时，青蛙跳上第 3 阶台阶的方法：3 种<br>n &#x3D; 4 时，青蛙跳上第 4 阶台阶的方法：5 种<br>……<br>n &#x3D; n-1 时，青蛙跳上第 n-1 阶台阶的方法：Fib(n-2)+Fib(n-3) 种<br>n &#x3D; n 时，青蛙跳上第 n 阶台阶的方法：Fib(n-1)+Fib(n-2) 种</p></blockquote><p>观察可得，本质上青蛙跳台阶问题实质上就是一个斐波那契数列<br>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4a23d34ba5b950a1fc8e07ec516d52a.png" alt="在这里插入图片描述"><br>那么根据 vlog.8 中的斐波那契数列求和代码可以很容易写出解决方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib(n - <span class="number">1</span>) + Fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="type">int</span> ret = Fib(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fib(%d)=%d\n&quot;</span>, x, ret);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码在源代码的基础上只进行了略微修改，用的是递归的方法，同样的也可以用迭代的方法简化代码，减少内存占用，防止栈溢出的风险，详细请看上一篇vlog</p><h1 id="汉诺塔专题"><a href="#汉诺塔专题" class="headerlink" title="汉诺塔专题"></a>汉诺塔专题</h1><blockquote><p>题目介绍：从左到右有A、B、C三个柱子，刚开始在A柱上从上到下套有1、2、3盘，其大小逐渐变大，盘子只能一个一个挪，借助于B柱，将A柱上的盘全部转移到C柱上，挪的过程中，盘子一定是上小下大<br>问：转移3个盘子需要多少步？</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5e7f3f50751431c58b874e487ab88f7.png" alt="在这里插入图片描述"><br>还是通过举例的方法，从三个盘子开始入手会更加简单的发现规律：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/64fb7310b17b6fe222bb2d6ecc18e93.png" alt="在这里插入图片描述"></p><blockquote><p>先把1盘挪到C柱，2盘挪到B柱，再把1盘挪回B柱，然后把3盘挪到C柱<br>即1、2盘为n-1个盘子</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a18020dd568a613784b1caf5d7711a.png" alt="请添加图片描述"></p><blockquote><p>再接着把1盘挪到A柱<br>即1盘为n-2个盘子</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f03e23fcc2825f6d46c8feda98e5eee.png" alt="在这里插入图片描述"></p><blockquote><p>最后把2盘放到C柱上，再把1盘放到C柱上</p></blockquote><p>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/67b1fe9a7709968b5a9d84b3d35042f.png" alt="在这里插入图片描述"></p><p>显而易见，这里移动了7次<br>我们定义移动的次数为F(n)</p><blockquote><p>1 个盘子时，需要移动 1 次<br>2 个盘子时，需要移动 3 次<br>3 个盘子时，需要移动 7 次<br>4 个盘子时，需要移动 15 次<br>……<br>n-1 个盘子时，需要移动 2F(n-2) + 1 次<br>n 个盘子时，需要移动 2F(n-1) + 1 次</p></blockquote><p>观察可得公式为 F(n) &#x3D; 2F(n-1) + 1 </p><p>那我们梳理一下过程可知<br>1、首先把n-1个盘子移动到第二根中转柱B上<br>2、再把最后一个也就是最大的那一个盘子移动到第三根目标柱C上<br>3、最后再把剩下的n-1个盘子移动到第三根目标柱C上</p><p>函数自己调用自己，那么可以知道这本质上也是个递归问题，写出以下移动过程代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> pos1, <span class="type">char</span> pos2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %c-&gt;%c &quot;</span>, pos1, pos2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> pos1, <span class="type">char</span> pos2, <span class="type">char</span> pos3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">move(pos1, pos3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hanoi(n - <span class="number">1</span>, pos1, pos3, pos2);</span><br><span class="line">move(pos1, pos3);</span><br><span class="line">hanoi(n - <span class="number">1</span>, pos2, pos1, pos3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">hanoi(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能看到这里会有些迷糊，其实只要理解了递归的思想，该问题也就迎刃而解了</p><p>有意思的是，在汉诺塔传说中，僧侣想要把64个金片同样从A柱转移到B柱<br>根据公式需要2^64-1次，在古印度那个时代这显然是不可能依靠人一个一个搬运完成的</p><p>如果还有不理解的可以点击文章开头的链接看我的上一篇 vlog 进行辅助知识理解 <strong>OwO</strong></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c39ee5e0ca0444834a53f7e4867d841.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.8——函数递归</title>
      <link href="/2024/10/22/C%E8%AF%AD%E8%A8%80/vlog8/"/>
      <url>/2024/10/22/C%E8%AF%AD%E8%A8%80/vlog8/</url>
      
        <content type="html"><![CDATA[<h1 id="递归的介绍"><a href="#递归的介绍" class="headerlink" title="递归的介绍"></a>递归的介绍</h1><p>在 vlog.2 的 printf 函数的返回值举例中，我们使用多次递归的方式实现了同一个函数的返回值调用，但这只是一个简易的递归，不算真正意义上的递归，那么什么是递归？</p><blockquote><p>在C语言中，<strong>递归就是函数自己调用自己</strong>，如果函数的递归没有限制条件，一直无限循环调用下去，代码最终就会陷入死循环，导致<strong>栈溢出</strong>（Stack overflow）</p></blockquote><p>递归就是递推的意思，递归的思考方式就是将<strong>大事化小</strong>，将复杂的程序化成简单的代码格式，也就是化成一个个子问题求解，知道子程序不再被分解，递归就结束了</p><h1 id="递归的限制条件"><a href="#递归的限制条件" class="headerlink" title="递归的限制条件"></a>递归的限制条件</h1><p>值得注意的是，递归也存在限制条件</p><blockquote><p>• 递归存在限制条件，当满足这个限制条件的时候，递归便不再继续<br>• 每次递归调用之后越来越接近这个限制条件</p></blockquote><h1 id="递归实战应用"><a href="#递归实战应用" class="headerlink" title="递归实战应用"></a>递归实战应用</h1><h2 id="求-n-的阶乘"><a href="#求-n-的阶乘" class="headerlink" title="求 n 的阶乘"></a>求 n 的阶乘</h2><blockquote><p>由数学知识可知：n！&#x3D; n ∗ (n−1)! 当 n &#x3D;&#x3D; 0 的时候，此时 n 的阶乘是 1 ，n &gt; 0时阶乘可根据公式计算</p></blockquote><p>那么我们可以写出阶乘函数 Fact ，Fact(n) 是求 n 的阶乘，那么Fact(n-1)就是求 n-1 的阶乘<br>此处不考虑 n 过大导致栈溢出的情况，只考虑合理范围内的 n</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span> ret = Fact(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的递归思想可以根据画图很容易的理解<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a92e64b2dfae4900123d936d65d22d.png" alt="在这里插入图片描述"></p><h2 id="顺序打印一个整数的每一位"><a href="#顺序打印一个整数的每一位" class="headerlink" title="顺序打印一个整数的每一位"></a>顺序打印一个整数的每一位</h2><p>输入⼀个整数m，按照顺序打印整数的每⼀位<br>如果n是⼀位数，n的每⼀位就是n自己<br>n是超过1位数的话，就得拆分每⼀位<br>比如：</p><blockquote><p>1234%10就能得到4，然后1234&#x2F;10得到123，这就相当于去掉了4<br>然后继续对123%10，就得到了3，再除10去掉3，以此类推<br>不断的 %10 和 &#x2F;10 操作，直到1234的每一位都得到<br>但是这里有个问题就是得到的数字顺序是倒着的</p></blockquote><p>假设我们用函数Print(n)打印n的每一位<br>那么我们知道1234 % 10 &#x3D; 4，1234 &#x2F; 10 &#x3D; 123</p><blockquote><p> Print(1234)就可以拆分为两步：</p><ol><li>Print(1234&#x2F;10)  &#x2F;&#x2F;打印123的每⼀位 </li><li>printf(1234%10) &#x2F;&#x2F;打印4</li></ol></blockquote><p>以此类推,利用递归思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Print(<span class="number">1234</span>)</span><br><span class="line">==&gt;Print(<span class="number">123</span>)                   +<span class="built_in">printf</span>(<span class="number">4</span>)</span><br><span class="line">==&gt;Print(<span class="number">12</span>)          + <span class="built_in">printf</span>(<span class="number">3</span>)</span><br><span class="line">==&gt;Print(<span class="number">1</span>) + <span class="built_in">printf</span>(<span class="number">2</span>)</span><br><span class="line">==&gt;<span class="built_in">printf</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>直到被打印的数字变成一位数的时候，就不需要再拆分，递归结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">9</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     Print(n/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    Print(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的函数不断地调用，当函数调用完之后依次从最后一个子程序往第一个程序打印</p><h1 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h1><p> Fact函数是可以产生正确的结果，但是在递归函数调用的过程中涉及一些运行时的开销</p><blockquote><p>在C语言中每一次函数调用，都需要为本次函数调用在内存的栈区，申请一块内存空间来保存函数调<br>用期间的各种局部变量的值，这块空间被称为运行时堆栈，或者函数栈帧。<br>函数不返回，函数对应的栈帧空间就⼀直占用，所以如果函数调用中存在递归调用的话，每⼀次递归<br>函数调用都会开辟属于自己的栈帧空间，直到函数递归不再继续，开始回归，才逐层释放栈帧空间，<br>所以如果采用函数递归的方式完成代码，递归层次太深，就会浪费太多的栈帧空间，也可能引起栈溢<br>出的问题，而且也很耗时间（后期将推出函数栈帧专题）</p></blockquote><p>通常如果使用递归不合适，就可以使用迭代的方式，那什么是迭代呢？<br>迭代简单来讲就是用循环的方式运行</p><p>举个例子：求第 n 个斐波那契数<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/44bf3109470c7c32176d1af9f53cc0b.png" alt="在这里插入图片描述"><br>如果使用的是递归的方法的话，层次会非常深，冗余的计算会非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">     count++;<span class="comment">//统计第3个斐波那契数被计算的次数</span></span><br><span class="line"> <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> <span class="type">int</span> ret = Fib(n);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>根据 count 的次数，在计算第40个斐波那契数的时候，使用递归方式，第3个斐波那契数就被重复计算了39088169次，这些计算是非常冗余的。所以斐波那契数的计算，使用递归是非常不明智的，我们就得想迭代的方式解决</p><p>那么迭代的话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(n&gt;<span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> c = a+b;</span><br><span class="line"> a = b;</span><br><span class="line"> b = c;</span><br><span class="line"> n--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不难看出，似乎用迭代的方式去实现这个代码，效率就要高出很多了，但同时我们也不要一直使用，会容易出现程序错误</p><h1 id="递归经典问题的拓展"><a href="#递归经典问题的拓展" class="headerlink" title="递归经典问题的拓展"></a>递归经典问题的拓展</h1><p>青蛙跳台阶问题<br>汉诺塔问题</p><p>这两个问题将在下一期vlog拓展推出，欢迎大家看我的下一期推文</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dd9199b39808c8738b61b5e84036f4d.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.7——数组函数实践</title>
      <link href="/2024/10/20/C%E8%AF%AD%E8%A8%80/vlog7/"/>
      <url>/2024/10/20/C%E8%AF%AD%E8%A8%80/vlog7/</url>
      
        <content type="html"><![CDATA[<p>扫雷游戏专题</p><p>掌握了前面的数组与函数的知识，我们可以制作一款大多电脑上都有的简易版经典小游戏——扫雷<br>游戏要求：<br>1.游戏使用菜单可以选择继续游玩或退出游戏<br>2.扫雷为 9 * 9 格子的棋盘<br>3.默认随机布置 10 个雷<br>4.排查雷：<br>如果该位置不是雷，就显示周围有几个雷<br>如果该位置是雷，就炸死游戏结束<br>把除 10 个雷以外的空格都找出来就算游戏胜利<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/98fe0980f23405fa352481ac087957c.png" alt="在这里插入图片描述"></p><h1 id="扫雷游戏的设计分析"><a href="#扫雷游戏的设计分析" class="headerlink" title="扫雷游戏的设计分析"></a>扫雷游戏的设计分析</h1><h2 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h2><p>在扫雷过程中，布置的雷和排查出的雷的信息要分别存储在两个棋盘上<br>因为我们需要在9<em>9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建⼀个9</em>9的数组来存放信息<br>如果这个位置是雷，我们就存放字  1 ，不是雷就存放  0<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/52cdf6b358f3b8c4c2fdf1b3fe212a3.png" alt="在这里插入图片描述"><br>假设我们排查（2，1）这个坐标，访问周围一圈8个蓝色的位置，查获一个雷</p><p>假设我们排查（5，8）这个坐标，访问周围一圈8个蓝色的位置，最下面三个坐标会越界<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/570ae017a400b6eb6b2a596ef06353c.png" alt="在这里插入图片描述"><br>为了防止越界的情况出现，在设计的时候，我们将数组扩大一圈，雷还是布置在原来的地方，周围一圈空在那儿就行了，所以我们将存放数据的数组创建成11*11是比较合适<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d0c74b3d0d2ca33b77210d8eb71b0a0.png" alt="在这里插入图片描述"><br>再接着，假设我们排查了某个位置，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的，那这个雷的个数信息存放在哪里呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能产生混淆和打印上的困难</p><p>解决办法：<br>雷和非雷的信息不要使用数字，使用字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便</p><p>这里我们采用另外⼀种方案，我们专门给⼀个棋盘（对应一个数组mine）存放布置好的雷的信息，再<br>给另外一个棋盘（对应另外一个数组show）存放排查出的雷的信息，这样就互不干扰了，把雷布置到<br>mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期<br>排查参考</p><p>同时为了保持神秘，show数组开始时初始化为字符  ‘ * ‘ ，为了保持两个数组的类型⼀致，可以使用同一<br>套函数处理，mine数组最开始也初始化为字符 ‘ 0 ‘ ，布置雷改成 ‘ 1 ‘<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a9949132f774a195516a186169845d1.png" alt="在这里插入图片描述"></p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>为了游戏的代码清晰明辨，根据函数的声明和定义，设计三个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.c <span class="comment">//⽂件中写游戏的测试逻辑  </span></span><br><span class="line">game.c <span class="comment">//⽂件中写游戏中函数的实现等</span></span><br><span class="line">game.h <span class="comment">//⽂件中写游戏需要的数据类型和函数声明等</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="扫雷游戏的实现"><a href="#扫雷游戏的实现" class="headerlink" title="扫雷游戏的实现"></a>扫雷游戏的实现</h1><p><strong>game.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> EASY_COUNT 10</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> COLS COL+2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化棋盘</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印棋盘</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//布置雷</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//排查雷</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>game.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">         <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">              &#123;</span><br><span class="line">                    board[i][j] = <span class="built_in">set</span>;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span>  i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------扫雷游戏-------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="comment">//布置10个雷</span></span><br><span class="line">        <span class="comment">//⽣成随机的坐标，布置雷</span></span><br><span class="line">        <span class="type">int</span> count = EASY_COUNT;</span><br><span class="line">        <span class="keyword">while</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">int</span> x = rand() % row + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> y = rand() % col + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        board[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        count--;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">GetMineCount</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mine[x<span class="number">-1</span>][y]+mine[x<span class="number">-1</span>][y<span class="number">-1</span>]+mine[x][y - <span class="number">1</span>]+mine[x+<span class="number">1</span>][y<span class="number">-1</span>]</span><br><span class="line">        +mine[x+<span class="number">1</span>][y]+mine[x+<span class="number">1</span>][y+<span class="number">1</span>]+mine[x][y+<span class="number">1</span>]+mine[x<span class="number">-1</span>][y+<span class="number">1</span>] - <span class="number">8</span> * <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (win &lt;row*col- EASY_COUNT)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请输⼊要排查的坐标:&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= row &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= col)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，你被炸死了\n&quot;</span>);</span><br><span class="line">                                DisplayBoard(mine, ROW, COL);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">//该位置不是雷，就统计这个坐标周围有⼏个雷</span></span><br><span class="line">                                <span class="type">int</span> count = GetMineCount(mine, x, y);</span><br><span class="line">                                show[x][y] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                                DisplayBoard(show, ROW, COL);</span><br><span class="line">                                win++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;坐标⾮法，重新输⼊\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (win == row * col - EASY_COUNT)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，排雷成功\n&quot;</span>);</span><br><span class="line">                DisplayBoard(mine, ROW, COL);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>test.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*****   1. play   *****\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*****   0. exit   *****\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">char</span> mine[ROWS][COLS];<span class="comment">//存放布置好的雷</span></span><br><span class="line">       <span class="type">char</span> show[ROWS][COLS];<span class="comment">//存放排查出的雷的信息</span></span><br><span class="line">       <span class="comment">//初始化棋盘</span></span><br><span class="line">       <span class="comment">//1. mine数组最开始是全&#x27;0&#x27;         </span></span><br><span class="line">       <span class="comment">//2. show数组最开始是全&#x27;*&#x27; </span></span><br><span class="line">       InitBoard(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       InitBoard(show, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">       <span class="comment">//打印棋盘</span></span><br><span class="line">       <span class="comment">//DisplayBoard(mine, ROW, COL);</span></span><br><span class="line">       DisplayBoard(show, ROW, COL);</span><br><span class="line">       <span class="comment">//1. 布置雷 </span></span><br><span class="line">       SetMine(mine, ROW, COL);</span><br><span class="line">       <span class="comment">//DisplayBoard(mine, ROW, COL);</span></span><br><span class="line">       <span class="comment">//2. 排查雷 </span></span><br><span class="line">       FindMine(mine, show, ROW, COL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">       srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">               menu();</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">               <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">               <span class="keyword">switch</span> (input)</span><br><span class="line">               &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                       game();</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;选择错误，重新选择\n&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (input);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫雷游戏的扩展"><a href="#扫雷游戏的扩展" class="headerlink" title="扫雷游戏的扩展"></a>扫雷游戏的扩展</h1><p>是否可选择游戏难度？<br>是否可标记雷？<br>是否可加上排雷时间显示？<br>如果排查位置不是雷，周围也没有雷，可以展开周围的一片</p><p>以上拓展就不过多展示，可以根据前边所学知识自行拓展<br>在线扫雷游戏：<a href="http://www.minesweeper.cn/">http://www.minesweeper.cn/</a></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6ce74d252551be3ce82eea65707eb91.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.6——函数</title>
      <link href="/2024/10/18/C%E8%AF%AD%E8%A8%80/vlog6/"/>
      <url>/2024/10/18/C%E8%AF%AD%E8%A8%80/vlog6/</url>
      
        <content type="html"><![CDATA[<p>函数在我们小学就开始接触，比如：一次函数 y &#x3D; kx + b<br>在C语言中也引入了数学中的函数概念，也叫做子程序，<strong>C语言中的函数就是⼀个完成某项特定的任务的⼀小段代码</strong>，程序其实就是由多个子程序组合而成，提升了开发软件的效率</p><h1 id="函数的介绍"><a href="#函数的介绍" class="headerlink" title="函数的介绍"></a>函数的介绍</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>C语言中规定了各种法则，C语言本身并不提供库函数，但编译器厂商根据国际标准的ANSIC规定的一些函数标准给出了一些函数，这些函数就被称为<strong>库函数</strong></p><p>前面我们学过的printf，scanf等都是库函数中现成的可以直接使用的函数，这些函数方便了程序员对代码功能的实现，一定程度上提升了效率性和保障性</p><p>学习库函数的各种函数对一名合格的程序员来说很重要<br>这是两个学习网站：<br><strong>C&#x2F;C++官方的链接：<a href="https://zh.cppreference.com/w/c/header">https://zh.cppreference.com/w/c/header</a><br>cplusplus.com：<a href="https://legacy.cplusplus.com/reference/clibrary/">https://legacy.cplusplus.com/reference/clibrary/</a></strong></p><p>网站函数的学习形式：</p><ol><li>函数原型</li><li>函数功能介绍</li><li>参数和返回类型说明</li><li>代码举例</li><li>代码输出</li><li>相关知识链接</li></ol><p>注意：库函数是在标准库中对应的头文件中声明的，所以库函数的使用，务必包含对应的头文件，不包含是可能会出现⼀些问题的</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>光有库函数提供的函数远远不足以实现所有的代码功能，所以程序员自行写了许多函数以实现各种功能，这种代码就叫做<strong>自定义函数</strong>，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret_type <span class="title function_">fun_name</span><span class="params">(形式参数)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>• ret_type 是函数返回类型</strong><br>有时候可以是void，表示什么都不返回，当不需要返回数值时，也可以不写返回值的类型</p><p><strong>• fun_name 是函数名</strong><br>函数的名字与其功能相关联，所以函数起名时要根据其功能起有意义的名字，便于程序员解读</p><p><strong>• 括号中放的是形式参数</strong><br>参数要交代清楚类型，名字和参数个数</p><p><strong>• {}括起来的是函数体</strong><br>也就是函数完成功能实现的过程</p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>举个简单的例子：写一个加法函数，完成两个数字的相加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"> <span class="comment">//调⽤加法函数，完成a和b的相加</span></span><br><span class="line"> <span class="comment">//求和的结果放在r中</span></span><br><span class="line"> <span class="comment">//to do</span></span><br><span class="line"> <span class="type">int</span> ret = Add(a,b)</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>• a 和 b 为函数的实参</strong><br>实参就是真实传递给函数的参数</p><p><strong>• x 和 y 为函数的形参</strong><br>形参只在形式上存在，并不会一直存在，只有在调用函数时向内存申请空间，使用完函数后形参又被销毁</p><p><strong>• 形参和实参各自是独立的空间</strong><br>在VS2022的监视窗口上可以观察到<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d5387da4bbcac33364b3f09756a407f.png" alt="在这里插入图片描述"><br>x和y确实得到了a和b的值，但是x和y的地址和a和b的地址是不⼀样的<br>所以我们可以理解为形参是实参的⼀份临时拷贝，这叫做<strong>传值调用</strong>（后面在指针部分会详细介绍）</p><h2 id="数组做函数参数"><a href="#数组做函数参数" class="headerlink" title="数组做函数参数"></a>数组做函数参数</h2><p>举个例子：写⼀个函数将⼀个整型数组的内容，全部置为0，再写⼀个函数打印数组的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_arr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> arr[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> set_arr(arr, sz);<span class="comment">//设置数组内容为-1</span></span><br><span class="line"> print_arr(arr, sz);<span class="comment">//打印数组内容</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的set_arr函数要能够对数组内容进行设置，就得把数组作为参数传递给函数，同时函数内部在设<br>置数组每个元素的时候，也得遍历数组，需要知道数组的元素个数。所以我们需要给set_arr传递2个参<br>数，⼀个是数组，另外⼀个是数组的元素个数，仔细分析print_arr也是⼀样的，只有拿到了数组和元<br>素个数，才能遍历打印数组的每个元素</p><p>• 函数的形式参数要和函数的实参<strong>个数匹配</strong></p><p>• 函数的实参是数组，形参也是可以写成<strong>数组形式</strong>的</p><p>• 形参如果是一维数组，<strong>数组大小可以省略不写</strong></p><p>• 形参如果是二维数组，<strong>行可以省略，但是列不能省略</strong></p><p>• 数组传参，<strong>形参是不会创建新的数组的</strong></p><p>• 形参操作的数组和实参的数组是<strong>同一个数组</strong></p><h1 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h1><p>在使用函数的时候，比如 main 函数， 自定义的 Add 函数常常需要返回值，也就是 <strong>return 语句</strong></p><p>• return 后边可以是⼀个数值，也可以是⼀个表达式，如果是表达式则先执行表达式，再返回表达式的结果</p><p>• return 后边也可以什么都没有，直接写 return，这种写法适合函数返回类型是 void 的情况</p><p>• return 返回的值和函数返回类型不⼀致，系统会⾃动将返回的值隐式转换为函数的返回类型</p><p>• return 语句执行后，函数就彻底返回，后边的代码不再执行</p><p>• 如果函数中存在 if 等分支的语句，则要保证每种情况下都有 return 返回，否则会出现编译错误</p><h1 id="嵌套调用和链式访问"><a href="#嵌套调用和链式访问" class="headerlink" title="嵌套调用和链式访问"></a>嵌套调用和链式访问</h1><p><strong>嵌套调用</strong>就是函数间的相互调用，函数间的有效相互调用才实现了大型程序<br>举个例子：假设我们计算某年某月有多少天？如果要函数实现，可以设计2个函数</p><p>• is_leap_year()：根据年份确定是否是闰年</p><p>• get_days_of_month()：调用 is_leap_year 确定是否是闰年后，再根据月计算这个月的天数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_leap_year</span><span class="params">(<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(((y%<span class="number">4</span>==<span class="number">0</span>)&amp;&amp;(y%<span class="number">100</span>!=<span class="number">0</span>))||(y%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_days_of_month</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> days[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"> <span class="type">int</span> day = days[m];</span><br><span class="line"> <span class="keyword">if</span> (is_leap_year(y) &amp;&amp; m == <span class="number">2</span>)</span><br><span class="line"> day += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;y, &amp;m);</span><br><span class="line"> <span class="type">int</span> d = get_days_of_month(y, m);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>链式访问</strong>就是将一个函数的返回值作为另外一个函数的参数，像链条一样函数串起来就是函数的链式访问<br>举个有趣的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">43</span>)));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解该代码的关键是理解 printf 的返回值是啥？<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ed4bc9c57e3d3895e4bc91e19070812.png" alt="在这里插入图片描述"><br>printf函数返回的是打印在屏幕上的字符的个数<br>我们就第⼀个printf打印的是第⼆个printf的返回值，第二个printf打印的是第三个printf的返回值<br>第三个printf打印43，在屏幕上打印2个字符，再返回2<br>第二个printf打印2，在屏幕上打印1个字符，再放回1<br>第一个printf打印1<br>所以屏幕上最终打印：4321</p><h1 id="函数的声明和定义"><a href="#函数的声明和定义" class="headerlink" title="函数的声明和定义"></a>函数的声明和定义</h1><h2 id="单个文件和多个文件"><a href="#单个文件和多个文件" class="headerlink" title="单个文件和多个文件"></a>单个文件和多个文件</h2><p><strong>单个文件</strong>中，还是上面闰年的例子，int is_leap_year 是函数的定义，int ret &#x3D; is_leap_year 是函数的调用</p><p>如果把 is_leap_year 函数放在main函数后面呢？<br>is_leap_year 函数调用的时候，并没有发现前面有 is_leap_year 的定义，就会报警告</p><p>那么如何让解决呢？<br>就是函数调用之前先声明一下 is_leap_year 这个函数，声明函数只要交代清楚：函数名，函数的返回类型和函数的参数就行了</p><p>上面闰年的例子就是正确的写法</p><p><strong>多个文件</strong>中，一般在企业中我们写代码时候，代码可能比较多，不会将所有的代码都放在一个文件中，我们往往会根据程序的功能，将代码拆分放在多个文件中一般情况下，函数的声明、类型的声明放在头文件（.h）中，函数的实现是放在源文件（.c）文件中</p><h2 id="static-和-extern"><a href="#static-和-extern" class="headerlink" title="static 和 extern"></a>static 和 extern</h2><p>在C语言中，static 和 extern 是关键字<br>static ：静态的意思，用于<strong>修饰全局变量，局部变量，函数</strong><br>extern ：用于<strong>声明外部符号</strong></p><p>这里拓展几个名词：<br><strong>作用域</strong>：⼀段程序代码中所用到的名字并不总是有效可用的<br>而限定这个名字的可用性的代码范围就是这个名字的作用域</p><p><strong>生命周期</strong>：变量的创建(申请内存)到变量的销毁(收回内存)之间的⼀个时间段</p><ol><li>局部变量的生命周期是：进入作用域变量创建，生命周期开始，出作用域生命周期结束</li><li>全局变量的生命周期是：整个程序的生命周期</li></ol><p>举个static修饰<strong>局部变量</strong>的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> i++;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> test();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果来看，打印了5个1，局部变量 i 每次进入 test 函数时都会重新定义，也就是重新创建再释放内存，如果我们不想让 i 出函数时被销毁，我们就在 int i &#x3D; 0 前面加上 static ，那么此时 i 出函数的时候是不会销毁的，重新进入函数也就不会重新创建变量，直接上次累积的数值继续计算</p><p>static修饰局部变量改变了变量的生命周期，生命周期改变的本质是改变了变量的存储类型，本<br>来⼀个局部变量是存储在内存的栈区的，但是被 static 修饰后存储到了静态区，存储在静态区的变<br>量和全局变量是⼀样的，生命周期就和程序的生命周期⼀样了，只有程序结束，变量才销毁，内存才<br>回收，但是作用域不变</p><p>举个static修饰<strong>全局变量</strong>的例子：</p><p>add.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_val = <span class="number">2018</span>;</span><br></pre></td></tr></table></figure><p>test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_val);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern 是用来<strong>声明外部符号</strong>的，如果⼀个全局的符号在A文件中定义的，在B文件中想使用，就可以使用 extern 进行声明，然后使用</p><p>如果在 int g_val &#x3D; 2018 前加个 static 在编译的时候会出现链接性错误，全局变量被 static 修饰之后，外部链接属性就变成了内部链接属性，只能在自己所在的源文件内部使用了，其他源文件，即使声明了，也是无法正常使用的（ <strong>static 修饰函数同理</strong>）</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/49c3020ede9a2b4405501955e8cf92e.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.5——数组</title>
      <link href="/2024/10/16/C%E8%AF%AD%E8%A8%80/vlog5/"/>
      <url>/2024/10/16/C%E8%AF%AD%E8%A8%80/vlog5/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h1><p>数组简单理解就是一组相同类型元素的集合<br>注意：<br>• 数组中存放的是1个或者多个数据，但是数组元素个数不能为0<br>• 数组中存放的多个数据，类型是相同的<br>• 数组分为一维数组和多维数组，常见多维数组为二维数组<br>• 数组可以没有初始值，也可以没有大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">0</span>&#125;<span class="comment">//大小为1</span></span><br></pre></td></tr></table></figure><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="一维数组的创建与初始化"><a href="#一维数组的创建与初始化" class="headerlink" title="一维数组的创建与初始化"></a>一维数组的创建与初始化</h2><p>一维数组其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arr_name[常量值];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//[]内是元素个数，&#123;&#125;内是初始化的元素</span></span><br></pre></td></tr></table></figure><p>type 可以是 char、float、double等等，也可以是自定义类型的数据<br>数组去掉其数组名剩下的就是数组的类型，比如：int arr1[10] ，arr1数组的类型是 int [10]</p><p>一维数组的<strong>完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>一维数组的<strong>不完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr2[<span class="number">6</span>] = &#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>第一个元素初始化为1，其余元素初始化为0</p><p>一维数组的<strong>错误初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>超出初始化元素的个数</p><p>注意：若 [ ] 内不写个数是可以的，该数组的元素个数根据 { } 的初始化决定</p><h2 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h2><p>数组是有下标的，假设有一组数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>那它的数组和下标对应关系为<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8107b3d10af7dee889c0b10df7c5423.png" alt="在这里插入图片描述"><br>所以C语言为了便于访问数组中的元素，创建了一个操作符 [ ] ，叫<strong>下引用操作符</strong><br>比如我们访问第五个元素，可以使用 arr[4] 访问</p><p>使用循环可以对数组进行打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要知道数组中元素的个数呢？<br>那此时我们可以使用C语言中的一个关键字 sizeof 计算类型或变量的大小<br>那只要计算出一个元素所占字节的个数，数组的元素个数就能算出来<br>这里我们选择第⼀个元素算大小就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sz);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> sizeof(arr) 为数组大小， sizeof(arr[0]) 为数组一个元素的大小，这两相除即为元素个数</p><h2 id="一维数组的存储"><a href="#一维数组的存储" class="headerlink" title="一维数组的存储"></a>一维数组的存储</h2><p>要了解一维数组在内存中的存储，我们可以依次打印其各个元素的地址进行观察：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d] = %p\n &quot;</span>, i, &amp;arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/edd4b39ecd2f6ac1b917f71b07ccd29.png" alt="在这里插入图片描述"><br>从代码的运行结果来看每个数组地址之间相差4个字节，由此可知<strong>一维数组在内存中是连续存放的</strong></p><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组的创建与初始化"><a href="#二维数组的创建与初始化" class="headerlink" title="二维数组的创建与初始化"></a>二维数组的创建与初始化</h2><p>数组的元素都是内置类型的<br>如果我们把⼀维数组做为数组的元素，这时候就是<strong>二维数组</strong><br>二维数组作为数组元素的数组被称为<strong>三维数组</strong>，二维数组以上的数组统称为<strong>多维数组</strong></p><p>二维数组其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type arr_name[常量值<span class="number">1</span>][常量值<span class="number">2</span>]；</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这里的3表示数组有3行，5表示每行有5个元素</p><p>二维数组的<strong>完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>12345为第一行，23456为第二行，34567为第三行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr4[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>12000为第一行，34000为第二行，56000为第三行</p><p>二维数组的<strong>不完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>第一行初始化为12000，第二、三行都为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr5[][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr6[][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr7[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>初始化时省略行，但是不能省略列</p><h2 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h2><p>C语言规定，二维数组的行是从0开始的，列也是从0开始的，假设有一数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>那它的数组和下标对应关系为<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ac3f24d1e6882aac0a9c2bbcd7156c.png" alt="在这里插入图片描述"><br>访问二维数组的单个元素我们知道了，那如何打印整个二维数组呢？<br>其实我们只要能够按照⼀定的规律产生所有的行和列的数字就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) <span class="comment">//产⽣⾏号</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) <span class="comment">//产⽣列号</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]); <span class="comment">//输出数据</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h2><p>像一维数组⼀样，我们如果想研究⼆维数组在内存中的存储方式，我们也是可以打印出数组所有元素的地址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d][%d] = %p\n&quot;</span>, i, j, &amp;arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c7e26c7de9da82673fd9817d7b9adca.png" alt="在这里插入图片描述"><br>从代码运行结果来看，每个元素的地址间也是相隔4个字节，所以<strong>二维数组中的每个元素都是连续存放的</strong>，像一维数组那样一字排开存储</p><h1 id="C99中的变长数组"><a href="#C99中的变长数组" class="headerlink" title="C99中的变长数组"></a>C99中的变长数组</h1><p>在C99标准之前，C语言在创建数组的时候，数组大小的指定只能使用常量、常量表达式，或者如果我<br>们初始化数据的话，可以省略数组大小，这样的语法限制，让我们创建数组就不够灵活，有时候数组大了浪费空间，有时候数组小了不够用</p><p>于是C99中给了一个<strong>变长数组</strong>的新特性，允许我们使用变量指定数组大小，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = a+b;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br></pre></td></tr></table></figure><p>数组 arr 就是变长数组，它的长度取决于变量 n 的值，编译器没法事先确定，只有运行时才能知道n是多少</p><p>变长数组的根本特征，就是数组长度只有运行时才能确定，所以变长数组不能初始化，它的好处是程<br>序员不必在开发时，随意为数组指定⼀个估计的长度，程序可以在运行时为数组分配精确的长度</p><p>遗憾的是在VS2022上，虽然支持大部分C99的语法，没有支持C99中的变长数组</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/af4c592ff65877f0c42d49814f0f71c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.4——分支和循环（下）</title>
      <link href="/2024/10/14/C%E8%AF%AD%E8%A8%80/vlog4/"/>
      <url>/2024/10/14/C%E8%AF%AD%E8%A8%80/vlog4/</url>
      
        <content type="html"><![CDATA[<p>猜数字游戏专题</p><p>掌握了前面学习的vlog的知识，尤其是分支与循环，我们可以写一个经典有趣的游戏：猜数字<br>游戏要求：<br>1.电脑自动生成1~100的随机数<br>2.玩家猜数字，程序根据玩家猜的数字，做出猜大了或猜小了的判断，直到玩家猜对为止</p><h1 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h1><h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>rand是C语言中的一种函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p> rand 会返回一个随机数，这个随机数的范围在0~RAND_MAX（理论值）之间<br>使用该函数需要包括头文件**#include &lt;stdlib.h&gt;**</p><p>实际上我们多次运行只有 rand 函数的程序会发现，每次打印的随机数都相同，其实只有 rand 函数返回的是一个<strong>伪随机数</strong>，真正的随机数是无法预测下一个数是多少的， rand 函数是基于一个叫 “<strong>种子</strong>” 的基准值生成随机数，种子默认值为1，所以我们想生成完全随机的数，要让种子时刻处于变化状态</p><h2 id="srand"><a href="#srand" class="headerlink" title="srand"></a>srand</h2><p>srand 也是C语言中的一种函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed）；</span></span><br></pre></td></tr></table></figure><p> srand 会初始化随机数的生成器，调用 rand 函数前要调用 srand 函数，通过 srand 函数的参数seed来设置rand函数生成随机数的时候的种子，只要种子在变化，每次生成的随机数序列也就变化起来了<br>那也就是说 srand 的种子如果是随机的， rand 就能生成随机数</p><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>易知时间是在时刻发生变化的，所以我们可以将时间作为种子来使用<br> time 就是C语言中的一个时间函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span> <span class="params">(<span class="type">time_t</span>* timer)</span>;</span><br></pre></td></tr></table></figure><p>time 函数会返回当前的日历时间，其实返回的是1970年1月1日0时0分0秒到现在程序运行时间之间的<br>差值，单位是秒，返回的类型是<strong>time_t类型</strong>的，time_t 类型本质上其实就是32位或者64位的整型类型</p><p>time 函数的参数 timer 如果是非NULL的指针的话，函数也会将这个返回的差值放在 timer 指向的内存中带回去，如果 timer 是NULL，就只返回这个时间的差值，time 函数返回的这个时间差也被叫做：时间戳, time 函数的时候需要包含头文件：**#include &lt;time.h&gt;**</p><p>于是完整的生成随机数代码可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand());</span><br></pre></td></tr></table></figure><p>srand函数是不需要频繁调用的，⼀次运行的程序中调用⼀次就够了</p><h2 id="随机数的范围"><a href="#随机数的范围" class="headerlink" title="随机数的范围"></a>随机数的范围</h2><p>生成0~99之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand() % <span class="number">100</span>;<span class="comment">//余数的范围是0~99</span></span><br></pre></td></tr></table></figure><p>生成1~100之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">//%100的余数是0~99,0~99的数字+1,范围是1~100</span></span><br></pre></td></tr></table></figure><p>生成100~200之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + rand()%(<span class="number">200</span><span class="number">-100</span>+<span class="number">1</span>)<span class="comment">//余数的范围是0~100，加100后就是100~200</span></span><br></pre></td></tr></table></figure><p>生成a~b之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + rand()%(b-a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="猜数字游戏的实现"><a href="#猜数字游戏的实现" class="headerlink" title="猜数字游戏的实现"></a>猜数字游戏的实现</h1><p>首先设置主要的菜单界面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">     srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">     <span class="keyword">switch</span> (input)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          game();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;游戏结束\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;选择错误，重新选择\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (input);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;****** 1. play ******\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;****** 0. exit ******\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设计主要的猜数字代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> r = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> guess= <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;请猜数字&gt;:&quot;</span>);</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">       <span class="keyword">if</span>(guess &lt; r)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;猜⼩了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(guess &gt; r)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;猜⼤了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，猜对了\n&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，丰富游戏玩法我们还可以加上猜的次数，自定义函数game可修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> r = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> guess = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">while</span> (count)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n你还有%d次机会\n&quot;</span>, count);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;请猜数字&gt;:&quot;</span>);</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">       <span class="keyword">if</span> (guess &lt; r)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜⼩了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (guess &gt; r)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜⼤了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，猜对了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     count--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;你失败了，正确值是:%d\n&quot;</span>, r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要注意把两个自定义函数 game 和 menu 放在主函数前<br>或者在主函数前加上 void mean() 和 void game() 进行<strong>函数声明</strong> (后面会讲) </p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3f51b4b4c496208dcc5e4624edf8b88.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.3——分支和循环（上）</title>
      <link href="/2024/10/12/C%E8%AF%AD%E8%A8%80/vlog3/"/>
      <url>/2024/10/12/C%E8%AF%AD%E8%A8%80/vlog3/</url>
      
        <content type="html"><![CDATA[<p>C语言的结构分为顺序结构、选择结构、循环结构，结构化程序设计离不开这三种结构或这三种结构的组合，合理快速的运用这些结构是学好C语言的基础</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p> if 语句，显而易见是如果的意思，通过判断真假来确认语句是否执行，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 表达式 )</span><br><span class="line"> 语句</span><br></pre></td></tr></table></figure><p> 表达式内语句为真，则语句执行，表达式内语句为假，则语句不执行，会直接跳过该语句<br> 在C语言中，0表示为假，非0表示为真<br> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/26a9bc676522b65c11c209750b3aacc.png" alt="在这里插入图片描述"><br>如果判断一个事物的正反面写两个 if 语句，就太麻烦了，这里就需要用到 if…else… 语句了<br>例如：输入⼀个年龄，&gt;&#x3D; 18岁就输出：成年，否则就输出：未成年</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"> <span class="keyword">if</span>(age&gt;=<span class="number">18</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;未成年\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 if 和 else 语句中都默认只控制一条语句，还是上面的例子，如果想要既打出”<strong>成年</strong>“，又想打出”<strong>可以谈恋爱了</strong>“,那就需要用大括号将两个 printf 输出语句括起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"> <span class="keyword">if</span>(age &gt;= <span class="number">18</span>) <span class="comment">//if 后使⽤&#123;&#125; 控制多条语句-这个块也叫：程序块，或者复合语句</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成年了\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱了\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果在 if 语句中嵌套 if 语句呢，这叫做<strong>嵌套 if</strong> ，但是如果连着多个 if 语句嵌套的话，会显得代码特别复杂不易理解，而且花括号多了，检查代码时也很难一一对应不遗漏，所以可以使用 <strong>else if</strong> ，就省去了嵌套的麻烦<br>例如：输入⼀个整数，判断输入的整数是0，还是正数或者负数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"> <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是0\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>) <span class="comment">//这⾥的if 相当于嵌套在else语句中，形成了嵌套结构</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是正数\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是负数\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意，如果 else 语句前有多个 if  ，可以记住这样⼀条规则， <strong>else 总是跟最接近的 if 匹配</strong>，相当于前面的 if 语句都被悬空了，这就是悬空else问题<br>如果希望else确实和第⼀个if匹配，可以如下例子这样子操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(b == <span class="number">2</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;haha\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分支与循环操作符"><a href="#分支与循环操作符" class="headerlink" title="分支与循环操作符"></a>分支与循环操作符</h1><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>用于比较的操作符称为<strong>关系表达式</strong></p><p>• &gt; 大于运算符<br>• &lt; 小于运算符<br>• &gt;&#x3D; 大于等于运算符<br>• &lt;&#x3D; 小于等于运算符<br>• &#x3D;&#x3D; 相等运算符<br>• !&#x3D; 不相等运算符</p><p>关系表达式通常返回 0 或 1 ，表示真假，比如， 20 &gt; 12 返回 1 ， 12 &gt; 20 返回 0<br>注意不要把相等运算符 &#x3D;&#x3D; 和赋值运算符 &#x3D; 弄混</p><p><strong>要避免多个运算符连用</strong>，举个例子： i &lt; j &lt; k<br>这是个合法表达，但不能保证 j 在 i 和 k 之间，这是因为关系运算符是从左往右运算，即 (i &lt; j) &lt; k<br>所以应改为这种写法 i &lt; j &amp;&amp; j &lt; k</p><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符也叫三目操作符，需要接受三个操作数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1 ? exp2 : exp3</span><br></pre></td></tr></table></figure><p>如果 exp1 为真， exp2 计算，计算的结果是整个表达式的结果；如果<br>exp1 为假， exp3 计算，计算的结果是整个表达式的结果</p><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><p>逻辑运算符用于逻辑的判断</p><p>• ! ：逻辑取反运算符（改变单个表达式的真假）<br>• &amp;&amp; ：逻辑与运算符，就是并且的意思（<strong>两侧的表达式都为真，则为真，否则为假</strong>）<br>• || ：逻辑或运算符，就是或者的意思（<strong>两侧至少有⼀个表达式为真，则为真，否则为假</strong>）</p><p>C语言的逻辑运算有个特点，就是优先对左侧的表达式求值，再对表达式右边的值求值<br>如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值，这种情况称为<strong>短路</strong></p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p> switch 语句用于实现分支结构，在循环结构中相当于 else if<br> 使用 switch 能够更好解读代码，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> value1: statement</span><br><span class="line"> <span class="keyword">case</span> value2: statement</span><br><span class="line"> <span class="keyword">default</span>: statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句会依次执行 case 分支，如果找不到对应的分支语句，就执行 default 语句<br>注意：<br>• switch 后的 expression 必须是<strong>整型表达式</strong><br>• case 后的值，必须是<strong>整形常量表达式</strong></p><p>举个例子：输入任意⼀个整数值，计算除3之后的余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> <span class="keyword">switch</span>(n%<span class="number">3</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;整除，余数为0\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;余数是1\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;余数是2\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>• case 和后边的数字之间必须有空格<br>• 每⼀个 case 语句中的代码执行完成后，需要加上 break ，才能跳出这个switch语句，否则会继续执行别的语句，就达不到我们想要的分支效果了<br>• default 在语句中没有顺序要求，通常把 default 放最后更符合逻辑</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h1><p>while 语句也是一种常用的循环语句，while 语句的语法结构和 if 语句非常相似<br>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>); <span class="comment">//while后边的条件满⾜，死循环的打印hehe</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来就是执行判断表达式，表达式的值为0，循环直接结束；表达式的值不为0，则执行循环语<br>句，语句执行完后再继续判断，是否进行下⼀次判断<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f20cbbda52d46b5c6e2d74c57d871b9.png" alt="在这里插入图片描述"></p><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h1><p>for 循环在循环结构中是最常使用的，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line"> 语句；<span class="comment">//如果循环体想包含更多的语句，可以加上⼤括号</span></span><br></pre></td></tr></table></figure><p>表达式1 用于循环变量的初始化<br>表达式2 用于循环结束条件的判断<br>表达式3 用于循环变量的调整</p><p>举个例子：计算1~100之间3的倍数的数字之和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"> sum += i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行表达式1：初始化循环变量，接下来就是执行表达式2：判断，表达式2的结果如果&#x3D;&#x3D;0，则循环结束<br>表达式2的结果如果!&#x3D;0则执行循环语句，循环语句执行完后，再去执行表达式3：调整循环<br>然后再去表达式2的地方执行判断，表达式2的结果是否为0，决定循环是否继续</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/67d275e42a5e7713bf44cdb77e93b46.png" alt="在这里插入图片描述"><br>整个过程中表达式1：初始化只被执行过一次</p><h1 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a>do-while循环语句</h1><p>do-while 语句在循环结构中使用的最少，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"> 语句；</span><br><span class="line"><span class="keyword">while</span>(表达式)；</span><br></pre></td></tr></table></figure><p>举个例子：在屏幕上打印1~10的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"> i = i + <span class="number">1</span>;</span><br><span class="line"> &#125;<span class="keyword">while</span>(i&lt;=<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行 do 里的语句，然后判断表达式<br>判断表达式的结果是!&#x3D;0，则继续循环，执行循环语句；判断表达式的结果 &#x3D;&#x3D; 0，则循环结束</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/55608d99ffdd1528aa1b5a45bb3f199.png" alt="在这里插入图片描述"></p><h1 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h1><p>在循环执行的过程中，如果某些状况发生的时候，需要提前终止循环，这是非常常见的现象。C语言中<br>提供了 break 和 continue 两个关键字，就是应用到循环中的。</p><p>• break 的作用是用于永久的终止循环，只要 break 被执行，直接就会跳出循环，继续往后执行<br>• continue 的作用是跳过本次循环中 continue 后边的代码， for 循环中直接跳到循环调整部分，while 循环直接跳到循环判断部分</p><h1 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h1><p>goto 语句可以实现在同⼀个函数内跳转到设置好的标号处<br>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> next;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;haha\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">next:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;跳过了haha的打印\n&quot;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goto 语句如果使用的不当，就会导致在函数内部随意乱跳转，打乱程序的执行流程，所以我们的建<br>议是能不用尽量不去使用；但是 goto 语句也不是一无是处，在多层循环的代码中，如果想快速跳出<br>使用 goto 就非常的方便了<br>比如本来 for 循环想提前退出得使用 break ，⼀个 break 只能跳出⼀层 for 循环，如果3层循环嵌套<br>就得使用3个 break 才能跳出循环，所以在这种情况下我们使用 goto 语句就会更加的快捷</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会持续更新"><a href="#小编会持续更新" class="headerlink" title="小编会持续更新"></a>小编会持续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/60692ff12e67dca25120f3622ddbe14.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.2——C语言数据类型和变量</title>
      <link href="/2024/10/10/C%E8%AF%AD%E8%A8%80/vlog2/"/>
      <url>/2024/10/10/C%E8%AF%AD%E8%A8%80/vlog2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型的介绍"><a href="#数据类型的介绍" class="headerlink" title="数据类型的介绍"></a>数据类型的介绍</h1><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>C语言的数据类型多种多样，类型不仅是我们了解数据的开始，也是数据初始化、函数自定义等的操作，编译器只有知道了数据的类型，才能进行相应的操作<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2edd3369e3a5a1ac391287b5394a135.png" alt="在这里插入图片描述"></p><p><strong>字符型</strong>：char、[signed] char（有符号字符）、[unsigned] char（无符号字符）</p><p><strong>整型</strong>：int、[signed] int、unsigned int<br><strong>短整型</strong>：short [int]、[signed] short [int]、unsigned int [int]<br><strong>长整型</strong>：long [int]、[signed] long [int]、unsigned long [int]<br><strong>更长的整型</strong>：long long [int]、[signed] long long [int]、unsigned long long [int]</p><p><strong>浮点型</strong>：float、double、long double</p><p><strong>布尔类型</strong>：布尔类型本不是专门的类型，后来为了表示真假，引入了布尔类型_Bool或bool，使用布尔类型必须包含头文件#include &lt;stdbool.h&gt;,布尔类型返回的是<strong>true或false</strong>，表示真假</p><p>注意每种类型的数据都有自己的长度，存储的数据范围有所差异，这里就不过多赘述（详情可看<a href="https://legacy.cplusplus.com/%EF%BC%89">https://legacy.cplusplus.com/）</a></p><h2 id="sizeof操作符"><a href="#sizeof操作符" class="headerlink" title="sizeof操作符"></a>sizeof操作符</h2><p>sizeof是一个关键字，也是个操作符，用于计算操作符数的类型长度，单位是字节<br>sizeof有两种计算方式：<strong>sizeof（类型）、sizeof 表达式</strong><br>这里要注意的是sizeof后边的表达式是不参与真实运算的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="keyword">sizeof</span>(num + <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 这里 num + 20 并不会真正进行加法运算，只是根据 num 的类zd型（int）来确定大小。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of num + 20: %zd\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显而易见这里输出的result的值应为4，在VS2022的X64环境下，常见的int为4个字节，char为1个字节，这里只是根据其类型得出是4个字节。而且sizeof需要用%zd（无符号整型）来打印，sizeof的计算结果是<strong>size_t类型</strong>的。</p><p>sizeof 运算符的返回值，C 语言只规定是<strong>无符号整数</strong>，并没有规定具体的类型，而是留给系统自己去决定， sizeof 到底返回什么类型。不同的系统中，返回值的类型有可能是unsigned int ，也有可能是 unsigned long ，甚至是 unsigned long long ，对应的 printf() 占位符分别是 %u 、 %lu 和 %llu 。这样不利于程序的可移植性。C 语言提供了⼀个解决方法，创造了⼀个类型别名 size_t ，用来统⼀表示 sizeof 的返回值类型。对应当前系统的 sizeof 的返回值类型，可能是 unsigned int ，也可能是unsigned long long</p><h2 id="signed和unsigned"><a href="#signed和unsigned" class="headerlink" title="signed和unsigned"></a>signed和unsigned</h2><p>signed表示一个类型带有正负号，unsigned表示一个类型不带有正负号，也就是正整数，所以对于int来说完整的写法应该是signed int，只不过平常忽略不写，但写了也不算错</p><p>int 类型也可以不带正负号，只表示非负整数，这时就必须使用关键字unsigned声明变量。unsigned int里面的int可以省略，也就是可以写成unsigned，字符char也存在signed、unsigned</p><p>值得注意的是C语言规定char是否默认带有正负号由当前系统决定，这就是说，char 不等同于 signed char ，它有可能是 signed char ，也有可能是unsigned char </p><h1 id="变量的介绍"><a href="#变量的介绍" class="headerlink" title="变量的介绍"></a>变量的介绍</h1><h2 id="创建与初始化"><a href="#创建与初始化" class="headerlink" title="创建与初始化"></a>创建与初始化</h2><p>我们都知道变化的量叫变量，不变的称为常量，创建形式为<strong>data_type name</strong>，第一个为数据类型，第二个为变量名，例如int a &#x3D; 10，在变量在创建的时候就给⼀个初始值，这就叫初始化</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>全局变量</strong>：在大括号外部定义的变量就是全局变量<br>全局变量的使用范围更广，整个工程中想使用，都是有办法使用的</p><p><strong>局部变量</strong>：在大括号内部定义的变量就是局部变量<br>局部变量的使用范围是比较局限，只能在自己所在的局部范围内使用的</p><p>注意当局部变量和全局变量同名时，<strong>局部变量优先使用</strong></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>内存中有三个区域：栈区、堆区、静态区</p><ol><li>局部变量是放在内存的栈区</li><li>全局变量是放在内存的静态区</li><li>堆区是用来动态内存管理的（后期会介绍）</li></ol><h1 id="操作符的介绍"><a href="#操作符的介绍" class="headerlink" title="操作符的介绍"></a>操作符的介绍</h1><h2 id="算术操作符：-、-、-、-、"><a href="#算术操作符：-、-、-、-、" class="headerlink" title="算术操作符：+、-、*、&#x2F;、%"></a>算术操作符：+、-、*、&#x2F;、%</h2><p>C语⾔中为了方便运算，提供了⼀系列操作符，其中有⼀组操作符叫：算术操作符。<br>分别是： + - * &#x2F; % ，这些操作符需要两个操作数进行计算的都是<strong>双目操作符</strong>，操作符也叫做<strong>运算符</strong></p><p>用+ 和 - 来完成加法和减法</p><p>运算符 * 用来完成乘法</p><p>运算符 &#x2F; 用来完成除法，除号的两端如果是整数，执行的是整数除法，得到的结果也是整数，<strong>如果运算数中至少有一个float浮点数，就能得到浮点数</strong></p><p>运算符 % 表示求模(余)运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数，<strong>负数求模的规则是，结果的正负号由第⼀个运算数的正负号决定</strong></p><h2 id="赋值操作符：-和复合赋值"><a href="#赋值操作符：-和复合赋值" class="headerlink" title="赋值操作符：&#x3D;和复合赋值"></a>赋值操作符：&#x3D;和复合赋值</h2><p>赋值操作符 &#x3D; 是⼀个随时可以给变量赋值的操作符，要赋的值放在右边。赋值也可以连续赋值，从右向左依次赋值</p><p>对一个数进行自增、自减操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a+<span class="number">3</span>;</span><br><span class="line">a = a<span class="number">-2</span>;</span><br></pre></td></tr></table></figure><p>用复合赋值的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">3</span>;</span><br><span class="line">a -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>代码会显得更方便简洁，对以上的算术操作符都适用</p><h2 id="单目操作符：-、–、-、"><a href="#单目操作符：-、–、-、" class="headerlink" title="单目操作符：++、–、+、-"></a>单目操作符：++、–、+、-</h2><p>C语言中还有⼀些操作符只有⼀个操作数，被称<br>为单目操作符。 ++、–、+(正)、-(负) 就是单目操作符</p><p><strong>前置++</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = ++a;<span class="comment">//++的操作数是a，是放在a的前⾯的，就是前置++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a , b);</span><br></pre></td></tr></table></figure><p><strong>计算口诀：先+1，后使用</strong><br>a原来是10，先+1，后a变成了11，再使用就是赋值给b，b得到的也是11，所以计算后，a和b都是11</p><p><strong>后置++</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = a++;<span class="comment">//++的操作数是a，是放在a的后⾯的，就是后置++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a , b);</span><br></pre></td></tr></table></figure><p><strong>计算口诀：先使用，后+1</strong><br>a原来是10，先使用，就是先赋值给b，b得到了10，然后再+1，然后a变成了11，所以直接计算后a是11，b是10</p><p>前置–和后置++与上面同理</p><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>以一段代码做例子就明白了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//a的是int类型, 3.14是double类型，两边的类型不⼀致，编译器会报警告</span></span><br></pre></td></tr></table></figure><p>消除这个警告，就可以使用强制类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//意思是将3.14强制类型转换为int类型，这种强制类型转换只取整数部分入代码片</span></span><br></pre></td></tr></table></figure><p>注意强制转化只在万不得已的时候使用</p><h1 id="占位符的介绍及使用"><a href="#占位符的介绍及使用" class="headerlink" title="占位符的介绍及使用"></a>占位符的介绍及使用</h1><p>占位符在printf中这样使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;There are %d apples\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出There are 3 apples，这样输出语句更能提高程序的稳定性和准确性</p><p>除此之外，还有很多常见的占位符<br>• %c ：字符。<br>• %d ：十进制整数<br>• %f ：小数（包含 float 类型和 double 类型）<br>• %p ：指针（用来打印地址）<br>• %s ：字符串。<br>• %u ：无符号整数<br>• %x ：十六进制整数<br>• %zd ： size_t 类型</p><p><strong>限定宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot;</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> %5d 表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。输出的值默认是右对齐，即输出内容前面会有空格<br> 如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的 % 的后面插入⼀个 - 号</p><p><strong>总是显示正负号</strong></p><p>默认情况下， printf() 不对正数显示 + 号，只对负数显示 - 号。如果想让正数也输出 + 号，可<br>以在占位符的 % 后面加⼀个 +</p><p><strong>限定小数位数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 Number is 0.50</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Number is %.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望小数点后面输出3位（ 0.500 ），占位符就要写成 %.3f<br>也可以和限定宽度结合使用，比如%6.2f，输出为”*<em>0.50”(这里的</em>表示空格）<br>最小宽度和小数位数这两个限定值，都可以用 *代替，通过 printf() 的参数传入</p><p><strong>输出部分字符串</strong></p><p>可以用 %.[m]s 指定输出的长度，其中 [m] 代表⼀个数字，表示所要输出的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%.5s\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出前五个字符，即“hello”</p><h1 id="scanf函数的介绍"><a href="#scanf函数的介绍" class="headerlink" title="scanf函数的介绍"></a>scanf函数的介绍</h1><p>scanf() 函数用于读取用户的键盘输入<br>程序运行到这个语句时，会停下来，等待用户从键盘输入，输入数据、按下回车键后， scanf() 就会处理用户的输入，将其存入变量</p><p>scanf的使用方法与printf类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>不过scanf需要加取地址符号&amp;（后面会讲）</p><p>注意scanf() 的返回值是一个整数，表示成功读取的变量个数。<br>如果没有读取任何项，或者匹配失败，则返回 0 。<br>如果在成功读取任何数据之前，发生了读取错误或者遇到读取到文件结尾，则返回常量 EOF (-1)</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会持续更新"><a href="#小编会持续更新" class="headerlink" title="小编会持续更新"></a>小编会持续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e499c20858c89482285baee013c1b66.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.1——C语言常见概念</title>
      <link href="/2024/10/08/C%E8%AF%AD%E8%A8%80/vlog1/"/>
      <url>/2024/10/08/C%E8%AF%AD%E8%A8%80/vlog1/</url>
      
        <content type="html"><![CDATA[<p>​</p><h1 id="C语言是什么？和C-有什么区别？"><a href="#C语言是什么？和C-有什么区别？" class="headerlink" title="C语言是什么？和C++有什么区别？"></a>C语言是什么？和C++有什么区别？</h1><p>定义：C 语言是一种通用的、面向过程的计算机编程语言。它最初由丹尼斯・里奇（Dennis Ritchie）在 20 世纪 70 年代初于贝尔实验室开发，用于编写 UNIX 操作系统。C 语言具有高效、简洁、可移植性强等特点。</p><p>简单来说：人和人交流使用的是自然语言，那么计算机语言就是人和计算机交流的桥梁，C语言就是众多计算机语言中的⼀种</p><p>C语言和C++的区别:C++是C语言的plus版，C语言是面向过程的语言，把大象放进冰箱需要多少步？需要三步，打开冰箱门，放入大象，关闭冰箱，这就是面向过程。C++是面向对象的语言，比C语言难，但是直接学习C++也需要接触面向过程的内容，大象的体重？身高？冰箱的尺寸？制冷效率？这就是面向对象的内容。</p><h1 id="编译器的选择和使用"><a href="#编译器的选择和使用" class="headerlink" title="编译器的选择和使用"></a>编译器的选择和使用</h1><p>我们需要把C语言转化成机器能够执行的机器命令，就需要一些编译器的集成开发环境来实现。<br>那我们常见的C语言编译器都有哪些呢？</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8857f0d6431ab38cd709e5cb498296d.png" alt="DevC++"></p><p>集成了gcc开发环境，也是学校和一些竞赛常用的，具有小巧灵活的特点，但是对代码风格的养成不太友好，不利于码农写出好看标准的代码，故选择性使用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e65d9b52ab12f4680575f00495919d3.png" alt="Clion"></p><p>集成了CMake开发环境，编译器可以根据个人习惯配置，还是不错的，但介于他是个收费软件，故不做目前推荐使用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7cc95ca71bd8e2d6c6da762a02a578d.png" alt="VS2022"></p><p>集成了MSVC开发环境，安装报包较大一些，安装简单，无需多余配置，企业中也较多使用，中文界面对初学者也很友好,使用起来非常方便，便于培养代码风格，是作者最喜欢用的，故在此推荐使用</p><h1 id="项目、源文件、头文件的介绍"><a href="#项目、源文件、头文件的介绍" class="headerlink" title="项目、源文件、头文件的介绍"></a>项目、源文件、头文件的介绍</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/138971510e0e0be6039199b0bbd6c55.png" alt="在这里插入图片描述"></p><p>安装好VS2022后，我们创建一个空白界面，这就是一个项目</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d2b2428fd1f2ce8d8ead0bc68427df7.png" alt="在这里插入图片描述"></p><p>如图所示，以.h结尾的就叫做头文件，以.c结尾的就叫做源文件 </p><p>头文件定义：是一种包含函数声明、变量声明、宏定义和类型定义等内容的文件，通常以.h（在 C、C++ 等编程语言中）为扩展名。</p><p>简单来说就是包含了自定义函数以及编译器自带函数等的文件</p><p>源文件定义：源文件是包含实际函数定义、变量定义等可执行代码的文件，在 C、C++ 等语言中通常以.c或.cpp（C++ 源文件）为扩展名。</p><p>简单来说我们在头文件下创建和执行的代码所在的文件就叫源文件</p><h1 id="main函数、printf函数、库函数的介绍"><a href="#main函数、printf函数、库函数的介绍" class="headerlink" title="main函数、printf函数、库函数的介绍"></a>main函数、printf函数、库函数的介绍</h1><p> main函数</p><p>是程序的入口点。这意味着当程序开始运行时，操作系统会首先调用main函数。 它是整个程序执行的起始位置，就像一场演出的开场节目一样，程序的其他部分都是在main函数的调用或控制下逐步执行的。</p><p>main函数也被叫做主函数，在写”hello world”代码时，前面的int表示函数执行结束时返回的类型，所以在main函数最后写return 0；正好前后呼应，返回一个0（假）使代码停止</p><p>• main函数有且仅有⼀个<br>• 即使⼀个项目中有多个.c文件，但是只能有⼀个main函数（因为程序的入口只能有⼀个）<br>• main后边的()不能漏掉了<br>• 代码中不能使用中文符号，比如括号和分号<br>• 一条语句结束后，有分号<br>printf函数<br>实现代码在屏幕上的打印，printf也是个库函数，printf可以打印各种类型的数据<br>库函数<br>一些代码会被我们重复性的去使用，为了提高程序员的代码开发效率，C语言标准规定了一些函数，由编译器进行实现提供给程序员使用，这些函数组成了一个库就被称为标准库，也叫库函数，库函数一般会声明在头文件中，所以使用库函数要包含对应的头文件</p><h1 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h1><p>像int、if、return这类保留名字的符号被称为关键字<br>• 关键字都有特殊的意义，是保留给C语言使用的<br>• 程序员自己在创建标识符的时候是不能和关键字重复的<br>• 关键字也是不能自己创建的。<br>6.字符、字符串、ASC||编码的介绍<br>像a、b、@、&amp;等这些叫做字符，使用单括号将他们括起来<br>像”abcdef”叫做字符串，使用双括号将他们括起来<br>计算机中的数据是以二进制形式存储的，给每个字符都编码一个二进制序列，这个叫做编码，所以出台了一个标准ASC||编码方便相互同通信，敲代码 </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/74334dbd08f3100de253af978e582e9.png" alt="在这里插入图片描述"></p><p>• 字符A-Z的ASCII码值从65-90<br>• 字符a-z的ASCII码值从97-122<br>• 对应的大小写字符(a和A)的ASCII码值的差值是32<br>• 数字字符0-9的ASCII码值从48-57<br>• 换行\n 的ASCII值是：10<br>• 在这些字符中ASCII码值从0~31 这32个字符是不可打印字符，无法打印在屏幕上观察</p><h1 id="转义字符的介绍"><a href="#转义字符的介绍" class="headerlink" title="转义字符的介绍"></a>转义字符的介绍</h1><p>转义字符其实就是转变代码意思的字符<br>C语言中像这样的转义字符还有一些，具体如下：<br>• ? ：在书写连续多个问号时使用，防止他们被解析成三字母词，在新的编译器上没法验证了。<br>• \ ：用于表示⼀个反斜杠，防止它被解释为⼀个转义序列符。<br>• \a ：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。<br>• \b ：退格键，光标回退⼀个字符，但不删除字符。<br>• \f ：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于 \v 。<br>• \n ：换行符。<br>• \r ：回车符，光标移到同一行的开头。<br>• \t ：制表符，光标移到下⼀个水平制表位，通常是下⼀个4&#x2F;8的倍数。<br>• \ddd ：d d d表示1~3个八进制的数字。 如：\130 表示字符X<br>• \xdd ：d d表示2个⼗六进制数字。 如： \x30 表示字符0<br>• \0 ：null 字符，代表没有内容， \0 就是 \ddd 这类转义字符的⼀种，⽤于字符串的结束标志，其<br>ASCII码值是0</p><h1 id="注释的重要性"><a href="#注释的重要性" class="headerlink" title="注释的重要性"></a>注释的重要性</h1><p>注释是一种对代码的说明，通常在&#x2F;&#x2F;后进行注释，注释后的代码编译器会忽略注释，所以注释是给程序员看的，好的注释可以帮助我们理解代码<br>另一种注释方法将注释放在 &#x2F;<em>…</em>&#x2F; 之间，内部可以分行<br>总的来说写注释提高了代码的可读性，能够描述变量和函数的用途，方便代码的维护<br>希望读者们多多三连支持<br>小编会持续更新<br>你们的鼓励就是我前进的动力！</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/76973ea184d17f67b7807a7829d0af4.png" alt="在这里插入图片描述"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发语言 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
