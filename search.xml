<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.22——动态内存管理dě查缺补漏</title>
      <link href="/2024/11/23/C%E8%AF%AD%E8%A8%80/vlog22/"/>
      <url>/2024/11/23/C%E8%AF%AD%E8%A8%80/vlog22/</url>
      
        <content type="html"><![CDATA[<p>本篇是对上一篇动态内存管理的总结提升，能够更好地帮助你理解使用动态内存管理😎</p><h1 id="动态内存的魔鬼细节"><a href="#动态内存的魔鬼细节" class="headerlink" title="动态内存的魔鬼细节"></a>动态内存的魔鬼细节</h1><h2 id="对空指针解引用"><a href="#对空指针解引用" class="headerlink" title="对空指针解引用"></a>对空指针解引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX/<span class="number">4</span>);</span><br><span class="line"> *p = <span class="number">20</span>;<span class="comment">//如果p的值是NULL，就会有问题</span></span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>其分配的大小为 INT_MAX&#x2F;4 字节，然而系统可能无法提供如此巨大的内存块以满足分配请求，所以在<strong>系统无法满足分配请求时，malloc 会返回一个空指针</strong>，直接对 *p 进行赋值操作，如果 p 的值是 NULL，那么这个赋值操作就会导致程序出现段错误（访问非法内存地址），即指向不存在的内存</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(INT_MAX / <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 可以在这里添加一些处理内存分配失败的逻辑，比如打印错误信息等</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在内存分配后添加对 p 是否为 NULL 的判断</p><h2 id="动态内存越界访问"><a href="#动态内存越界访问" class="headerlink" title="动态内存越界访问"></a>动态内存越界访问</h2><p>这里先介绍 exit 函数，<strong>用于终止当前正在执行的程序</strong>，EXIT_FAILURE 是一个<strong>预定义的宏</strong>，它通常被定义为一个非零值，当 exit 函数以 EXIT_FAILURE 作为参数被调用时，<strong>这表示程序是以一种错误状态退出的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> == p)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *(p+i) = i;<span class="comment">//当i是10的时候越界访问</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>通过 malloc 分配的内存空间是用于存储 10 个 int 类型数据的，但是却输入了 11 个整数，当 i 的值达到 10 时，*(p + i) 这个操作就会超出所分配内存空间的边界，<strong>导致越界访问</strong>，可能导致程序出现程序崩溃、数据错误等</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环在有效范围内对所分配内存空间中的元素进行赋值操作</p><h2 id="对非动态内存-free"><a href="#对非动态内存-free" class="headerlink" title="对非动态内存 free"></a>对非动态内存 free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> *p = &amp;a;</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//ok?</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>这里没有开辟动态内存，只是创建了指针变量，并不是说只要是内存都能被 free 释放，free 函数在 C 语言中是用于<strong>释放通过动态内存分配函数</strong>（如 malloc、calloc、realloc 等）分配的内存空间</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 使用完分配的内存后</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 malloc 函数动态分配了能够容纳一个 int 类型数据的内存空间，将其赋值给指针 p，在对该内存进行了必要的操作（如赋值等）之后，再使用 free 函数来释放这块动态分配的内存</p><h2 id="使用-free-只释放一部分动态内存"><a href="#使用-free-只释放一部分动态内存" class="headerlink" title="使用 free 只释放一部分动态内存"></a>使用 free 只释放一部分动态内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> p++;</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>指针 p 进行自增操作（p++），使其不再指向所分配动态内存的起始位置，free 函数要求<strong>传入的指针必须指向通过动态内存分配函数所分配的内存块的起始位置</strong>，当传入不符合要求的指针给 free 函数时，可能会导致程序崩溃、内存泄漏等问题</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> *original_p = p;  <span class="comment">// 保存起始指针</span></span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用p进行其他操作后，当需要释放内存时</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(original_p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过引入一个新的指针 original_p 来保存最初通过 malloc 分配内存时得到的起始指针，在对 p 进行了自增等可能改变其指向的操作之后，当需要释放内存时，就使用 original_p 来调用 free 函数，这样就能正确地释放所分配的动态内存了</p><h2 id="对同一块动态内存多次-free"><a href="#对同一块动态内存多次-free" class="headerlink" title="对同一块动态内存多次 free"></a>对同一块动态内存多次 free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(p);<span class="comment">//重复释放</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><blockquote><p>p 开辟的动态空间已经被 free 函数释放过一次了，<strong>重复释放</strong>同一块内存是不合法的</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 进行相关操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = <span class="literal">NULL</span>;  <span class="comment">// 将指针置为NULL，避免后续误操作指向已释放内存的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="忘记-free-动态内存"><a href="#忘记-free-动态内存" class="headerlink" title="忘记 free 动态内存"></a>忘记 free 动态内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line"> &#123;</span><br><span class="line"> *p = <span class="number">20</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> test();</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里进入一个无限循环 while(1)，使得程序在<strong>执行完 test 函数后不会立即退出</strong><br>后续没有对开辟的动态内存进行进一步的有效利用，由于没有调用 free 函数来归还这块动态分配的内存给系统的堆内存管理系统，随着程序的运行，如果<strong>多次调用 test 函数或者类似的函数进行大量的动态内存分配操作而不释放</strong>，就会导致<strong>内存泄漏</strong></p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span>!= p)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 完成赋值操作后，释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用 test 函数时，在对动态分配的内存进行赋值操作后，就会及时将这块内存归还给系统的堆内存管理系统，避免了内存泄漏的问题</p><h1 id="动态内存经典试题解析"><a href="#动态内存经典试题解析" class="headerlink" title="动态内存经典试题解析"></a>动态内存经典试题解析</h1><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line"> &#123;</span><br><span class="line"> p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(str);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/81037d25bc1c42e3bd11362e77519de6.png" alt="在这里插入图片描述"></p><blockquote><ol><li>首先创建了指针变量 str ，置为空指针，将 str 作为实参传给形参 p，此时 p 也为空指针，将开辟的 100 个字节的空间地址放在形参 p 中，但是此时是传值调用，在 p 上的操作并没有实际作用在 str 上，所以 <strong>str 依然是空指针</strong></li><li>然后把“hello world” 拷贝到 str 里时，<strong>需要对 str 解引用操作</strong>，向 NULL 指针所指向的空间进行字符串复制操作会导致程序崩溃，产生段错误等未定义行为</li><li>此时最危险的是当函数执行完毕返回时，这个局部变量 p 就会被销毁，<strong>它所指向的刚分配的内存地址也就丢失了</strong>，那么可能会造成内存泄漏</li></ol></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str);</span><br><span class="line">    <span class="keyword">if</span> (str!= <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">free</span>(str);  <span class="comment">// 使用完内存后要记得释放</span></span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建二级指针，实现传址调用，并且在 Test 函数使用完内存后，通过 free 释放所分配的内存，避免内存泄漏，并将 str 重新赋值为 NULL 以防止野指针出现</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> str = GetMemory();</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/768141bdcae2407584b304a47ea7ac78.png" alt="在这里插入图片描述"></p><blockquote><ol><li>当函数GetMemory执行完毕并返回时，其栈帧会被销毁，这也就意味着字符数组 p 所占用的内存空间已经被释放掉了，尽管函数返回了p的地址，但这个<strong>地址所指向的内容已经是无效的了</strong></li><li>调用 GetMemory 函数期望获取一个有效的字符串指针并赋值给str，然后通过 printf 输出该字符串，然而，由于前面提到的 GetMemory 函数返回的<strong>指针指向的是已经被释放的栈内存</strong>，所以在执行 printf(str) 时，就会出现未定义行为</li></ol></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">GetMemory</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    str = GetMemory();</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符数组p定义为静态数组，静态数组在程序的整个生命周期内都存在，不会随着函数的结束而被销毁</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line"> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><blockquote><p>这题和题1修改后的代码基本差不多，最重要的一点就是<strong>没有释放动态内存空间</strong>，导致了<strong>内存泄漏</strong>，即随着程序的运行，不断地分配内存但从不释放，最终耗尽系统的可用内存资源</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetMemory</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span><br><span class="line"> &#123;</span><br><span class="line"> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">    GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保程序在使用完动态分配的内存后能够及时释放，避免内存泄漏和野指针相关的问题</p><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">char</span> *str = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="built_in">free</span>(str);</span><br><span class="line"> <span class="keyword">if</span>(str != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>运行 Test 函数会有什么样的结果？</strong></p><p><strong>解析</strong>：</p><blockquote><p>在释放内存之后，紧接着进行了 if(str!&#x3D; NULL) 的判断，这里存在一个误区，虽然直观上感觉释放内存后 str 应该变为 NULL ，但实际上 <strong>free 函数只是释放了 str 所指向的内存块</strong>，并<strong>不会自动将 str 指针本身设置为 NULL</strong>，所以此时 str 指针的值仍然是之前指向的那块已释放内存的地址（虽然<strong>这块内存已经被释放，不能再正常使用了</strong>），即 if 条件依然成立，执行语句导致未定义行为</p></blockquote><p><strong>修改后的代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (str!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(str);</span><br><span class="line">        str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配内存用于新的操作</span></span><br><span class="line">        str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (str!= <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(str, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">free</span>(str);</span><br><span class="line">            str = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放内存后及时将 str 指针设置为 NULL，并且当需要再次进行存储字符串等操作时，重新通过 malloc 分配了新的内存空间，这样可以保证操作的安全性和正确性</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a67638884c24d0fa74b7d3ac065884f.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.21——动态内存管理</title>
      <link href="/2024/11/20/C%E8%AF%AD%E8%A8%80/vlog21/"/>
      <url>/2024/11/20/C%E8%AF%AD%E8%A8%80/vlog21/</url>
      
        <content type="html"><![CDATA[<h1 id="内存的开辟与释放"><a href="#内存的开辟与释放" class="headerlink" title="内存的开辟与释放"></a>内存的开辟与释放</h1><p>过去我们开辟空间的方式有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">20</span>;<span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="type">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure><p>但是这种方式存在缺点：</p><blockquote><p>空间开辟大小是固定的数组在申明的时候，必须指定数组的长度，数组空间一旦确定了大小不能调整</p></blockquote><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>malloc 是一种常用的开辟空间的函数，它适用于各种类型的内存开辟。这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8991eda226e4ecb8b9770e569e26de9.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/malloc/?kw=malloc">malloc-C++参考</a></p></blockquote><p><strong>参数</strong>：size-表示需要分配的字节数</p><p><strong>返回值</strong>：返回一个指向所分配内存块起始地址的指针</p><p><strong>值得注意的是</strong>：</p><p>• 如果开辟成功，则返回⼀个指向开辟好空间的指针</p><p>• 如果开辟失败，则返回⼀个 NULL 指针，因此 malloc 的返回值⼀定要做检查</p><p>• 返回值的类型是 void* ，所以 malloc 函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定</p><p>• 如果参数 size 为0，malloc 的行为是标准是未定义的，取决于编译器</p><p><strong>eg</strong>：开辟100个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>；</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一般开辟了空间，就要检查该空间是否开辟成功</p><blockquote><p>malloc 或许还可以开辟 INT_MAX 的内存大小，但是在实际运行中，当你试图使用malloc(INT_MAX) 时，几乎肯定会导致内存分配失败，这只是一个理论上存在的值，malloc 函数会返回 NULL ，这是因为系统没有足够的连续空闲内存来满足这样大的请求</p></blockquote><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>malloc 开辟的内存是动态的，也就是说在程序结束时如果不释放的话，会一直占用空间，造成内存泄漏</p><h3 id="为什么要释放内存？"><a href="#为什么要释放内存？" class="headerlink" title="为什么要释放内存？"></a>为什么要释放内存？</h3><p>首先我们要知道什么是<strong>内存泄漏</strong></p><blockquote><p>&#x3D;&#x3D;内存泄漏&#x3D;&#x3D;是指程序动态分配的内存空间在使用完毕后没有被释放，导致这部分内存一直被占用。当程序中存在内存泄漏时，随着程序的运行，被泄漏的内存会不断累积</p></blockquote><p>所以长时间运行的程序，内存泄漏可能会导致系统内存逐渐被耗尽。当系统内存不足时，程序可能会出现性能下降、运行缓慢甚至崩溃的情况</p><h3 id="free的使用"><a href="#free的使用" class="headerlink" title="free的使用"></a>free的使用</h3><p>释放和回收动态内存的函数为 free ，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e3cedf97589c4b49bef07cfae28aed70.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/free/?kw=free">free-C++参考</a></p></blockquote><p><strong>参数</strong>：指向先前使用或分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• 如果参数 ptr 指向的空间不是动态开辟的，那 free 函数的行为是未定义的</p><p>• 如果参数 ptr 是 NULL 指针，则函数什么事都不做</p><p>• free 的内存释放可以理解为这块内存的使用权被取消掉了，而内存的回收销毁是栈实现的</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"> <span class="type">int</span> arr[num] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="literal">NULL</span>;</span><br><span class="line"> ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != ptr)<span class="comment">//判断ptr指针是否为空</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> *(ptr+i) = <span class="number">0</span>；</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(ptr);<span class="comment">//释放ptr所指向的动态内存</span></span><br><span class="line"> ptr = <span class="literal">NULL</span>;<span class="comment">//是否有必要？</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptr &#x3D; NULL 是有必要的，此时的 ptr 仍然指向该内存，但是这个内存已经被释放了，如果后续代码中错误地访问*p（比如试图修改或读取这个已经释放的内存空间中的值），就会导致程序出现未定义行为，可能会出现程序崩溃、数据错误等情况</p><h1 id="内存的初始化和修改"><a href="#内存的初始化和修改" class="headerlink" title="内存的初始化和修改"></a>内存的初始化和修改</h1><blockquote><p>malloc 提供的功能是开辟内存空间，万一我们想要增加使用的空间，可以再次使用 malloc开辟空间，但这又得创建一个变量存储，释放空间就要多次释放，这不免容易忘记，而且多次使用 malloc 开辟的空间通常是不连续的，哪里有空间他就在哪里开辟，那么就需要 realloc 函数提供修改动态空间的功能了</p></blockquote><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p>calloc 函数也用来动态内存分配，但是它可以初始化动态内存的内容，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3a4d4b3825b44b42b291abef68e8c178.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/calloc/?kw=calloc">calloc-C++参考</a></p></blockquote><p><strong>参数</strong>：num-元素个数，size-元素大小</p><p><strong>返回值</strong>：指向函数分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• 函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为 0</p><p>• 与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全 0</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line"> &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> p = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的内容为 10 个 0，证明 calloc 确实初始化开辟的空间为 0</p><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>realloc函数的出现让动态内存管理更加灵活，可以修改原先开辟的动态内存，声明在 &#x3D;&#x3D;stdlib.h&#x3D;&#x3D; 头文件中</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ad8ced63e2ef4b18a65528097595d2dd.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstdlib/realloc/?kw=realloc">realloc-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr-指向先前使用或分配的内存块的指针，size-元素大小</p><p><strong>返回值</strong>：指向重新分配的内存块的指针</p><p><strong>值得注意的是</strong>：</p><p>• ptr 是要调整的内存地址</p><p>• size 调整之后新大小(包含原来的大小)</p><p>• 返回值为调整之后的内存起始位置</p><p>• 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间</p><p>• realloc 在调整内存空间的是存在<strong>两种情况</strong>：</p><p> <strong>情况1</strong>：原有空间之后有足够大的空间</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a38d5e3054c40538318ad79e152d35e.png" alt="在这里插入图片描述"><br>直接在原有空间后面加上新的空间</p><p> <strong>情况2</strong>：原有空间之后没有足够大的空间<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c4be8f8576b2465ebe685d5de1e290c5.png" alt="在这里插入图片描述"><br>如果后续空间不够， realloc 函数直接在内存的堆区找一块新的满足大小的空间，将旧的数据拷贝到新的空间，原来的空间则自动释放，返回新的地址</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码1 - 直接将realloc的返回值放到ptr中</span></span><br><span class="line">ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">1000</span>);<span class="comment">//这样可以吗？(如果申请失败会如何？)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码2 - 先将realloc函数的返回值放在p中，不为NULL，在放ptr中</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">p = <span class="built_in">realloc</span>(ptr, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptr = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//业务处理</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码1</strong>：</p><blockquote><p>如果内存重新<strong>分配失败</strong>（例如，系统没有足够的连续内存来满足 1000 个 int 类型数据的内存需求），realloc 函数会返回 NULL，但这里的问题是，当它返回 NULL 时，<strong>原始的 ptr 所指向的内存块已经被释放</strong>（因为 realloc 在尝试重新分配失败时，会释放掉原始的内存块以避免内存泄漏），这就导致 ptr 变为 NULL，并且之前通过 <strong>ptr 可访问的原始数据也丢失了</strong>，后续若再尝试使用 ptr 就会导致程序出错</p></blockquote><p><strong>代码2</strong>：</p><blockquote><ol><li>先将 realloc 函数的返回值赋给 p ，然后进行判断的做法<strong>更为稳妥</strong>，同样执行 p &#x3D; realloc(ptr, 1000)，当重新分配成功时，通过判断 p!&#x3D; NULL 能确认重新分配成功，然后再将 p 的值赋给 ptr，使得 ptr 正确<strong>指向新的内存块</strong></li><li>如果重新<strong>分配失败</strong>，realloc 会返回 NULL，此时 p 为 NULL，由于没有直接将 NULL 赋给 ptr，所以 ptr <strong>仍然指向原来的内存块</strong>（前提是原来的内存块还未被 realloc 释放，在这种情况下，原来的内存块未被释放是因为重新分配失败后没有进行释放原始内存块的操作），这样就可以<strong>避免丢失原始数据以及出现空指针错误</strong></li></ol></blockquote><h1 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h1><h2 id="什么是柔性数组？优势是什么？"><a href="#什么是柔性数组？优势是什么？" class="headerlink" title="什么是柔性数组？优势是什么？"></a>什么是柔性数组？优势是什么？</h2><blockquote><p>柔性数组是 C99 标准中引入的一个特性，它是在一个结构体的最后一个成员位置定义的数组，并且这个数组的大小是可以灵活变化的，大小是未知的</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> data[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个结构体my_struct中，data就是一个柔性数组</p><p><strong>值得注意的是</strong>：</p><p>• 结构中的柔性数组成员前面<strong>必须至少一个其他成员</strong></p><p>• sizeof 返回的这种结构大小<strong>不包括柔性数组的内存</strong></p><p>• 包含柔性数组成员的结构用 malloc () 函数进行内存的动态分配，并且<strong>分配的内存应该大于结构的大小</strong>，以适应柔性数组的预期大小</p><h2 id="柔性数组的使用"><a href="#柔性数组的使用" class="headerlink" title="柔性数组的使用"></a>柔性数组的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">0</span>];<span class="comment">//柔性数组成员</span></span><br><span class="line">&#125;type_a;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> type_a *p = (type_a*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(type_a)+<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> p-&gt;i = <span class="number">100</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> p-&gt;a[i] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次将 i 的值赋值给柔性数组，柔性数组能被赋多少，那他的空间一般就为多少，这样柔性数组成员 a，相当于获得了 100 个整型元素的连续空间</p><p>但是不提倡在结构体里进行内存的二次分配，用户调用 free 可以释放结构体，但是用户并不知道这个结构体内的成员也需要 free，所以你不能指望用户来发现这个事</p><h1 id="C-C-内存分配"><a href="#C-C-内存分配" class="headerlink" title="C&#x2F;C++内存分配"></a>C&#x2F;C++内存分配</h1><p>以一段代码做例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">5</span>] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">char</span> *sh = <span class="string">&quot;zxcv&quot;</span></span><br><span class="line"><span class="type">int</span> *ptr1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="type">int</span> *ptr2 = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> *ptr3 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般程序中内存区域划分为：</p><ol><li><p><strong>内核空间（用户代码不能读写）</strong></p></li><li><p><strong>栈（向下增长）</strong>：<br>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放，栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限，<strong>栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">10</span>] ,<span class="type">char</span> ch[<span class="number">5</span>] ,<span class="type">char</span> *sh </span><br><span class="line"><span class="type">int</span> *ptr1 ,<span class="type">int</span> *ptr2 ,<span class="type">int</span> *ptr3 </span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>内存映射段（文件映射、动态库、匿名映射）</strong></p></li><li><p><strong>堆（向上增长）</strong>：<br>⼀般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方<br>式类似于链表，<strong>堆区主要存放动态开辟的内存空间等</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line">(<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">(<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr2,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>数据段（全局数据、静态数据）</strong></li></ol><p>（static）<strong>存放全局变量、静态数据</strong>，程序结束后由系统释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num , <span class="type">static</span> <span class="type">int</span> ret</span><br></pre></td></tr></table></figure><ol start="6"><li><strong>代码段（可执行代码&#x2F;只读常量）</strong></li></ol><p>存放函数体（类成员函数和全局函数）的<strong>二进制代码</strong></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b770db5fe7fe458db493a3056649c243.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.20——自定义类型：联合&amp;&amp;枚举</title>
      <link href="/2024/11/17/C%E8%AF%AD%E8%A8%80/vlog20/"/>
      <url>/2024/11/17/C%E8%AF%AD%E8%A8%80/vlog20/</url>
      
        <content type="html"><![CDATA[<h1 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h1><p><strong>什么是联合体？</strong>联合体也称<strong>共用体</strong>，顾名思义，共用共用就有节省空间的意思，它允许在相同的内存位置存储不同的数据类型，就是个<strong>缩小内存的结构体</strong></p><h2 id="联合体的声明及定义"><a href="#联合体的声明及定义" class="headerlink" title="联合体的声明及定义"></a>联合体的声明及定义</h2><p>联合体的声明，定义与结构体相同，只是类型不同，<strong>其语法形式为</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p>声明就是去掉 variable-list ，保留剩下的，可以在结构体上定义，也可以另起一行定义对象<br>上一篇结构体声明与定义有详细介绍</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143783658?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.19——自定义类型：结构体</a></p></blockquote><p>联合体的<strong>初始化</strong>也有<strong>特殊之处</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//联合类型的声明</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//联合变量的定义</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un1</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">Un</span> <span class="title">un2</span> =</span> &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, un1.i); </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, un2.i); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照联合体初始化规则，<strong>初始化赋值时将值赋给第一个成员</strong></p><blockquote><ol><li>&#x3D;&#x3D;<strong>赋值为 0 的情况</strong>&#x3D;&#x3D;：这是一种特殊情况，通常情况下只会将初始化的值赋给第一个变量，但是初始化为 0 在编译器的角度下是一种自然状态，编译器会将这个全 0 的状态自然地扩展到整个联合体的内存空间。这就好比在一个容器中倒入了无色无味的清水，清水会自然地填满整个容器。所以整个 un1 结构体都初始化为 0，<strong>即 un1.i &#x3D; 0</strong></li><li>&#x3D;&#x3D;<strong>赋值为其他值的情况</strong>&#x3D;&#x3D;：当用 ‘a’ 初始化联合体的第一个成员（如 char 类型）时，只会将 ‘a’ 的 ASCII 码值 97 存储在第一个成员对应的内存位置（即将 01100001 存在字符 c 中）<br>那如果用个很大的数，比如 9999 ，对于 9999 的二进制表示 00000000 00000000 00100111 00011111，实际存储到 c 中的就是 00011111，所以其余 3 个字节是未初始化的垃圾数据，如果访问整型 i 得到的结果是不可预测的，<strong>即 un2.i &#x3D; 随机值</strong></li></ol></blockquote><h2 id="联合体的内存计算"><a href="#联合体的内存计算" class="headerlink" title="联合体的内存计算"></a>联合体的内存计算</h2><p>联合体与结构体最大的不同就是不会浪费内存，尽可能节省空间，这样⼀个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d32d2c1b27264304a975bc895b87796c.jpeg" alt="请添加图片描述"><br><strong>代码1 输出</strong>：001BC63F、001BC63F、001BC63F<br><strong>代码2 输出</strong>：11223355</p><p>不难发现联合体的部分或整体地址都一样，整型 i 的数据被字符 c 覆盖，这是为什么呢？</p><blockquote><p>地址从高到低存放 44332211 ，而联合体是共用空间的，所以把 55 覆盖在 44上。有人就会有疑惑了，为什么不是地址从低到高存放 44332211，把 55 覆盖在 11上，这就和数据的字节存储方式有关了，马上就会介绍到。<br>言归正传，把字符 c 覆盖在 整型 i 上，i 就无法使用了，所以联合体就是一种能够使用多种类型的集合体，但每次想要使用就要对要使用的值赋值，覆盖之前的数据，使想要的数据有完整的值，处于能正常访问的状态</p></blockquote><p><strong>那么联合体的大小究竟如何计算呢？</strong></p><p>• 联合的大小至少是最大成员的大小<br>• 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍</p><h2 id="1-3-联合体和结构体比较"><a href="#1-3-联合体和结构体比较" class="headerlink" title="1.3 联合体和结构体比较"></a>1.3 联合体和结构体比较</h2><p>对比结构体和联合体的空间存储情况就能清楚地知道为什么联合体能节省空间了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">S</span>//<span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;<span class="comment">//struct S s = &#123;0&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>分别在空间中的存储情况</strong>：<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f119066238e941a0bc3fedd930634dc8.png" alt="在这里插入图片描述"><br>黄色部分是浪费的空间，明显结构体为了能完整存储每个变量，会采取空间换时间的方式</p><h2 id="大小端介绍"><a href="#大小端介绍" class="headerlink" title="大小端介绍"></a>大小端介绍</h2><p><strong>什么是大小端？</strong></p><blockquote><ol><li>大端也叫大端序或大字节序，数据的高位字节存于低地址，低位字节存于高地址</li><li>叫小端序或小字节序，与大端相反，数据的低位字节存于低地址，高位字节存于高地址</li></ol></blockquote><p>这就可以解答我们上面的疑惑了，”地址从低到高存放 44332211，把 55 覆盖在 11上” 是因为机器采用了小端存储的方式，不同的机器的存储方式各有不同，根据其所处的环境和需求决定</p><p><strong>如何通过代码判断大小端？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_sys</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line"> &#125;un;</span><br><span class="line"> un.i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> un.c;<span class="comment">//返回1是⼩端，返回0是⼤端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合体的应用"><a href="#联合体的应用" class="headerlink" title="联合体的应用"></a>联合体的应用</h2><p>比如，我们要搞⼀个活动，要上线一个礼品兑换单<br>礼品兑换单中有三种商品：图书、杯子、衬衫<br>每一种商品都有：库存量、价格、商品类型和商品类型<strong>相关的其他信息</strong></p><blockquote><ol><li>图书：书名、作者、页数</li><li>杯子：设计</li><li>衬衫：设计、可选颜色、可选尺寸</li></ol></blockquote><p>如果使用结构体就要把所有物品，不论是公共属性，还是特殊属性都要表示出来<br>如果使用结构体就可以把特殊属性作为结构体放在联合体里，要用哪个就赋值哪个，能省下不少空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gift_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> stock_number;<span class="comment">//库存量</span></span><br><span class="line"> <span class="type">double</span> price; <span class="comment">//定价</span></span><br><span class="line"> <span class="type">int</span> item_type;<span class="comment">//商品类型</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> title[<span class="number">20</span>];<span class="comment">//书名</span></span><br><span class="line"> <span class="type">char</span> author[<span class="number">20</span>];<span class="comment">//作者</span></span><br><span class="line"> <span class="type">int</span> num_pages;<span class="comment">//⻚数</span></span><br><span class="line"> &#125;book;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> design[<span class="number">30</span>];<span class="comment">//设计</span></span><br><span class="line"> &#125;mug;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="type">char</span> design[<span class="number">30</span>];<span class="comment">//设计</span></span><br><span class="line"> <span class="type">int</span> colors;<span class="comment">//颜⾊</span></span><br><span class="line"> <span class="type">int</span> sizes;<span class="comment">//尺⼨</span></span><br><span class="line"> &#125;shirt;</span><br><span class="line"> &#125;item;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p><strong>什么是枚举？</strong>枚举用于定义一组命名的常量，例如，在一个表示星期的程序中，我们可以定义一个枚举类型来代表一周的七天，而不是使用数字 0 - 6 来分别表示星期一到星期日</p><h2 id="枚举的声明"><a href="#枚举的声明" class="headerlink" title="枚举的声明"></a>枚举的声明</h2><p><strong>表示星期</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>//星期</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Mon,</span><br><span class="line"> Tues,</span><br><span class="line"> Wed,</span><br><span class="line"> Thur,</span><br><span class="line"> Fri,</span><br><span class="line"> Sat,</span><br><span class="line"> Sun</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>表示颜色</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>//颜⾊</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> RED,</span><br><span class="line"> GREEN,</span><br><span class="line"> BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>{}中的内容是枚举类型的可能取值，也叫 枚举常量，这些可能取值都是有值的，默认从0开始，依次递增1，当然在声明枚举类型的时候也可以赋初值</p></blockquote><p>比如颜色枚举常量，从上到下默认为RED、GREEN、BLUE赋值0、1、2</p><p><strong>为什么非要用枚举常量，用宏定义(#define)不也可以吗？</strong></p><p>• 增加代码的可读性和可维护性</p><p>• 和 #define 定义的标识符比较枚举有类型检查，更加严谨</p><p>• 便于调试，预处理阶段会删除 #define 定义的符号</p><p>• 使用方便，一次可以定义多个常量</p><p>• 枚举常量是遵循作用域规则的，枚举声明在函数内，只能在函数内使用</p><blockquote><p>这里只要知道枚举常量在各种意义上来说，表示一系列常量时是优于宏定义，关于预处理阶段的宏定义，会在后续进行详细介绍</p></blockquote><h2 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>//颜⾊</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> RED=<span class="number">1</span>,</span><br><span class="line"> GREEN=<span class="number">2</span>,</span><br><span class="line"> BLUE=<span class="number">4</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> <span class="title">clr</span> =</span> GREEN;</span><br></pre></td></tr></table></figure><p>枚举量可以作为常量给变量赋值，这里提醒一下，在 switch 语句中，case 后面也可以接枚举量，这能使代码的可读性更高</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0ecf2d4f72c40e6ba7a4442ede0bd8b.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.19——自定义类型：结构体</title>
      <link href="/2024/11/15/C%E8%AF%AD%E8%A8%80/vlog19/"/>
      <url>/2024/11/15/C%E8%AF%AD%E8%A8%80/vlog19/</url>
      
        <content type="html"><![CDATA[<p>前面在学习操作符的时候，已经对结构体有了初步了解，结构体不仅在C语言中经常使用，也为C++学习类和对象打下基础，本篇 vlog 将对结构体进行详细的解析</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/143237196?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.10——进制转化&amp;&amp;操作符进阶</a></p></blockquote><h1 id="结构体的声明与初始化"><a href="#结构体的声明与初始化" class="headerlink" title="结构体的声明与初始化"></a>结构体的声明与初始化</h1><p>数组用于存放同类型的数据，而结构体是用于存放不同类型变量的函数的集合</p><p><strong>其语法形式为</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="普通声明"><a href="#普通声明" class="headerlink" title="普通声明"></a>普通声明</h2><p>比如我们想要描述一个学生</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"> <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"> <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号</span></span><br><span class="line">&#125;; <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure><p>声明只需要写出返回类型，参数，函数名<br>返回类型是 struct ，参数是学生的信息，函数名是 Stu</p><h2 id="创建及初始化"><a href="#创建及初始化" class="headerlink" title="创建及初始化"></a>创建及初始化</h2><p>struct 是一种自定义类型，那么就规定需要为其<strong>创建对象</strong>，那么如何理解对象呢？</p><blockquote><p>假设类是一个大房子，struct 就是房子的类型，Stu就是房子的名字，房子里入住的人就是对象，对象能够在同一种类中，但是他们的个人信息可以不同</p></blockquote><p><strong>初始化的方式有两种</strong>：</p><p>1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line"> <span class="type">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"> <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line"> <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号</span></span><br><span class="line">&#125;s1，s2;</span><br></pre></td></tr></table></figure><p>在 variable-list 处写出对象名</p><p>2）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//按照结构体成员的顺序初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s</span> =</span> &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;20230818001&quot;</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, s.name);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;age : %d\n&quot;</span>, s.age);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sex : %s\n&quot;</span>, s.sex);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;id : %s\n&quot;</span>, s.id);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//按照指定的顺序初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s2</span> =</span> &#123; .age = <span class="number">18</span>, .name = <span class="string">&quot;lisi&quot;</span>, .id = <span class="string">&quot;20230818002&quot;</span>, .sex = </span><br><span class="line"><span class="string">&quot;⼥&quot;</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;name: %s\n&quot;</span>, s2.name);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;age : %d\n&quot;</span>, s2.age);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sex : %s\n&quot;</span>, s2.sex);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;id : %s\n&quot;</span>, s2.id);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在结构体外创建对象，根据之前讲过的操作符，可以按结构体的默认顺序来初始化，也可以用结构体成员访问操作符直接或间接访问，这里不涉及指针，所以不用 -&gt;</p><h2 id="特殊声明"><a href="#特殊声明" class="headerlink" title="特殊声明"></a>特殊声明</h2><p>声明结构体可以不完全声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">float</span> c;</span><br><span class="line">&#125;x;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">float</span> c;</span><br><span class="line">&#125;a[<span class="number">20</span>], *p;</span><br></pre></td></tr></table></figure><p>这两个结构体省略了函数名，编译器会把上面的两个声明当成完全不同的两个类型，所以是非法的，匿名的结构体类型，如果没有对结构体类型重命名的话，基本上只能使用一次</p><h2 id="结构体的自引用"><a href="#结构体的自引用" class="headerlink" title="结构体的自引用"></a>结构体的自引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码是错误的</p><blockquote><p>要确定一个 struct Node 实例的大小，就需要先确定它内部成员 next 的大小（因为结构体成员是依次排列在内存中的），但 next 本身又是 struct Node 类型，要确定它的大小又得先确定它内部 next 的大小…… 这样就陷入了无限循环的困境，编译器无法准确计算出 struct Node 结构体到底应该占用多少内存空间，所以这种写法在内存布局上就是不合理且无法实现的</p></blockquote><p><strong>修改后</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过让 next 指针指向另一个 Node 结构体，就可以实现数据元素之间的链式存储关系</p><p><strong>那如果夹杂了 typedef 对匿名结构体类型重命名呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> Node* next;</span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>答案是错误的，他在对 struct 重命名完成之前就在内部使用了重命名后的名字</p><h1 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h1><p>那么结构体的大小该如何计算呢？<br>这也是近几年面试题竞赛题常考的点</p><h2 id="对齐规则"><a href="#对齐规则" class="headerlink" title="对齐规则"></a>对齐规则</h2><blockquote><ol><li>结构体的第⼀个成员对齐到和结构体变量起始位置<strong>偏移量为 0 的地址处</strong></li><li>其他成员变量要对齐到某个数字（对齐数）的整数倍的<strong>地址处</strong><br>• <strong>对齐数</strong> &#x3D; 编译器默认的⼀个对齐数与该成员变量大小的<strong>较小值</strong><br> • VS 中<strong>默认的值为 8</strong>（可修改）<br> • Linux中 gcc 没有默认对齐数，对齐数就是成员自身的大小</li><li>结构体总大小为<strong>最大对齐数</strong>（结构体中每个成员变量都有⼀个对齐数，所有对齐数中最大的）<strong>的整数倍</strong></li><li>如果嵌套了结构体的情况，<strong>嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处</strong>，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍</li></ol></blockquote><p>是不是看的感觉有些迷糊？举个例子你就明白了</p><p><strong>代码1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S1));</span><br></pre></td></tr></table></figure><p>本题的答案是 12</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b5f6049dbe104dfd842a479de49a4b73.png" alt="在这里插入图片描述"></p><blockquote><p>刚开始 c1 对其到地址为 0 处，然后比较 i 和 8 发现 i 小，所以这里对齐数为 4 ，所以在 4 的尽可能最小倍数处对齐，即地址为 4 处，同理 c2 与 8比较发现 c2 小，所以这里对齐数为 1，所以在 1 的尽可能最小倍数处对齐，则总体大小为最大对齐数的尽可能最小倍数，即最大对齐数为 4，则总体大小为 12</p></blockquote><p><strong>代码2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">S1</span> <span class="title">s1</span>;</span></span><br><span class="line"> <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S4));</span><br></pre></td></tr></table></figure><p>答案是 24</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ff487e10e97c47c4ac0fc2b1b4cb3349.png" alt="在这里插入图片描述"></p><p>这里说一下 struct S1 的最大对齐数为 4 ，大小为 12 ，其他都与代码 1 的处理方式同理</p><h2 id="结构体对齐存在的重要性"><a href="#结构体对齐存在的重要性" class="headerlink" title="结构体对齐存在的重要性"></a>结构体对齐存在的重要性</h2><p>结构体的内存对齐是拿空间来换取时间的做法</p><h3 id="平台原因"><a href="#平台原因" class="headerlink" title="平台原因"></a>平台原因</h3><blockquote><p>不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</p></blockquote><h3 id="性能原因"><a href="#性能原因" class="headerlink" title="性能原因"></a>性能原因</h3><blockquote><p>数据结构(尤其是栈)应该尽可能地在自然边界上对齐，原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要⼀次访问，假设⼀个处理器总是从内存中取8个字节，则地址必须是8的倍数，如果我们能保证将所有的 double 类型的数据的地址都对齐成8的倍数，那么就可以用⼀个内存操作来读或者写值了，否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中</p></blockquote><p>比如刚才的代码1</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e97ac5cd06e94ef0b2efcbbe9792c0fe.png" alt="在这里插入图片描述"><br>如果没有内存对齐，假设一个机器是 4 位读取，那么 int i 就需要分两次才能得到这个数据，或许你觉得这没什么，但是在大型的项目的数据里，这种方式是十分低效率的，按照对齐规排序能够保证读取能够读取一个完整数据</p><h2 id="修改默认对齐数"><a href="#修改默认对齐数" class="headerlink" title="修改默认对齐数"></a>修改默认对齐数</h2><p>结构体在对齐方式不合适的时候，我们可以自己更改默认对齐数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">//设置默认对⻬数为1</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> c1;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()<span class="comment">//取消设置的对⻬数，还原为默认</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//输出的结果是什么？</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#pragma 这个预处理指令，可以改变编译器的默认对齐数</p><h1 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data[<span class="number">1000</span>];</span><br><span class="line"> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print1</span><span class="params">(<span class="keyword">struct</span> S s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print2</span><span class="params">(<span class="keyword">struct</span> S* ps)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> print1(s); <span class="comment">//传结构体</span></span><br><span class="line"> print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过我前面介绍传值调用和传址调用的uu们应该知道，传地址的效果明显好很多</p><p><strong>原因</strong>：</p><p> • 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销<br> • 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导 致性能的下降</p><h1 id="位段的实现"><a href="#位段的实现" class="headerlink" title="位段的实现"></a>位段的实现</h1><h2 id="什么是位段"><a href="#什么是位段" class="headerlink" title="什么是位段"></a>什么是位段</h2><p>位段的声明和结构与结构体类似</p><p><strong>不同的是</strong>：</p><ol><li>位段的成员必须是 int、unsigned int 或signed int ，在C99中位段成员的类型也可以选择其他类型</li><li>位段的成员名后边有一个冒号和一个数字</li></ol><p><strong>举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> _a:<span class="number">2</span>;</span><br><span class="line"> <span class="type">int</span> _b:<span class="number">5</span>;</span><br><span class="line"> <span class="type">int</span> _c:<span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的 A 就是一种位段，后面的数字表示其所占的位数，单位是比特<br>可是一个 int 类型所占的比特位不应该是32位吗？</p><h2 id="位段的内存分配"><a href="#位段的内存分配" class="headerlink" title="位段的内存分配"></a>位段的内存分配</h2><p>位段的内存分配准确来说和结构体内存分配不同的地方在于位段尽可能压缩了内存的占用，但其局限性在于限制了比特位，只能输出特定范围的数据</p><blockquote><ol><li>位段的成员可以是 int unsigned int signed int 或者是 char 等类型</li><li>位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段</li></ol></blockquote><p><strong>举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> a:<span class="number">3</span>;</span><br><span class="line"> <span class="type">char</span> b:<span class="number">4</span>;</span><br><span class="line"> <span class="type">char</span> c:<span class="number">5</span>;</span><br><span class="line"> <span class="type">char</span> d:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">s.a = <span class="number">10</span>;</span><br><span class="line">s.b = <span class="number">12</span>;</span><br><span class="line">s.c = <span class="number">3</span>;</span><br><span class="line">s.d = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>这里设置 a b c d 的内存占用比特位为 3 4 5 4（注意不要将其误认为初始化），为这几个数赋值 10 12 3 4<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d42b11c04e9648debc09dd4e5dfc9ea4.png" alt="在这里插入图片描述"></p><p>VS2013测试数据：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ed325a1e2d645a0887a6f49da2d0d0f.png" alt="VS2013测试数据"></p><p>由分析可得，冒号后的位数表示占用比特位，放进去的数由于位数的限制，会导致其只能输出限制位所能表达的二进制数</p><h2 id="位段的跨平台问题"><a href="#位段的跨平台问题" class="headerlink" title="位段的跨平台问题"></a>位段的跨平台问题</h2><blockquote><ol><li>int 位段被当成有符号数还是无符号数是不确定的</li><li>位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题</li><li>位段中的成员在内存中从左向右分配，还是从右向左分配，标准尚未定义</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的</li></ol></blockquote><p>所以跟结构体相比，位段能够起到很好的节省空间的效果，但是其平台移植性差，其他的机器不一定能够适应其结构</p><h2 id="4-4位段的使用"><a href="#4-4位段的使用" class="headerlink" title="4.4位段的使用"></a>4.4位段的使用</h2><p>首先我们要知道内存中每个字节分配一个地址，一个字节内部的 bit 位是没有地址的，而位段的地址不在某个字节处，所以我们不能在 scanf 函数中使用 &amp; 进行取地址赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> _a : <span class="number">2</span>;</span><br><span class="line"> <span class="type">int</span> _b : <span class="number">5</span>;</span><br><span class="line"> <span class="type">int</span> _c : <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> _d : <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">sa</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sa._b);<span class="comment">//这是错误的</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//正确的⽰范</span></span><br><span class="line"> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b);</span><br><span class="line"> sa._b = b;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法是先对某一个变量进行初始化赋值，然后再将该变量赋值给位段，进行二进制位数的处理，从而达到位段的效果</p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=rjfiwit5a9zh">https://cloud.tencent.com/developer/support-plan?invite_code=rjfiwit5a9zh</a></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/aa3ce00fb59849e7b76f5acb6b510772.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.18——内存函数</title>
      <link href="/2024/11/13/C%E8%AF%AD%E8%A8%80/vlog18/"/>
      <url>/2024/11/13/C%E8%AF%AD%E8%A8%80/vlog18/</url>
      
        <content type="html"><![CDATA[<h1 id="memcpy函数"><a href="#memcpy函数" class="headerlink" title="memcpy函数"></a>memcpy函数</h1><p><strong>memcpy</strong> 主要用于将一段内存中的数据完整地复制到另一段内存中，在很多场景下都非常有用，例如在处理数组、结构体等数据结构时，从源内存地址 src 复制 n 个字节的数据到目标内存地址 destination</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/195affa979924dcb84ca89d8c09a2d71.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memcpy/?kw=memcpy">memcpy-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-目标内存地址，它是一个 void* 类型的指针，source-源内存地址，同样是 void* 类型(不可修改)，num-要复制的字节数</p><p><strong>返回值</strong>：返回指向目标内存地址 destination 的指针</p><p><strong>值得注意的是</strong>：函数 memcpy 从 source 的位置开始向后复制 num 个字节的数据 destination 指向的内存位置，这个函数在遇到 ‘\0’ 的时候并不会停下来，如果 source 和destination 有任何的重叠，复制的结果都是未定义的</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, <span class="built_in">strlen</span>(src)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>memcpy 函数将 src 数组中的字符串（包括字符串结束符 \0 ）复制到 dest 数组中 strlen(src)+1 是为了把 \0 也复制过去</p></blockquote><p><strong>memcpy 的模拟实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memcpy</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ret = dst;</span><br><span class="line">assert(dst);</span><br><span class="line">assert(src);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* copy from lower addresses to higher addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将dst和src先强制转换为char*类型，实现了以字节为单位的访问和赋值操作，因为 char类型在内存中占用一个字节，所以这样可以逐个字节地复制数据，而不管原始数据的类型是什么，分别将目标地址 dst 和源地址 src 向后移动一个字节的位置，以便在下一次循环中复制下一个字节的数据</p></blockquote><h1 id="memmove函数"><a href="#memmove函数" class="headerlink" title="memmove函数"></a>memmove函数</h1><p><strong>memmove</strong> 和 memcpy 类似，也是从源内存地址 source 复制 num 个字节的数据到目标内存地址destination ，但是 memmove 函数<strong>能够处理源内存区域和目标内存区域重叠的情况</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/578a0946815a4ea0b1c3743968fdeab8.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memmove/?kw=memmove">memmove-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-目标内存地址，它是一个 void* 类型的指针，source-源内存地址，同样是 void* 类型(不可修改)，num-要复制的字节数</p><p><strong>返回值</strong>：返回指向目标内存地址 destination 的指针</p><p><strong>值得注意的是</strong>：和 memcpy 的差别就是 memmove 函数处理的源内存块和目标内存块是可以重叠的，如果源空间和目标空间出现重叠，就得使用 memmove 函数处理</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串中的后3个字符向前移动2个位置</span></span><br><span class="line">    memmove(str + <span class="number">2</span>, str + <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str + 3 是源地址，str + 2 是目标地址，存在重叠部分，memmove 函数可以正确地完成复制操作，而 memcpy 函数不能完成有重叠的操作</p><p><strong>mememove 的模拟实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">memmove</span><span class="params">(<span class="type">void</span>* dst, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ret = dst;</span><br><span class="line"><span class="keyword">if</span> (dst &lt;= src || (<span class="type">char</span>*)dst &gt;= ((<span class="type">char</span>*)src + count)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Non-Overlapping Buffers</span></span><br><span class="line"><span class="comment">* copy from lower addresses to higher addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst + <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Overlapping Buffers</span></span><br><span class="line"><span class="comment">* copy from higher addresses to lower addresses</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dst = (<span class="type">char</span>*)dst + count - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src + count - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">*(<span class="type">char</span>*)dst = *(<span class="type">char</span>*)src;</span><br><span class="line">dst = (<span class="type">char</span>*)dst - <span class="number">1</span>;</span><br><span class="line">src = (<span class="type">char</span>*)src - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先判断源内存区域和目标内存区域是否有重叠情况，然后就是分为非重叠和重叠的情况和 memcpy 模拟实现类似的操作</p></blockquote><h1 id="memset函数"><a href="#memset函数" class="headerlink" title="memset函数"></a>memset函数</h1><p>memset 能将指定内存区域 ptr 的前 num 个字节<strong>设置为指定的值 value</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fa7d76805e8a4a30b7ccc34a335d7a97.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memset/?kw=memset">memset-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr-要设置的内存区域的起始地址，是 void* 类型，value-要设置的值，这个值会被转换为 unsigned char 类型后进行设置，num-要设置的字节数</p><p><strong>返回值</strong>：返回指向设置后的内存区域 ptr 的指针</p><p><strong>值得注意的是</strong>：设置完内容后，记得在后面加上 \0</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>);</span><br><span class="line">    buffer[<span class="number">5</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memset 将 buffer 数组的前 5 个字节设置为字符A，然后手动添加字符串结束符 \0 ，以便能够正确地使用 printf 输出字符串</p><h1 id="memcmp函数"><a href="#memcmp函数" class="headerlink" title="memcmp函数"></a>memcmp函数</h1><p>memcmp 用于<strong>比较两个内存区域</strong> ptr1 和 ptr2 的前 num 个字节<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/87ad2ce236224c7688ee9ce5d6c911f6.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/memcmp/?kw=memcmp">memcmp-C++参考</a></p></blockquote><p><strong>参数</strong>：ptr1、ptr2-要比较的两个内存区域的起始地址，都是 const void* 类型，num-要比较的字节数</p><p><strong>返回值</strong>：<br>• 如果 ptr1 所指向的内存区域的前 num 个字节大于 ptr2 所指向的内存区域的前 num 个字节，返回一个大于 0 的值<br>• 如果 ptr1 所指向的内存区域的前 num 个字节小于 ptr2 所指向的内存区域的前 num 个字节，返回一个小于 0 的值<br>• 如果 ptr1 所指向的内存区域的前 num 个字节等于 ptr2 所指向的内存区域的前 num 个字节，返回 0</p><p><strong>值得注意的是</strong>：比较从 ptr1 和 ptr2 指针指向的位置开始，向后的 num 个字节，遇到第一个不一样的比较就行了</p><p><strong>eg</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;abd&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">memcmp</span>(str1, str2, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memcmp 比较 str1 和 str2 的前 3 个字节，因为 c 的 ASCII 码小于 d 的 ASCII 码，所以返回一个小于 0 的值 </p><p>以上就是主要使用的内存函数，过几天就参加全国计挑了，希望可以拿个奖，没拿到就当练手了吧，毕竟竞赛经验更重要🤩</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ee65acb7681b439fbf6fef55b8ae83c4.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.17——字符函数&amp;&amp;字符串函数</title>
      <link href="/2024/11/11/C%E8%AF%AD%E8%A8%80/vlog17/"/>
      <url>/2024/11/11/C%E8%AF%AD%E8%A8%80/vlog17/</url>
      
        <content type="html"><![CDATA[<h1 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h1><blockquote><p>字符函数通常是针对单个字符进行操作的函数，它们接受一个字符作为参数，并返回与该字符相关的某种属性或经过特定处理后的结果</p></blockquote><h2 id="字符分类函数"><a href="#字符分类函数" class="headerlink" title="字符分类函数"></a>字符分类函数</h2><p>此类函数主要用于字符的分类，需要包含头文件 &#x3D;&#x3D;#include &lt;ctype.h&gt;&#x3D;&#x3D;<br>以下介绍一个常用的字符分类函数</p><h3 id="islower"><a href="#islower" class="headerlink" title="islower"></a>islower</h3><p>islower 用于检查字符是否为小写字母， isupper 作用与其相反<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b09e05f80aea46358ace61baf971e31d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cctype/islower/?kw=islower">islower-C++参考</a></p></blockquote><p><strong>参数</strong>：要检查的参数，即大小写字母</p><p><strong>返回值</strong>：如果 c 确实是小写字母，则该值不为零（即 true），否则为 0（即 false）</p><p>举个例子：将字符串中的小写字母都转成大写字母，其他字符不变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Test String.\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (str[i])</span><br><span class="line">&#123;</span><br><span class="line">c = str[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">islower</span>(c))</span><br><span class="line">c -= <span class="number">32</span>; </span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符转换函数"><a href="#字符转换函数" class="headerlink" title="字符转换函数"></a>字符转换函数</h2><p>此类函数主要用于字符的转换，需要包含头文件 &#x3D;&#x3D;#include &lt;ctype.h&gt;&#x3D;&#x3D;<br>以下介绍一个常用的字符转换函数</p><h3 id="tolower"><a href="#tolower" class="headerlink" title="tolower"></a>tolower</h3><p>tolower 用于将参数传进去的大写字母转小写，与 islower 不同的是，islower 只是判断，tolower是直接转换。toupper 用于将参数传进去的小写字母转大写，与 tolower 同理<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b8dfd76c988c4f6dbe2c20b2558b916b.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cctype/tolower/?kw=tolower">tolower-C++参考</a></p></blockquote><p><strong>参数</strong>：要检查的参数，即大小写字母</p><p>还是和上面相同的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Test String.\n&quot;</span>;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> (str[i])</span><br><span class="line">&#123;</span><br><span class="line">c = str[i];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">islower</span>(c))</span><br><span class="line">c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 c &#x3D; toupper( c ) 把 c -&#x3D; 32 替代了，省去了记 ASC|| 值的麻烦，以后修改值直接使用转换字符函数就行了</p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><blockquote><p>字符串函数则是对字符串（由零个或多个字符组成的序列）进行各种操作的函数，比如获取字符串长度、查找子字符串、替换字符串内容等</p></blockquote><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>看过我往期 vlog 的同学，该函数相信大家已经烂熟于心了，这里就不再过多赘述<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/bc18bff128b84cdd8ee2d71b8621decc.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen">strlen-C++参考</a></p></blockquote><h2 id="strcpy和strncpy"><a href="#strcpy和strncpy" class="headerlink" title="strcpy和strncpy"></a>strcpy和strncpy</h2><p>strcpy 用于将一个字符串复制到另一个字符串中，即 copy<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c1c61d39a2c84ad69cad9c2d98d6cc69.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy">strcpy-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-指向要复制内容的目标数组的指针，source-要复制的 C 字符串(注意原字符串不可修改)</p><p><strong>返回值</strong>：destination 的起始地址</p><p><strong>值得注意的是</strong>：源字符串必须以 ‘\0’ 结束，拷贝会将源字符串中的 ‘\0’ 拷贝到目标空间，且目标空间必须足够大，以确保能存放源字符串，目标空间必须可修改</p><p><strong>strcpy 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* ret = dest;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((*dest++ = *src++))</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将 dest 的起始地址存储到变量 ret，以便返回值返回，对两个形参进行断言操作，避免空指针的使用 while 循环里的两个变量先各自++，然后从右向左赋值，直到 src 遇到 \0 循环才停止</p></blockquote><p><strong>和 strcpy 相像的是 strncpy</strong> </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/97af51217ba04c8fa5d877fcbac1c460.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncpy/?kw=strncpy">strncpy-C++参考</a></p></blockquote><p>唯一与 strcpy 不同的是它可以固定复制的个数，不只是以 \0 为标准停下来</p><p><strong>值得注意的是</strong>：在指定的连接字符个数中是不包括\0的，拷贝num个字符从源字符串到目标空间，如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个</p><h2 id="strcat和strncat"><a href="#strcat和strncat" class="headerlink" title="strcat和strncat"></a>strcat和strncat</h2><p>strcat 用于将一个字符串连接到另一个字符串的末尾，即 concatenate，需要包含头文件     &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dd07ab4ea9f04a35acec58d389c2cf17.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcat/?kw=strcat">strcat-C++参考</a></p></blockquote><p><strong>参数</strong>：destination-指向要复制内容的目标数组的指针，source-要复制的 C 字符串(注意 destination 和 source 不能重合)</p><p><strong>返回值</strong>：destination 的起始地址</p><p><strong>值得注意的是</strong>：源字符串必须以 ‘\0’ 结束，目标字符串中也得有 \0 ，否则没办法知道追加从哪里开始，目标空间必须有足够的大，能容纳下源字符串的内容，目标空间必须可修改，追加过程中是会覆盖掉目标字符串末尾的 \0 的</p><p><strong>如果自己给自己追加呢？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(str, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原字符串str初始化为 “Hello”，它所占用的内存空间是按照初始化时设定的长度来分配的<br>• 理论上：追加过程中是会覆盖掉目标字符串末尾的 \0 的，但是不会把原字符串的 \0 复制过去，而是复制完后编译器自动在末尾加上一个 \0<br>• 实际上：自己给自己追加这个操作是无法让编译器到达添加 \0 这一步的，所以 “Hello” 会一直追加，无限循环下去，直到数组栈溢出报错为止</p></blockquote><p><strong>strcat 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* ret = dest;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*dest)</span><br><span class="line">&#123;</span><br><span class="line">dest++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((*dest++ = *src++))</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实就是在 strcpy 模拟实现的的基础上加了个循环，让指针指向目标字符串的末尾再开始</p></blockquote><p><strong>和 strcat 相像的是 strncat</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/62c28cecd1b043899763e015a824bf33.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncat/?kw=strncat">strncat-C++参考</a></p></blockquote><p>唯一与 strcat 不同的是它可以固定追加的个数，不只是以 \0 为标准停下来</p><p><strong>值得注意的是</strong>：在指定的连接字符个数中是不包括\0的，将 source 指向字符串的前 num 个字符追加到 destination 指向的字符串末尾，再追加⼀个 \0 字符，如果 source 指向的字符串的长度小于 num 的时候，只会将字符串中到 \0 的内容追加到 destination 指向的字符串末尾</p><h2 id="strcmp和strncmp"><a href="#strcmp和strncmp" class="headerlink" title="strcmp和strncmp"></a>strcmp和strncmp</h2><p>strcmp 用于比较两个字符串的函数，即 compare，需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/83d6d9cb8c184d78a14ef4caaa7b5b7a.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strcmp/?kw=strcmp">strcmp-C++参考</a></p></blockquote><p><strong>参数</strong>：str1、str2-要比较的字符串</p><p><strong>返回值规定</strong>：<br>• 第一个字符串大于第二个字符串，则返回大于 0 的数字<br>• 第一个字符串等于第二个字符串，则返回 0<br>• 第一个字符串小于第二个字符串，则返回小于 0 的数字</p><p><strong>如何判断两个字符串？</strong></p><blockquote><p>比较两个字符串中对应位置上字符ASCII码值的大小</p></blockquote><p><strong>strcmp 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*str1 == *str2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*str1 == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">str1++;</span><br><span class="line">str2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *str1 - *str2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>str1 和 str2分别逐个向后一个一个比较，直到遇到第一个大小不同的字符，立马停下，后面都不比较了，无论这个字符串多长，都只看第一个遇到的不同的字符谁大谁小，以ASC|| 的差值作返回值</p></blockquote><p><strong>和 strcmp 相像的是 strnccmp</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0eb3ff77aef248d8b9b0b39de9375ced.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strncmp/?kw=strncmp">strncmp-C++参考</a></p></blockquote><p>唯一与 strcmp 不同的是它可以固定比较的个数</p><p><strong>值得注意的是</strong>：比较 str1 和 str2 的前 num 个字符，如果相等就继续往后比较，最多比较 num 个字母，如果提前发现不⼀样，就提前结束，大的字符所在的字符串大于另外一个，如果 num 个字符都相等，就是相等返回 0</p><h2 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h2><p>strstr 用于查找在一个字符串中查找另一个指定字符串（子字符串）的首次出现位置<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a1666f20b4f54d4994e9e644dc9ca51d.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strstr/?kw=strstr">strstr-C++参考</a></p></blockquote><p><strong>参数</strong>：str1-要扫描的字符串，str2-包含要匹配的字符序列</p><p><strong>返回值</strong>：指向 str2 中指定的整个字符序列在 str1 中第一次出现的指针，如果 str1 中不存在序列，则为空指针</p><p><strong>strstr 的模拟实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* cp = (<span class="type">char</span>*)str1;</span><br><span class="line"><span class="type">char</span>* s1, * s2;</span><br><span class="line"><span class="keyword">if</span> (!*str2)</span><br><span class="line"><span class="keyword">return</span>((<span class="type">char</span>*)str1);</span><br><span class="line"><span class="keyword">while</span> (*cp)</span><br><span class="line">&#123;</span><br><span class="line">s1 = cp;</span><br><span class="line">s2 = (<span class="type">char</span>*)str2;</span><br><span class="line"><span class="keyword">while</span> (*s1 &amp;&amp; *s2 &amp;&amp; !(*s1 - *s2))</span><br><span class="line">s1++, s2++;</span><br><span class="line"><span class="keyword">if</span> (!*s2)</span><br><span class="line"><span class="keyword">return</span>(cp);</span><br><span class="line">cp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>外层循环遍历 str1 字符串，内层循环在每个可能的起始位置上对 str2 进行逐个字符比对</p></blockquote><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h2><p>strtok 是用于字符串分割的函数，需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ceface0b5970479ea2f909dade9adec3.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strtok/?kw=strtok">strtok-C++参考</a></p></blockquote><p><strong>参数</strong>：str-是要进行分割操作的字符串，可以是字符数组形式存在的字符串，delimiters-是用于指定分割字符的字符串，即按照 delim 中包含的字符来对 str 进行分割</p><p><strong>返回值</strong>：返回一个指向被分割出的下一个子字符串的指针或空指针</p><p><strong>值得注意的是</strong>：sep 参数指向一个字符串，定义了用作分隔符的字符集合，第⼀个参数指定⼀个字符串，它包含了 0 个或者多个由 sep 字符串中⼀个或者多个分隔符分割的标记 strtok 函数找到 str 中的下⼀个标记，并将其用  \0 结尾，返回⼀个指向这个标记的指针。（注：strtok函数会改变被操作的字符串，所以被strtok函数切分的字符串⼀般都是临时拷贝的内容并且可修改），strtok函数的第一个参数不为 NULL ，函数将找到str中第一个标记，strtok 函数将保存它在字符串中的位置，strtok 函数的第一个参数为 NULL ，函数将在同一个字符串中被保存的位置开始，查找下一个标记，如果字符串中不存在更多的标记，则返回 NULL 指针</p><p><strong>这个函数有点难理解，举个例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;192.168.6.111&quot;</span>;</span><br><span class="line"><span class="type">char</span>* sep = <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="type">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (str = strtok(arr, sep); str != <span class="literal">NULL</span>; str = strtok(<span class="literal">NULL</span>, sep))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段 C 语言代码的主要目的是使用strtok函数对一个表示 IP 地址的字符串进行分割，并逐个输出分割后的子字符串，也就是将 IP 地址中的每个数字部分单独提取并打印出来</p></blockquote><h2 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h2><p>strerror 用于将一个错误码（由 errno 表示）转换为对应的、人类可读的错误描述字符串<br>需要包含头文件 &#x3D;&#x3D;#include &lt;string.h&gt;&#x3D;&#x3D;</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/875e869f0fbb4ceca990d220e8c45812.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strerror/?kw=strerror">strerror-C++参考</a></p></blockquote><p><strong>参数</strong>：errnum-错误码</p><blockquote><p>在不同的系统和C语言标准库的实现中都规定了一些错误码，一般是放在 errno.h 这个头文件中说明的，C语言程序启动的时候就会使用一个全局的变量 errno 来记录程序的当前错误码，只不过程序启动的时候 errno 是0，表示没有错误，当我们在使用标准库中的函数的时候发生了某种错误，就会将对应的错误码，存放在 errno 中，而⼀个错误码的数字是整数很难理解是什么意思，所以每一个错误码都是有对应的错误信息的，strerror 函数就可以将错误对应的错误信息字符串的地址返回</p></blockquote><p><strong>返回值</strong>：向描述 errnum 的错误字符串的指针</p><p>比如我们打印⼀下0~10这些错误码对应的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dc4291ab8e4a4c6cbe614df13a92ca50.png" alt="在这里插入图片描述"><br>可以看到每个数字都有对应的错误信息</p><p><strong>和 strerror 相像的是 perror</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;Error opening file unexist.ent: %s\n&quot;</span>, strerror(errno))</span><br><span class="line">perror(<span class="string">&quot;Error opening file unexist.ent&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这两段代码是等价的，perror函数打印完参数部分的字符串后，再打印一个冒号和一个空格，再打印错误信息</p></blockquote><p>本篇到这就结束了，涉及的函数很多，及时理解总结才能更好的掌握本篇的知识哦😋</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/849236c66dd6499792b05c75fe1f7772.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.16——万字详解指针概念及技巧</title>
      <link href="/2024/11/08/C%E8%AF%AD%E8%A8%80/vlog16/"/>
      <url>/2024/11/08/C%E8%AF%AD%E8%A8%80/vlog16/</url>
      
        <content type="html"><![CDATA[<h1 id="sizeof-和-strlen"><a href="#sizeof-和-strlen" class="headerlink" title="sizeof 和 strlen"></a>sizeof 和 strlen</h1><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>在初学C语言时就提到过 sizeof 的概念，这也是个常用的关键字，想必已经大家已经烂熟于心<br>回顾提示：<strong>sizeof（类型）、sizeof 表达式</strong></p><blockquote><ol><li>sizeof 是操作符</li><li>sizeof 计算操作数所占内存的大小，单位是字节</li><li>不关注内存中存放什么数据</li></ol></blockquote><p>这里不做过多赘述，忘记的可以去看我往期的文章回顾:</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142828273?spm=1001.2014.3001.5502">关于我、重生到500年前凭借C语言改变世界科技vlog.2——C语言数据类型和变量</a></p></blockquote><h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h2><p>前面在举指针的例子的时候，提到过 strlen ，是用来计算字符串长度的<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/79867d2c7b444adab18dd9be2bdde503.png" alt="在这里插入图片描述"></p><blockquote><p>传送门：<a href="https://legacy.cplusplus.com/reference/cstring/strlen/?kw=strlen">strlen-C++参考</a></p></blockquote><p>头文件为 #include &lt;string.h&gt; , strlen 是专门用于计算字符串长度的，strlen 从 str 这个参数的地址开始向后，统计 \0 之前的字符串个数，只要没遇到 \0 就不会停止，直到找到为止，所以可能存在越界查找的情况</p><p>通过一个例子就能明白：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> arr1[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"> <span class="type">char</span> arr2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr1));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr2));</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr1));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr2));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后可以发现结果为 35，3，3，4<br>字符没有 \0 ，所以 strlen 找不到停止的标志，就会产生一个随机值</p><p>可以总结出以下几点：</p><blockquote><ol><li>strlen是库函数，使用需要包含头文件 string.h</li><li>srtlen是求字符串长度的，统计的是 \0 之前字符的个数</li><li>关注内存中是否有 \0 ，如果没有 \0 ，就会持续往后找，可能会越界</li></ol></blockquote><h1 id="数组和指针结合的试题深入解析"><a href="#数组和指针结合的试题深入解析" class="headerlink" title="数组和指针结合的试题深入解析"></a>数组和指针结合的试题深入解析</h1><p>以下代码均在 x64 环境下运行，地址大小为 8 ，地址保持不变</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">1</span>]));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*&amp;a));</span><br><span class="line"><span class="number">8.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a+<span class="number">1</span>));</span><br><span class="line"><span class="number">9.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]));</span><br><span class="line"><span class="number">10.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>16 数组名放在sizeof内部表示整个数组 ，单位是字节</li><li>8 这里 a 是数组名，表示首元素地址，加 0 后不变</li><li>4 这里 a 是数组名，表示首元素地址，解引用后就是首元素，即 a[0]<br> 所以*a – *(a + 0) – a[0]</li><li>8 这里 a + 1 是第二个元素的地址</li><li>4 第二个元素类型为 int</li><li>8 这里取整个数组的地址</li><li>16 这里的 * 和 &amp; 抵消了，也就是 sizeof(a) ,访问整个数组</li><li>8 这里 &amp;a + 1 跳过整个数组取地址</li><li>8 取第一个元素的地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="number">1.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="number">2.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="number">4.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span>printf(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 数组名放在sizeof内部表示整个数组</li><li>8 这里 arr 是数组名，表示首元素地址，加 0 后不变</li><li>1 这里 arr 是数组名，表示首元素地址，解引用后就是首元素</li><li>1 表示第二个元素</li><li>8 这里取整个数组的地址</li><li>8 这里 &amp;a + 1 跳过整个数组取地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>随机值 没有 \0</li><li>随机值 没有 \0</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 访问第二个元素，即 ‘b’ &#x3D; 98 ，会把 98 当成地址去访问</li><li>随机值 arr数组的地址，没有 \0</li><li>随机值 跳过整个数组取地址，没有 \0 </li><li>随机值 取第二个元素的地址，没有 \0</li></ol></blockquote><h3 id="代码3"><a href="#代码3" class="headerlink" title="代码3"></a>代码3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>7 数组名放在sizeof内部表示整个数组</li><li>8 arr是首元素地址，加 0 后不变</li><li>1 访问首元素，即 a</li><li>1 访问第二个元素，即 b</li><li>8 这里是数组的地址，和首元素地址一样</li><li>8 跳过整个数组取地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码4"><a href="#代码4" class="headerlink" title="代码4"></a>代码4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*arr));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(arr[<span class="number">1</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;arr[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 arr是首元素地址，统计 \0 之前的字符长度</li><li>6 arr是首元素地址，统计 \0 之前的字符长度，加 0 后不变</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 访问第二个元素，即 ‘b’ &#x3D; 98 ，会把 98 当成地址去访问</li><li>6 &amp;arr是数组的地址，即首元素地址，统计 \0 之前的字符长度</li><li>随机值 跳过整个数组取地址，没有 \0 </li><li>5 取第二个元素的地址，统计 \0 之前的字符长度</li></ol></blockquote><h3 id="代码5"><a href="#代码5" class="headerlink" title="代码5"></a>代码5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p+<span class="number">1</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(*p));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>8 p 是指针变量，计算的是指针变量的大小</li><li>8 p+1是第二个元素地址</li><li>1 p 的大小是 char* ，所以 *p 只能访问一个字节</li><li>1 p[0] – *(p + 0) – *p ,访问一个字节</li><li>8 指针变量 p 的地址</li><li>8 跳过 p 变量取后面的地址</li><li>8 取第二个元素的地址</li></ol></blockquote><h3 id="代码6"><a href="#代码6" class="headerlink" title="代码6"></a>代码6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p+<span class="number">1</span>));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(p[<span class="number">0</span>]));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(&amp;p[<span class="number">0</span>]+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>6 p 是指针变量，存放字符串的地址，统计 \0 之前的字符长度</li><li>5 指向第二个元素的地址</li><li>程序崩溃 访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>程序崩溃 p[0] – *(p + 0) – *p，访问首元素，即 ‘a’ &#x3D; 97 ，会把 97 当成地址去访问</li><li>随机值 取指针变量 p 的地址，没有 \0</li><li>随机值 跳过 p 变量取后面的地址，没有 \0</li><li>5 取第二个元素的地址，统计 \0 之前的字符长度</li></ol></blockquote><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="number">1.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="number">2.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line"><span class="number">3.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line"><span class="number">4.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line"><span class="number">5.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(a[<span class="number">0</span>]+<span class="number">1</span>)));</span><br><span class="line"><span class="number">6.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a+<span class="number">1</span>));</span><br><span class="line"><span class="number">7.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(a+<span class="number">1</span>)));</span><br><span class="line"><span class="number">8.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;a[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line"><span class="number">9.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*(&amp;a[<span class="number">0</span>]+<span class="number">1</span>)));</span><br><span class="line"><span class="number">10.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(*a));</span><br><span class="line"><span class="number">11.</span><span class="built_in">printf</span>(<span class="string">&quot;%zd\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">3</span>]));</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><ol><li>48 数组名放在sizeof内部表示整个数组</li><li>4 第一行第一个元素</li><li>16 第一行数组名，计算第一行大小</li><li>8 a[0]+1则是将这个指针向后移动一个元素的位置<br>所以 a[0] + 1 – &amp;a[0][0] + 1 – &amp;a[0][1]  </li><li>4 第一行第二个元素</li><li>8 第二行的地址</li><li>16 解引用第二行</li><li>8 第二行的地址</li><li>16 第二行解引用</li><li>16 第一行解引用</li><li>16 第四行</li></ol></blockquote><h1 id="指针运算的试题深入解析"><a href="#指针运算的试题深入解析" class="headerlink" title="指针运算的试题深入解析"></a>指针运算的试题深入解析</h1><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序的结果是什么？</span></span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出 2，5<br>1.首先，&amp;a 取的是整个数组a的地址，数组的地址和数组首元素的地址在数值上是相同的，但类型不同，数组首元素的地址类型是 int <em>，而数组的地址类型是 int (</em>)[5]（因为a是一个包含 5 个元素的数组）<br>2.然后，&amp;a + 1 表示将指针向后移动一个数组的大小，由于数组 a 包含 5 个 int 类型的元素，每个int类型元素占 4 个字节，那么整个数组a在内存中所占字节数为 5×4 &#x3D; 20字节，所以 &amp;a + 1 实际上是指向了数组 a 所占内存空间之后的下一个位置<br>3.最后，(int *)(&amp;a + 1) 将这个指向数组a之后位置的指针强制转换为 int * 类型的指针，也就是将其看作是指向一个int类型元素的指针，赋值给了ptr</p></blockquote><p><em><em>对于 <em>(a + 1)：</em></em><br>数组名a在大多数情况下会被隐式转换为指向数组首元素的指针，所以 a + 1 就是将指向首元素的指针向后移动一个元素的位置，</em>(a + 1) 则是获取这个移动后指针所指向的元素，也就是数组a的第二个元素，其值为 2</p><p><em><em>对于 <em>(ptr - 1)：</em></em><br>ptr 是指向数组a所占内存空间之后的下一个位置，那么 ptr - 1 就是将这个指针向前移动一个元素的位置，</em>(ptr - 1) 就是获取这个移动后指针所指向的元素，也就是数组a的最后一个元素，其值为 5</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在X86环境下</span></span><br><span class="line"><span class="comment">//假设结构体的⼤⼩是20个字节</span></span><br><span class="line"><span class="comment">//程序输出的结果是啥？</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> Num;</span><br><span class="line"> <span class="type">char</span> *pcName;</span><br><span class="line"> <span class="type">short</span> sDate;</span><br><span class="line"> <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line"> <span class="type">short</span> sBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p = (<span class="keyword">struct</span> Test*)<span class="number">0x100000</span>;</span><br><span class="line"><span class="comment">//定义了一个指向 Test 结构体的指针 p，并将其初始化为内存地址 0x100000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>*)p + <span class="number">0x1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：0x100014，0x100001，0x100004</p></blockquote><p><strong>第一次输出：</strong><br>将各成员所占字节数相加：4 + 4 + 2 + 2 + 8 &#x3D; 20 字节<br>所以当 p + 0x1 时，指针会按照结构体大小移动，即从初始地址 0x100000 移动到 0x100000 + 20×1 &#x3D; 0x100014，这里输出的结果应该是 0x100014</p><p><strong>第二次输出：</strong><br>这里将结构体指针 p 强制转换为 unsigned long 类型，然后进行加法运算，当把指针转换无符号长整型后，就不再按照结构体的大小进行指针移动的运算了，而是单纯的数值加法，因为 p 被初始化为 0x100000，将其视为无符号长整型并加上 0x1，得到的结果就0x100001，这里输出的结果应该是 0x100001</p><p><strong>第三次输出：</strong><br>这里将结构体指针 p 强制转换为 unsigned int* 类型的指针，然后进行加法运算，当 unsigned int* 类型的指针进行算术运算时，指针移动的步长是根据 unsigned int 类型的大小来确定的，在一般情况下，unsigned int 类型占 4 个字节，所以当 (unsigned int*)p + 0x1 时，指针会从初始地址 0x100000 移动到 0x100000 + 4×1 &#x3D; 0x100004，这里输出的结果应该是 0x100004</p><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line"> <span class="type">int</span> *p;</span><br><span class="line"> p = a[<span class="number">0</span>];</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：1<br>a[0] 可以看作是指向二维数组 a 第一行，这里将 a[0] 赋值给指针 p，此时 p 就指向了数组 a 的第一行的第一个元素，也就是值为 1 的那个元素</p></blockquote><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设环境是x86环境，程序输出的结果是啥？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"> <span class="type">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line"> p = a;</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：0xFFFFFFFC,-4</p></blockquote><p> int(*p)[4], p &#x3D; a 的图示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d176ba6ea41849cdbfc2a913bdcf8c49.png" alt="请添加图片描述"></p><blockquote><p>p[4][2] &#x3D; <em>(</em>(p+4)+2)<br>所以地址减地址得到的是元素个数，又因为这里打印地址，所以以补码的形式打印</p></blockquote><h2 id="题5"><a href="#题5" class="headerlink" title="题5"></a>题5</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"> <span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line"> <span class="type">int</span> *ptr2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line"> <span class="built_in">printf</span>( <span class="string">&quot;%d,%d&quot;</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：10，5</p></blockquote><p>int *ptr1 &#x3D; (int *)(&amp;aa + 1)， int *ptr2 &#x3D; (int <em>)(</em>(aa + 1)) 如图所示</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/74eedf2ea94c4a32ae8a65fd2f812754.png" alt="请添加图片描述"></p><blockquote><ol><li>首先，&amp;aa 取整个二维数组 aa 的地址加一</li><li>然后，aa + 1 指向了二维数组 aa 的第二行，*(aa + 1) 就是获取这个指针所指向的内容，也就是二维数组 aa 的第二行</li></ol></blockquote><p><em><em>对于 <em>(ptr1 - 1)：</em></em><br>ptr1 是指向数组 aa 所占内存空间之后的下一个位置，那么 ptr1 - 1 就是将这个指针向左移动一个元素的位置，</em>(ptr1 - 1) 就是获取这个移动后指针所指向的元素，也就是数组 aa 的最后一个元素，其值为 10</p><p><em><em>对于 <em>(ptr2 - 1)：</em></em><br>ptr2 是指向二维数组 aa 的第二行，那么 ptr2 - 1 就是将这个指针向左移动一个元素的位置，</em>(ptr2 - 1) 就是获取这个移动后指针所指向的元素，也就是二维数组 aa 的第一行的第五个元素，其值为 5</p><h2 id="题6"><a href="#题6" class="headerlink" title="题6"></a>题6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *a[] = &#123;<span class="string">&quot;work&quot;</span>,<span class="string">&quot;at&quot;</span>,<span class="string">&quot;alibaba&quot;</span>&#125;;</span><br><span class="line"> <span class="type">char</span>**pa = a;</span><br><span class="line"> pa++;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：at</p></blockquote><p>char *a[ ] &#x3D; {“work”,”at”,”alibaba”}， char**pa &#x3D; a 如图所示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/45389f0d30c14161b87b6b992f511fd4.png" alt="请添加图片描述"></p><blockquote><p>a 数组里分别存放三个字符串的地址，然后将该数组的地址存放到二级指针里，即第一个字符串的地址，pa++ 指向第二个字符串，然后解引用得到 at 的地址，但是这里使用 %s 占位符，所以当把 *pa 作为 %s 的参数传递给 printf 函数时，printf 函数会按照字符串的格式来处理它，即从这个指针所指向的位置开始，依次输出字符，直到遇到空字符（\0）为止，这样就输出了完整的字符串 “at”，而不是它的地址</p></blockquote><h2 id="题7"><a href="#题7" class="headerlink" title="题7"></a>题7</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *c[] = &#123;<span class="string">&quot;ENTER&quot;</span>,<span class="string">&quot;NEW&quot;</span>,<span class="string">&quot;POINT&quot;</span>,<span class="string">&quot;FIRST&quot;</span>&#125;;</span><br><span class="line"> <span class="type">char</span>**cp[] = &#123;c+<span class="number">3</span>,c+<span class="number">2</span>,c+<span class="number">1</span>,c&#125;;</span><br><span class="line"> <span class="type">char</span>***cpp = cp;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><blockquote><p>输出：POINT，EW，ST，NT</p></blockquote><p> 如图所示<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e8fd3cc212fa417299f2d7c81a29e83b.png" alt="请添加图片描述"></p><p><strong>第一次输出：</strong></p><ol><li>首先，++cpp 会使 cpp 指针自增，它现在指向 cp 数组中的第二个元素（也就是原来 cp[1] 的地址）。</li><li>然后，*cpp 会取出 cpp 所指向的元素，即 cp[1]，它是指向 c + 2 的指针（也就是指向字符串 “POINT” 的指针）。</li><li>最后，**cpp 再次间接访问，得到的就是字符串 “POINT”，所以这个 printf 语句会输出 “POINT”</li></ol><p><strong>第二次输出：</strong></p><ol><li>先看 ++cpp，这会使 cpp 再次自增，现在它指向 cp 数组中的第三个元素（原来 cp[2] 的地址）</li><li>然后 *++cpp 取出 cpp 所指向的元素，即 cp[2]，它是指向 c + 1 的指针（指向字符串 “NEW” 的指针）</li><li>接着 –*++cpp 会对 cp[2] 所指向的指针（也就是指向字符串 “NEW” 的指针）进行自减操作，此时它指向了字符串 “NEW” 中的倒数第二个字符（假设字符串以 \0 结尾，那么就是指向 ‘W’ 的指针）</li><li>最后 <em>–</em>++cpp + 3 会先取出这个新指向的字符（’W’），然后再往后偏移 3 个字符，此时就指向了字符串 “NEW” 中的倒数第一个字符（’W’ 往后 3 个字符，也就是 ‘W’ 本身，因为字符串 “NEW” 较短），所以这个 printf 语句会输出 “EW”</li></ol><p><strong>第三次输出：</strong></p><ol><li>cpp[-2] 相当于 *(cpp - 2)，因为前面 cpp 经过两次自增，现在要往回找两个位置，所以 cpp[-2] 指向的是原来 cp[0] 的地址</li><li>*cpp[-2] 取出 cpp[-2] 所指向的元素，即 cp[0]，它是指向 c + 3 的指针（指向字符串 “FIRST” 的指针）</li><li>*cpp[-2] + 3 会在指向字符串 “FIRST” 的指针基础上往后偏移 3 个字符，所以会指向字符串 “FIRST” 中的第 4 个字符，因此这个 printf 语句会输出 “ST”</li></ol><p><strong>第四次输出：</strong></p><ol><li>cpp[-1] 相当于 *(cpp - 1)，因为前面 cpp 经过两次自增，现在往回找一个位置，所以 cpp[-1] 指向的是原来 cp[1] 的地址</li><li>cpp[-1][-1] 相当于 <em>(</em>(cpp - 1) - 1)，也就是先找到 cp[1]（指向 c + 2 的指针，指向字符串 “POINT” 的指针），然后再对这个指针进行自减操作，此时它指向了字符串 “POINT” 中的倒数第二个字符</li><li>cpp[-1][-1] + 1 会在指向 ‘N’ 的指针基础上往后偏移 1 个字符，所以会指向字符串 “POINT” 中的倒数第一个字符（’N’ 往后 1 个字符，也就是 ‘T’ 的指针），因此这个 printf 语句会输出 “NT”</li></ol><blockquote><p>今天的博客属实不易，有些题博主也想了很久才理解，也尽量用最简易易懂的方式给大家讲解每一道题，希望看完这篇 vlog ，以后不再害怕指针类型的题目，冬天到了，祝大家立冬快乐！</p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c0688a7b3efc46d5956d24ab490ce77d.jpeg" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.14——常见C语言算法</title>
      <link href="/2024/11/04/C%E8%AF%AD%E8%A8%80/vlog14/"/>
      <url>/2024/11/04/C%E8%AF%AD%E8%A8%80/vlog14/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地走访要排序的数列，一次比较两个数据元素，如果顺序不对则进行交换，并一直重复这样的走访操作，直到没有要交换的数据元素为止</p></blockquote><p>核心思想：&#x3D;&#x3D;两两元素进行比较交换&#x3D;&#x3D;</p><blockquote><p>基本原理<br>1.比较相邻的元素，如果第一个比第二个大（假设是按照升序排序，若为降序则相反），就交换它们两个<br>2.对每一对相邻元素作同样的操作，从开始第一对到结尾的最后一对，这样在经过第一轮比较后，最大的元素就会 “浮” 到数列的末尾<br>3.针对所有的元素重复以上的步骤，除了最后已经排好序的元素（因为每一轮都会把当前未排序部分的最大元素移到最后，所以每轮结束后末尾的元素数量会增加，这些元素就不需要再参与后续排序了）<br>4.持续重复上述过程，直到整个数列都按照要求的顺序排列好</p></blockquote><p>理论知识介绍完，举个例子或许你就完全明白了<br>假设我们有一个数组 [5, 4, 3, 2, 1] 要进行升序排序：</p><blockquote><p><strong>第一轮排序</strong><br>1.比较第 1 个元素 5 和第 2 个元素 4，因为 5 &gt; 4，所以交换它们，数组变为 [4, 5, 3, 2, 1]<br>2.接着比较第 2 个元素 5 和第 3 个元素 3，因为 5 &gt; 3，交换后数组变为 [4, 3, 5, 2, 1]<br>3.再比较第 3 个元素 5 和第 4 个元素 2，交换得到 [4, 3, 2, 5, 1]<br>4.最后比较第 4 个元素 5 和第 5 个元素 1，交换后数组变为 [4, 3, 2, 1, 5]。此时第一轮排序结束，最大的元素 5 已经 “浮” 到了数组的末尾</p></blockquote><blockquote><p><strong>第二轮排序</strong><br>1.对除了最后一个元素 5 之外的数组部分 [4, 3, 2, 1] 进行同样操作<br>2.先比较第 1 个元素 4 和第 2 个元素 3，交换得 [3, 4, 2, 1]<br>3.再比较第 4 个元素 4 和第 3 个元素 2，交换得 [3, 2, 4, 1]<br>4.最后比较第 3 个元素 4 和第 4 个元素 1，交换得 [3, 2, 1, 4]。第二轮排序结束，此时未排序部分的最大元素 4 也 “浮” 到了合适位置</p></blockquote><p><strong>……以此类推</strong></p><p>可以发现每次都将最大的那个数送到最右边，假设有 n 个数，那么<strong>需要运送的趟数就为 (n-1)</strong><br>每一轮，每两个数都要进行比较，已经被运送到最右边的就不需要比较<br>那么<strong>需要比较 (n-1-已经运送到右边的数的个数)</strong></p><p>所以交换的函数可以这么写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span><span class="comment">//参数接收数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz<span class="number">-1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;sz-i<span class="number">-1</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                     <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                     arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                     arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">       bubble_sort(arr, sz);</span><br><span class="line">       <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明一下<strong>时间复杂度</strong>的概念，这里只需要理解概念即可，如何计算到了C数据结构会讲解</p><blockquote><ol><li>时间复杂度是用来衡量算法运行时间随着输入规模增长而增长的趋势的一个重要指标 </li><li>时间复杂度通常用大 O 表示法来表示,大 O 表示法描述的是算法在最坏情况下的时间复杂度，也就是当输入对算法运行造成最大困难时的运行时间增长趋势</li></ol></blockquote><p>对于该冒泡排序<br><strong>最坏情况</strong>：当输入的数组是完全逆序时，第一轮需要比较 n-1 次，第二轮需要比较 n-2 次，以此类推，总共需要比较的次数为 (n-1)+(n-2)+…+1，这个和等于 n (n-1)&#x2F;2，所以需要进行 &#x3D;&#x3D;n(n-1)&#x2F;2&#x3D;&#x3D; 次比较和交换操作，所以时间复杂度为 &#x3D;&#x3D;O(n^2)&#x3D;&#x3D;，其中 n 是数组的元素个数</p><p><strong>最好情况</strong>：当输入的数组已经是有序的，只需要进行一轮比较（每个元素都和它相邻的元素比较一次），此时时间复杂度为 &#x3D;&#x3D;O(n)&#x3D;&#x3D;</p><p>假设有多个序列需要排列，所以为了提高效率，对最好情况进行快速排序，对代码可进行如下优化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span><span class="comment">//参数接收数组元素个数</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz<span class="number">-1</span>; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//假设这⼀趟已经有序了</span></span><br><span class="line">           <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;sz-i<span class="number">-1</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                     flag = <span class="number">0</span>;<span class="comment">//发⽣交换就说明，⽆序</span></span><br><span class="line">                     <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                     arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                     arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(falg == <span class="number">1</span>)<span class="comment">//这⼀趟没交换就说明已经有序，后续⽆序排序了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">       <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">       bubble_sort(arr, sz);</span><br><span class="line">       <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序虽然简单易懂，但由于其时间复杂度较高，在处理大规模数据排序时效率相对较低，通常会被更高效的排序算法如快速排序、归并排序等所替代,但在一些数据量较小且对排序效率要求不是特别高的场景下，仍然可以使用冒泡排序</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote><p>二分查找（Binary Search），也叫折半查找，是一种用于在有序数组（或其他有序数据结构）中快速查找特定元素的高效查找算法</p></blockquote><p>核心思想：&#x3D;&#x3D;不断对半查找&#x3D;&#x3D;</p><blockquote><p>基本原理<br>1.每次查找时都将待查找的区间分成两部分<br>2.然后根据要查找元素与中间元素的比较结果，确定下一次查找应该在左半部分还是右半部分继续进行<br>3.如此反复，直到找到目标元素或者确定目标元素不存在为止</p></blockquote><p>还是通过举例来说明，假设我们有一个有序数组 [1, 3, 5, 7, 9, 11, 13, 15]，&#x3D;&#x3D;要查找元素 7&#x3D;&#x3D;</p><blockquote><p><strong>首先</strong>，确定整个数组为待查找区间，计算中间元素的索引，对于长度为 n 的数组，中间元素索引 mid 计算公式为：mid &#x3D; (left + right) &#x2F; 2（这里 left 表示区间的左端点，right 表示区间的右端点，在初始时 left &#x3D; 0，right &#x3D; n - 1）。在这个例子中，n &#x3D; 8，所以 mid &#x3D; (0 + 7) &#x2F; 2 &#x3D; 3，中间元素就是 7</p></blockquote><blockquote><p><strong>然后</strong>，将目标元素 7 与中间元素 7 进行比较，发现它们相等，这就找到了目标元素，查找过程结束</p></blockquote><p>再假设要&#x3D;&#x3D;查找元素 4&#x3D;&#x3D;</p><blockquote><ol><li>同样先确定整个数组为待查找区间，计算中间元素索引 mid &#x3D; (0 + 7) &#x2F; 2 &#x3D; 3，中间元素是 7</li><li>将目标元素 4 与中间元素 7 进行比较，因为 4 &lt; 7，所以目标元素如果存在，一定在左半部分。此时更新待查找区间为左半部分，即 left &#x3D; 0，right &#x3D; mid - 1 &#x3D; 2</li><li>再次计算新的中间元素索引 mid &#x3D; (0 + 2) &#x2F; 2 &#x3D; 1，新的中间元素是 3<br>将目标元素 4 与新的中间元素 3 进行比较，因为 4 &gt; 3，所以目标元素如果存在，一定在右半部分，更新待查找区间为右半部分，即 left &#x3D; mid + 1 &#x3D; 2，right &#x3D; 2</li><li>第三次计算中间元素索引 mid &#x3D; (2 + 2) &#x2F; 2 &#x3D; 2，中间元素是 5</li><li>将目标元素 4 与中间元素 5 进行比较，因为 4 &lt; 5，所以目标元素如果存在，一定在左半部分，更新待查找区间为左半部分，即 left &#x3D; 2，right &#x3D; mid - 1 &#x3D; 1，此时 left &gt; right，说明目标元素在这个有序数组中不存在，查找过程结束</li></ol></blockquote><p>可以发现每次折中查找，然后和目标元素比较，以此往复完成二分查找</p><p>对于二分查找<br>二分查找每次查找都会将搜索范围缩小一半，最多需要查找的次数为以 2 为底，n（数组元素个数）的对数次<br>即 &#x3D;&#x3D;log 2^n&#x3D;&#x3D; ，所以二分查找的时间复杂度为 &#x3D;&#x3D;O(log n)&#x3D;&#x3D;，这使得它在处理较大规模的有序数组时，查找速度比顺序查找（时间复杂度为 O(n)）快得多</p><blockquote><p>例如，当数组有 1024 个元素时，二分查找最多只需要查找 10 次（因为 ）就可以确定目标元素是否存在<br>如果是顺序查找就要找 1024 次，往往查找的数目还不止这么多，甚至更加庞大</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// 计算中间元素的索引</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) </span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> result = binary_search(arr, n, target);</span><br><span class="line">    <span class="keyword">if</span> (result!= <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中的索引为 %d\n&quot;</span>, target, result);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;目标元素 %d 在数组中不存在\n&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找是一种非常高效的查找算法，但它的前提是数组必须是有序的。如果数组未排序，则需要先对数组进行排序，再使用二分查找</p><h1 id="转移表"><a href="#转移表" class="headerlink" title="转移表"></a>转移表</h1><p>转移表是一种数据结构和编程技巧，用于实现根据不同的条件或输入值快速跳转到相应的代码段执行</p><blockquote><p>例如：写一个简单的计算器程序，它可以执行加、减、乘、除四种运算。你可以创建一个转移表，表中包含四个元素，分别对应四种运算的处理函数的指针，当用户输入一个运算符号后，程序可以根据这个符号在转移表中快速找到对应的处理函数并执行，而不需要使用一长串的 if-else 或 switch 语句来逐个判断运算符号并调用相应函数</p></blockquote><p>根据前面所学的 switch 结构和 加法函数，可以写出一个简易的四则运算计算器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> x, y;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    1:add          2:sub \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    3:mul          4:div \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    0:exit               \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">switch</span> (input)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = add(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = sub(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = mul(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;输⼊操作数：&quot;</span>);</span><br><span class="line">              <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">              ret = div(x, y);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;退出程序\n&quot;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;选择错误\n&quot;</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种写法过于重复啰嗦，可以运用<strong>函数数组指针</strong>来简化代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> x, y;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span>(*p[<span class="number">5</span>])(<span class="type">int</span> x, <span class="type">int</span> y) = &#123;<span class="number">0</span>, add, sub, mul, div &#125;;<span class="comment">//转移表</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    1:add          2:sub \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    3:mul          4:div \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;    0:exit               \n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;请选择：&quot;</span>);</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">         <span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))</span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;输⼊操作数：&quot;</span> );</span><br><span class="line">               <span class="built_in">scanf</span>( <span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">               ret = (*p[input])(x, y);</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;退出计算器\n&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">               <span class="built_in">printf</span>( <span class="string">&quot;输⼊有误\n&quot;</span> ); </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">while</span> (input);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就通过函数指针数组实现了根据不同的索引值灵活调用不同函数的功能，这在很多需要根据条件或情况动态选择执行不同函数的场景中非常有用</p><p>如果还有不懂可以私信博主或回顾往期 vlog 查缺补漏</p><blockquote><p>主页传送门：<a href="https://blog.csdn.net/Zero_VPN?type=lately">DARLING Zero two♡ 的 blog</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ed29ea1478f3b975f82f1fb539e7a3f.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.13——深入理解指针(3)</title>
      <link href="/2024/11/01/C%E8%AF%AD%E8%A8%80/vlog13/"/>
      <url>/2024/11/01/C%E8%AF%AD%E8%A8%80/vlog13/</url>
      
        <content type="html"><![CDATA[<h1 id="字符指针变量"><a href="#字符指针变量" class="headerlink" title="字符指针变量"></a>字符指针变量</h1><p>字符指针变量，顾名思义就是字符类型的指针，即 char*<br>常见的输出格式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> ch = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line"> <span class="type">char</span> *pc = &amp;ch;</span><br><span class="line"> *pc = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是存放一个字符的情况，如果存放字符串呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* pstr = <span class="string">&quot;hello bit.&quot;</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pstr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看是存放字符串在指针变量中，但我们要记住指针变量是用来存放地址的<br>所以这里本质是把字符串 hello bit. 首字符的地址放到了pstr中，即字符 h 的地址</p><h1 id="数组指针变量"><a href="#数组指针变量" class="headerlink" title="数组指针变量"></a>数组指针变量</h1><p>上一篇 vlog 学到了指针数组，就是存放指针的数组，也可以理解为存放指针的集合(元素相同)，那么数组指针就可以得出是存放数组地址的指针，是一种指针变量，指向数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>那么以上哪种是数组指针？<br>答案是下面那个<br>分析：&#x3D;&#x3D;[ ] 的优先级大于 * ，所以必须加上 （）来保证 p 和 * 优先结合&#x3D;&#x3D;</p><p>p先和 * 结合，说明p是一个指针变量，然后指针指向的是一个大小为10个整型的数组<br>所以 p 是一个指针，指向一个数组，叫&#x3D;&#x3D;数组指针&#x3D;&#x3D;</p><p>int 表示 p指向的数组的元素类型， p 是数组指针变量名，10是指向数组的元素个数</p><h1 id="函数指针变量"><a href="#函数指针变量" class="headerlink" title="函数指针变量"></a>函数指针变量</h1><p>根据前面学过的类比，不难发现，函数指针变量应该是用来存放函数地址的，通过地址能够调用函数的<br>那么函数真的有地址吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;test: %p\n&quot;</span>, test);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;test: %p\n&quot;</span>, &amp;test);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以发现函数确实有地址，&#x3D;&#x3D;用函数名就能代表其地址&#x3D;&#x3D;，当然也可以通过 &amp;函数名 的方<br>式获得函数的地址，为了方便一般就不写取地址符<br>其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*pf3)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line"><span class="type">int</span>(*pf3)(<span class="type">int</span> x, <span class="type">int</span> y) = &amp;Add;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;函数参数的变量名可写可不写&#x3D;&#x3D;，取地址符也是<br>int 是指向函数的返回类型，pf3 是函数指针变量名，int x，int y 是 pf3 指向函数的参数类型和个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>(*pf3)(<span class="type">int</span>, <span class="type">int</span>) = Add;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pf3)(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pf3(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将通过函数指针调用指针指向的函数写一个我们之前写过的加法函数</p><blockquote><p>这里通过解引用函数指针 pf3 的方式来调用它所指向的函数（也就是 Add 函数），传入参数 2 和 3，然后将返回的结果使用 printf<br>函数输出。实际上，在这种情况下，解引用操作符 * 在这里是可选的，因为在 C<br>语言中，函数名本身在求值时就会转换为指向该函数的指针，所以也可以直接写成 pf3(2, 3)</p></blockquote><h1 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h1><p>在学习了指针数组的基础上，我们引入函数指针放入数组<br>那么以下哪种为正确的形式？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*parr1[<span class="number">3</span>])();</span><br><span class="line"><span class="type">int</span> *parr2[<span class="number">3</span>]();</span><br><span class="line"><span class="type">int</span> (*)() parr3[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>答案是第一个</p><blockquote><p>定义形式如下：返回值类型 (*数组名[数组大小])(参数列表)</p></blockquote><p>parr1 先和 [ ] 结合，说明 parr1是数组，是 int (*)() 类型的函数指针<br>那么参数如何理解？其实就是每个元素代表的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func_array[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;add, subtract&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，func_array 数组的两个元素分别被初始化为 add 函数和 subtract 函数的指针</p><h1 id="二维数组传参本质"><a href="#二维数组传参本质" class="headerlink" title="二维数组传参本质"></a>二维数组传参本质</h1><p>讲数组的时候说过二维数组其实可以看做是每个元素是一维数组的数组，也就是二维数组的每个元素是一个一维数组，那么二维数组的首元素就是第一行，是个一维数组<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5fe059216cb9645764968a491d4b117.png" alt="在这里插入图片描述"><br>第一行的一维数组的类型就是 int [5] ，所以第一行的地址的类型就是数组指针类型 int(*)[5] ，那就意味着二维数组传参本质上也是传递了地址，传递的是第一行这个一维数组的地址，那么形参也是可以写成指针形式的，&#x3D;&#x3D;总的来说就是把二维数组当一维数组理解，第一行看成一维数组的第一个元素，首元素就是第一行一整行的地址&#x3D;&#x3D;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> r, <span class="type">int</span> c)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;r; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;c; j++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(p+i)+j));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"> test(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的遍历数组传参也可以这样写</p><blockquote><p>这里的 *(p+i) 相当于获取二维数组的第 i 行的首地址（因为 p 是指向包含 5 个整数的数组的指针，p+i 就指向了第 i 行），然后 *(p+i)+j 就是指向第 i 行第 j 列元素的指针，最后 <em>(</em>(p+i)+j) 就是获取该位置的元素值并输出</p></blockquote><p>虽然解引用通常是获取元素本身，但在指向二维数组行的指针这种特殊情况下，&#x3D;&#x3D;由于指针所指向的对象本身就是一个数组，解引用得到的就是这个数组的首地址&#x3D;&#x3D;，这是由 C 语言的指针和数组特性共同决定的</p><blockquote><p>二维数组传参，形参的部分可以写成数组，也可以写成指针形式</p></blockquote><h1 id="拓展补充"><a href="#拓展补充" class="headerlink" title="拓展补充"></a>拓展补充</h1><p>补充一个关键字 typedef ，是用来类型重命名的，可以将复杂的类型，简单化</p><p><strong>普通类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> uint;</span><br><span class="line"><span class="comment">//将unsigned int 重命名为uint</span></span><br></pre></td></tr></table></figure><p><strong>普通指针类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* ptr;</span><br></pre></td></tr></table></figure><p><strong>数组函数指针类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span><span class="params">(*parr)</span>[5]; <span class="comment">//新的类型名必须在*的右边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*pfun)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//新的类型名必须在*的右边</span></span><br></pre></td></tr></table></figure><p>下一期 vlog 将对二分查找，转移表，冒泡排序等常见算法题目进行练习解析<br>建议对前面的知识都有系统性的理解后再来写题</p><blockquote><p>主页传送门：<a href="https://blog.csdn.net/Zero_VPN?type=blog">DARLING Zero two♡ 的 blog</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/59b74dc7fa200c95b948b4b9094715c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.12——深入理解指针(2)</title>
      <link href="/2024/10/30/C%E8%AF%AD%E8%A8%80/vlog12/"/>
      <url>/2024/10/30/C%E8%AF%AD%E8%A8%80/vlog12/</url>
      
        <content type="html"><![CDATA[<h1 id="数组名与地址"><a href="#数组名与地址" class="headerlink" title="数组名与地址"></a>数组名与地址</h1><p>有这么一个数组，数组名为 arr </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="type">int</span> *p = &amp;arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>在这里 &amp;arr[0] 指的是首元素地址，其实本质上数组名就代表的是数组首元素地址<br>接下来我们将对以下几个名字进行区分</p><blockquote><p>1.arr<br>2.sizeof(arr)<br>3.&amp;arr</p></blockquote><h2 id="arr"><a href="#arr" class="headerlink" title="arr"></a>arr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;arr = %p\n&quot;</span>, arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上保留取地址符&amp;和只用数组名，打印对应的地址可以发现<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/98a8ebf2eab0205fff01de1b924f3cd.png" alt="在这里插入图片描述"><br>两个的地址都相同，这就说明了 &amp;arr[0] &#x3D; arr，即数组名就是首元素地址</p><h2 id="sizeof-arr"><a href="#sizeof-arr" class="headerlink" title="sizeof(arr)"></a>sizeof(arr)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键字 sizeof 计算 arr 的大小，你可能会觉得应该输出首元素的大小？<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/fc3bebaa5fc315b87c942214733234d.png" alt="在这里插入图片描述"><br>不，这里的 arr 不代表首元素大小，而是表示整个数组，计算整个数组的大小，单位是字节</p><h2 id="arr-1"><a href="#arr-1" class="headerlink" title="&amp;arr"></a>&amp;arr</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 &amp;arr 和 &amp;arr+1 地址，假设他是跳过一个字节的地址<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/191e061e0225b00fcc5b7003ad9b19b.png" alt="在这里插入图片描述"><br>很显然，根据代码结果，两段代码地址相差40，那么假设就是错的，所以 &amp;arr 表示的是整个数组的大小</p><p>总结：<strong>只有  &amp;arr 和 sizeof(arr) 有特殊含义，其他情况下的数组名都代表数组首元素地址</strong></p><h1 id="指针访问数组"><a href="#指针访问数组" class="headerlink" title="指针访问数组"></a>指针访问数组</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="type">int</span>* p = arr;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p+i);</span><br><span class="line"> <span class="comment">//scanf(&quot;%d&quot;, arr+i);//也可以这样写</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指针访问数组在一些环境下，会更接近本质，更加简洁易懂<br>将 *(p+i) 换成 p[i] 也是能够正常打印的<br>在这里解引用操作符和下标引用符产生的效果相同</p><p>本质上p[i] 是等价于 *(p+i)，数组元素的访问在编译器处理的时候，也是转换成首元素的地址+偏移<br>量求出元素的地址，然后解引用来访问的</p><h1 id="一维数组传参本质"><a href="#一维数组传参本质" class="headerlink" title="一维数组传参本质"></a>一维数组传参本质</h1><p>在前面学习的函数篇章中，数组可以传递给自定义函数，那么数组传递的本质是什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> sz2 = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sz2 = %d\n&quot;</span>, sz2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz1 = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;sz1 = %d\n&quot;</span>, sz1);</span><br><span class="line"> test(arr);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码调试后可以发现，sz1 &#x3D; 10，sz2 &#x3D; 1，同样的算法应该 sz1 &#x3D; sz2 &#x3D;10 ，但穿过去的形参根据结果 sizeof(arr) 只计算出一个元素的大小，前面我们提到 arr 表示首元素的地址，那么在数组传参的时候，传递的是数组名，也就是数组传参的时候传递的是首元素的地址</p><p>所以函数的形参应该用指针变量来接收一个地址，这也证实了<strong>数组传参的本质是传递首元素地址</strong><br><strong>形参部分既可以写成 int * arr 的指针形式，也可以写成 arr[ ] 的数组形式</strong></p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><p>什么是数组指针？什么是指针数组？这里我们重点介绍一下指针数组<br>指针数组是一个数组，比如整型数组存放的数组，字符数组存放的是字符，那么指针数组存放的就是指针</p><blockquote><p>int* arr[5] &#x3D; 5个int*</p></blockquote><p>每一个数组里的指针都指向一个地址                     </p><h1 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h1><p>正常的一个常见的指针是一级指针，那么在一个指针里面再嵌套一个指针就是二级指针<br>是变量就有地址，指针变量也不例外，比如把指针变量的地址需要存放在另一个指针变量里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> * pi = &amp;i;</span><br><span class="line">  <span class="type">int</span> ** pii = &amp;pi;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>*pii 通过对 pii 中的地址进行解引用，这样找到的是 pi ， *pii 其实访问的就是 pi<br>**pii 先通过 *pii 找到 pi ,然后对 pi 进行解引用操作： *pi ，那找到的是 i</p></blockquote><p>博主最近在准备蓝桥杯的校内比赛，更新可能会有所减缓，大家多多谅解！:)</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/32e5ef8b3198c777f6565b4d21b5e7c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.11——深入理解指针(1)</title>
      <link href="/2024/10/28/C%E8%AF%AD%E8%A8%80/vlog11/"/>
      <url>/2024/10/28/C%E8%AF%AD%E8%A8%80/vlog11/</url>
      
        <content type="html"><![CDATA[<h1 id="内存和地址"><a href="#内存和地址" class="headerlink" title="内存和地址"></a>内存和地址</h1><blockquote><p>内存是用于暂时存储 CPU（中央处理器）正在处理的数据以及与硬盘等外部存储设备交换的数据的硬件设备。它充当了 CPU 和其他设备之间数据传输的中转站，使得计算机各个部件能够高效协同工作</p></blockquote><p>我们在买电脑时，有 8GB&#x2F;16GB&#x2F;32GB等内存选择，读取数据和处理后的放回数据都是经过内存处理的，读取数据和放回数据也要找到相应的地址放回，电脑也像人一样，要进行高效的内存空间管理，所以电脑把<strong>每一个字节的空间作为一个内存单元</strong></p><p>每个内存单元，就好比一间间酒店房间，每个房间能住 8 个比特位，房间（内存单元）都有一个门牌编号(地址)，有了门牌号，就能快速找到相应的房间，即CPU能通过地址快速找到内存空间，在C语言中，<strong>给地址起了个名字叫指针</strong></p><blockquote><p>内存单元编号&#x3D;地址&#x3D;指针</p></blockquote><p>CPU访问内存中的某个字节空间，必须知道这个字节空间在内存的什么位置，而因为内存中字节很多，所以需要给内存进行编址，计算机中的编址，并不是把每个字节的地址记录下来，而是通过硬件设计完成的，在硬件层面上就设计好了</p><h1 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h1><blockquote><p>int a &#x3D; 5<br>int * p &#x3D; &amp;p</p></blockquote><p>这里的 int* 是变量 p 的类型，也就是一个整型指针，*就是说明 p 是一个指针变量，前面的 int 表示 p 指向的是整型类型的对象，p 中存放的是 a 的地址</p><p>注意指针变量是有大小的</p><blockquote><p>• 32位平台下地址是32个bit位，指针变量大小是4个字节<br>• 64位平台下地址是64个bit位，指针变量大小是8个字节<br>• 注意指针变量的大小和类型是无关的，只要指针类型的变量，在相同的平台下，大小都是相同的</p></blockquote><h1 id="指针操作符"><a href="#指针操作符" class="headerlink" title="指针操作符"></a>指针操作符</h1><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符 &amp;"></a>取地址操作符 &amp;</h2><p>通过取地址操作符取出的地址是一个数值，比如：0x004AAC78,取地址这一操作就是为了把地址取出放在指针变量中，方便后期使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> * pa = &amp;a;<span class="comment">//取出a的地址并存储到指针变量pa中</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="解引用操作符"><a href="#解引用操作符" class="headerlink" title="解引用操作符 *"></a>解引用操作符 *</h2><p>那么我们把地址存储在指针变量后要如何将存放在里面的东西取出使用呢？<br>在知道地址的前提下，可以通过解引用操作符找到指针指向的对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"> <span class="type">int</span>* pa = &amp;a;</span><br><span class="line"> *pa = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pa 通过解引用找到 a 并将他的值改成 0 ，就好像通过门牌号找到特定酒店房间里的特定物品，并将其替换了，但这是就会产生一个疑惑，为什么不直接通过对 a 进行赋值改变它的值，不一定非要用指针吧，确实在当前情况下使用指针略显麻烦，但是在程序代码更加复杂，或者是不同的操作情景下，指针是一种妙用，后续的实例将会逐步深入理解指针的必要性和实用性</p><h1 id="指针变量类型的意义"><a href="#指针变量类型的意义" class="headerlink" title="指针变量类型的意义"></a>指针变量类型的意义</h1><p>指针变量的大小与类型无关，只与操作平台有关，在同一平台下，大小都是一样的，那么指针类型的意义在哪儿呢？</p><h2 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0x11223344</span>;</span><br><span class="line"> <span class="type">int</span> *pi = &amp;n; </span><br><span class="line"> *pi = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试我们可以看到，代码会将n的4个字节全部改为0，如果把指针类型改成 char 呢？答案是代码只是将n的第⼀个字节改为0，这说明了指针类型决定了解引用的权限，也就是指针解引用的访问权限</p><h2 id="指针-整数"><a href="#指针-整数" class="headerlink" title="指针 + - 整数"></a>指针 + - 整数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"> <span class="type">char</span> *pc = (<span class="type">char</span>*)&amp;n;</span><br><span class="line"> <span class="type">int</span> *pi = &amp;n;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;n);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pc+<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>%p用来打印地址，我们可以通过调试查看地址变化</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/0f16c385fa1b7f808479b6a43521e23.png" alt="请添加图片描述"></p><p>由图显而易见，char* 类型的指针变量+1跳过1个字节， int* 类型的指针变量+1跳过了4个字节<br>所以指针类型决定了指针加减整数时一步走多大距离</p><h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h2><p>void* 指针是一种特殊的指针，他没有特定的类型，不像int<em>、char</em>那样指向特定的数据所在的内存地址，但也是有指向地址的，不过是对其指向的内容类型，或进行操作时的方式不明确，即void*指针不能进行解引用操作和加减整数操作<br>报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span>* pa = &amp;a;</span><br><span class="line"> <span class="type">char</span>* pc = &amp;a;</span><br><span class="line"> *pa = <span class="number">10</span>;</span><br><span class="line"> *pc = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：void*指针接收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> <span class="type">void</span>* pa = &amp;a;</span><br><span class="line"> <span class="type">void</span>* pc = &amp;a;</span><br><span class="line"> *pa = <span class="number">10</span>;</span><br><span class="line"> *pc = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调试可以发现 void<em>指针可以接收不同类型的地址，但无法运算，所以void</em>指针一般用于函数参数部分，用于接受不同类型数据的地址</p><h1 id="const-的修饰"><a href="#const-的修饰" class="headerlink" title="const 的修饰"></a>const 的修饰</h1><p>const是一个关键字，用于声明常量一旦一个变量被声明为const，它的值就不能被修改，<strong>const放在 * 的左边或右边有不同的意义</strong></p><blockquote><p>int * p     没有const修饰<br>int a &#x3D; 10<br>int   const<em>p &#x3D; &amp;a     const 放在 * 的左边做修饰<br>int</em> const p &#x3D; &amp;a      const 放在 * 的右边做修饰</p></blockquote><p><strong>const如果放在*的左边</strong>，修饰的是指针指向的内容<br>保证指针指向的内容不能通过指针来改变，但是指针变量本身的内容可变<br><strong>即 a&#x3D;10 这个值不能改变，变量 p 指向 a 可以改成指向别的变量</strong></p><p><strong>const如果放在*的右边</strong>，修饰的是指针变量本身，保证了指针变量的内容不能修改<br>但是指针指向的内容，可以通过指针改变<br><strong>即 a&#x3D;10 这个值能改变，变量 p 指向 a 不可以改成指向别的变量</strong></p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h1><h2 id="指针-整数-1"><a href="#指针-整数-1" class="headerlink" title="指针 +- 整数"></a>指针 +- 整数</h2><p>比如打印数组可以用指针打印，更加清晰有效</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));<span class="comment">//p+i 这⾥就是指针+整数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的分析在我“打印数组的多种方式”的一篇博客有提到</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142187329?spm=1001.2014.3001.5502">打印数组的多种方式</a></p></blockquote><h2 id="指针-指针"><a href="#指针-指针" class="headerlink" title="指针 - 指针"></a>指针 - 指针</h2><p>代替 strlen 函数(计算字符或字符串长度)，实现一个自定义的函数 my_strlen 来计算输入字符串的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> *p = s;</span><br><span class="line"> <span class="keyword">while</span>(*p != <span class="string">&#x27;\0&#x27;</span> )</span><br><span class="line"> p++;</span><br><span class="line"> <span class="keyword">return</span> p-s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, my_strlen(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在 main 函数中调用 my_strlen(“abc”) 时，传给 my_strlen 函数的是字符串 “abc” 的首字符的地址</p><p>在 C 语言中，字符串常量（如这里的 “abc”）在内存中是以字符数组的形式存储的，并且会在末尾自动添加一个字符串结束标志 ‘\0’ ,当把字符串常量作为参数传递给函数时，实际上传递的就是这个字符数组的首元素（也就是首字符）的地址</p><p>在 my_strlen 函数内部，通过这个接收到的地址（形参 s），就可以从字符串的开头开始逐个访问字符，直到遇到字符串结束标志 ‘\0’，从而实现对字符串长度的计算</p><h1 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h1><p>野指针是指程序中指向一块已释放内存或未初始化的内存区域的指针，指向的位置是随机的，不可知的<br>它可能指向任意的内存地址，这个随机地址就可能是系统正在使用的或者不允许访问的内存区域</p><h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><h3 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> *p;<span class="comment">//局部变量指针未初始化，默认为随机值</span></span><br><span class="line"> *p = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int * p 没有对应的地址存放，那他可能就会存放一个随机的地址</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> *p = &amp;arr[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=<span class="number">11</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//当指针指向的范围超出数组arr的范围时，p就是野指针</span></span><br><span class="line"> *(p++) = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当循环执行到 i &#x3D; 10 及之后时，指针 p 已经超出了数组 arr 的范围。数组 arr 在内存中是连续分配的一段空间，大小刚好能容纳 10 个整数。当 p 不断递增并超出这个范围后，它就指向了数组 arr 所占用内存空间之外的未知区域，此时 p 就变成了野指针</p><h3 id="指向的空间释放"><a href="#指向的空间释放" class="headerlink" title="指向的空间释放"></a>指向的空间释放</h3><p>这部分我们放在后续的动态内存部分讲解，目前知道这种情况会造成野指针形成即可</p><h2 id="如何规避"><a href="#如何规避" class="headerlink" title="如何规避"></a>如何规避</h2><blockquote><p>1.对指针变量都进行初始化操作<br>2.注意数组等变量的范围，小心指针越界<br>3.指针不使用时，及时置之为NULL空指针(定义用来表示指针不指向任何有效的内存地址，也就是指针为        空的情况,当一个指针被赋值为 NULL 时，意味着该指针当前没有指向任何有意义的对象或者内存区域)<br>4.不要返回局部变量的地址</p></blockquote><h1 id="assert-的断言"><a href="#assert-的断言" class="headerlink" title="assert 的断言"></a>assert 的断言</h1><p>assert.h 头文件定义了宏 assert() ，用于在运行时确保程序符合指定条件，如果不符合，就报<br>错终止运行，这个宏常常被称为“断言”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(p != <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>p 等于 NULL 程序终止运行，p 不等于 NULL 程序继续执行</p><blockquote><p>使用assert有好有坏<br>好处是它不仅能自动标识文件和出问题的行号，还有⼀种无需更改代码就能开启或关闭 assert() 的机制，如果已经确认程序没有问题，不需要再做断言，就在 #include &lt;assert.h&gt; 语句的前⾯，定义⼀个宏 NDEBUG<br>坏处是因为引入了额外的检查，增加了程序的运行时间</p></blockquote><p>这里拓展一下不同版本的发布环境</p><p><strong>Debug 称为调试版本</strong>，它包含调试信息，并且不作任何优化，便于程序员调试程序，程序员在写代码的时候，需要经常性的调试代码，就将这里设置为 Debug ，这样编译产生的是 Debug 版本的可执行序，其中包含调试信息，是可以直接调试的</p><p><strong>Release 称为发布版本</strong>，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用，当程序员写完代码，测试再对程序进行测试，直到程序的质量符合交付给用户使用标准，这个时候就会设置为 Release ，编译产生的就是 Release 版本的可执行程序，这个版本是用户使的，无需包含调试信息等为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d616a1dba18730630345ea4100816ce.png" alt="请添加图片描述"></p><p>一般宏是在 Debug 中使用的，在VS环境下的 Release 版本不影响用户使用</p><h1 id="指针的应用"><a href="#指针的应用" class="headerlink" title="指针的应用"></a>指针的应用</h1><p>这里介绍两个概念：<strong>传值调用</strong>和<strong>传址调用</strong></p><p>传值调用：当调用一个函数并传递参数时，实际传递给函数的是参数值的副本，也就是说，函数内部对参数进行操作，不会影响到函数外部原来的变量值</p><p>传址调用：当调用一个函数并传递参数时，传递的是变量的地址（在一些语言中也可能表述为传递指向变量的指针等类似含义），这意味着函数内部通过该地址可以直接访问和操作函数外部的原始变量，对参数的任何修改都会反映到原始变量上</p><p>具体实例理解可以参考“交换变量的多种方法(面试题)”这篇博客</p><blockquote><p>传送门：<a href="https://blog.csdn.net/Zero_VPN/article/details/142233884?spm=1001.2014.3001.5502">交换变量的多种方法(面试题)</a></p></blockquote><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e9969227c057594fd439edc9067494e.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.10——进制转化&amp;&amp;操作符进阶</title>
      <link href="/2024/10/26/C%E8%AF%AD%E8%A8%80/vlog10/"/>
      <url>/2024/10/26/C%E8%AF%AD%E8%A8%80/vlog10/</url>
      
        <content type="html"><![CDATA[<h1 id="操作符分类"><a href="#操作符分类" class="headerlink" title="操作符分类"></a>操作符分类</h1><blockquote><p>• 算术操作符：+ 、- 、* 、&#x2F; 、%<br>• 移位操作符：&lt;&lt;、&gt;&gt;<br>• 位操作符：&amp;、|、^<br>• 赋值操作符：&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;、&amp;&#x3D;、|&#x3D;、^&#x3D;<br>• 单目操作符：！、++、–、&amp;、* 、+ 、- 、~ 、sizeof、(类型)<br>• 关系操作符：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、！&#x3D;<br>• 逻辑操作符：&amp;&amp;、||<br>• 条件操作符：？：<br>• 逗号表达式：，<br>• 下标引用：[ ]<br>• 函数调用：( )<br>• 结构体成员访问：. 、-&gt;</p></blockquote><p>上述操作符中，除了单目操作符中的&amp;、*将会在后续指针的vlog中介绍，高亮部分操作符是该篇要重点介绍的，操作符中有些操作符与二进制及其转化有关系，我们先拓展一些相关的基础知识</p><h1 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h1><p>计算机主流的数值表示形式为2进制、8进制、10进制、16进制<br><strong>2进制中满2进1<br>2进制的数字每⼀位都是0~1的数字组成()</strong><br>其余进制同理</p><blockquote><p> 12的2进制：1100<br>    12的8进制：14<br>    12的10进制：12<br>    12的16进制：C<br>   &#x2F;&#x2F;16进制的数值之前写:0x<br>  &#x2F;&#x2F;8进制的数值之前写:0 </p></blockquote><p>进制转化都是以 2 进制为转接点，所以重点介绍 2 进制与其他进制的转换</p><h2 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h2><p>10进制中的123，从右到左依次是个位，十位，百位<br>每一位都有自己的权重，每一位各自乘以各自的权重然后加和就是表示的值</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/76b097aec155a89809486f81db6013f.png" alt="在这里插入图片描述"><br>2进制表示的10进制的12也同理</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/87d352a4a8abc3d9a65c1a72d292321.png" alt="在这里插入图片描述"></p><h2 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h2><p>假设有个十进制数125转化为2进制，利用短除法可以快速得到转化后的结果</p><blockquote><p>125 % 2 &#x3D; 1<br>62 % 2 &#x3D; 0<br>31 % 2 &#x3D; 1<br>15 % 2 &#x3D; 1<br>7 % 2 &#x3D; 1<br>3 % 2 &#x3D; 1<br>1 % 2 &#x3D; 1 </p></blockquote><p>由下往上依次所得的余数就是125转化的2进制数，即1111101</p><h2 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h2><p>以在2进制转8进制数的时候，从2进制序列中右边低位开始向左每3个2进制位会换算一个8进制位<br>剩余不够3个2进制位的直接换算</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8c7c4a01b056c50ac4b0721880f6898.png" alt="请添加图片描述"><br>如：2进制的01101011，换成8进制：0153，0开头的数字，会被当做8进制</p><p><strong>8 进制转 2 进制也同理，按三个三个转换，去掉转换后前面多出的 0 就是 2 进制了</strong> </p><h2 id="2-4-二进制转十六进制"><a href="#2-4-二进制转十六进制" class="headerlink" title="2.4 二进制转十六进制"></a>2.4 二进制转十六进制</h2><p>在16进制中，两位数用字母表示（大小写都可以）</p><blockquote><p>10 &#x3D; A&#x2F;a<br>11 &#x3D; B&#x2F;b<br>12 &#x3D; C&#x2F;c<br>13 &#x3D; D&#x2F;d<br>14 &#x3D; E&#x2F;e<br>15 &#x3D; F&#x2F;f</p></blockquote><p>在2进制转16进制数的时候，从2进制序列中右边低位开始向左每4个2进制位会换算一个16进制位<br>剩余不够4个2进制位的直接换算</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/71ee74dd78d9fb1099078e89510ef00.png" alt="请添加图片描述"><br>如：2进制的01101011，换成16进制：0x6b，16进制表示的时候前面加0x</p><p><strong>16 进制转 2 进制也同理，按四个四个转换，去掉转换后前面多出的 0 就是 2 进制了</strong></p><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><p>整数的2进制表示方法有三种：原码、反码、补码</p><p>我们知道 int 类型占 32 比特位，有符号整数前提下，<strong>第一位是符号位，后面三十一位是数值位</strong><br><strong>符号位用 0 表示正，1 表示负</strong></p><p>正整数：原反补都<strong>相同</strong><br>负整数：<br><strong>原码</strong>：直接将数值按照正负数的形式翻译成二进制得到<br><strong>反码</strong>：将原码的<strong>符号位不变</strong>，其他位依次按位取反就可以得到反码<br><strong>补码</strong>：<strong>反码+1</strong>就得到补码</p><p>注意：<strong>原码取反＋1即可得到补码，补码取反+1也能得到原码</strong></p><p>计算机内存中以补码的形式保存</p><blockquote><p>在补码运算中，符号位可以和数值位一起参与运算，不需要额外的判断和处理。例如，在进行加法运算时，不管是正数相加还是正数和负数相加，或者负数相加，都可以按照相同的加法规则进行运算，而不需要单独考虑符号位的处理，这种特性使得计算机在进行算术运算时更加高效和准确</p></blockquote><h1 id="操作符进阶"><a href="#操作符进阶" class="headerlink" title="操作符进阶"></a>操作符进阶</h1><h2 id="移位操作符"><a href="#移位操作符" class="headerlink" title="移位操作符"></a>移位操作符</h2><p>移位操作符分为右移操作符 &gt;&gt; ,左移操作符 &lt;&lt; ,<strong>其操作数只能是整数</strong>，<strong>不要移动负数位</strong></p><h3 id="左移操作符"><a href="#左移操作符" class="headerlink" title="左移操作符"></a>左移操作符</h3><p><strong>左边抛弃，右边补0</strong><br>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8075a2fc42a4d48608739a4edb7de11.png" alt="在这里插入图片描述"></p><h3 id="右移操作符"><a href="#右移操作符" class="headerlink" title="右移操作符"></a>右移操作符</h3><p><strong>逻辑右移：左边补0，右边抛弃</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/9258338e1b347bdf2a5fa277740c58d.png" alt="在这里插入图片描述"><br><strong>算术右移：左边用原值的符号位补充，右边抛弃</strong></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/65b27ec3b60b0530a95ebb575c96fa8.png" alt="在这里插入图片描述"></p><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>位操作符的操作数必须是整数</p><blockquote><p>按位与：&amp;<br>按位或：|<br>按位异或：^<br>按位取反：~</p></blockquote><p>以下举例a &#x3D; 5,b &#x3D; 3</p><h3 id=""><a href="#" class="headerlink" title="&amp;"></a>&amp;</h3><p>当两个对应的二进制位都为 1 时，结果位才为 1，否则为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000000 01   <strong>a &amp; b</strong></p></blockquote><h3 id="-1"><a href="#-1" class="headerlink" title="|"></a>|</h3><p>当两个对应的二进制位中有一个为 1，结果位就为 1<br>当两个位都为 0 时，结果位才为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000001 11   <strong>a | b</strong></p></blockquote><h3 id="-2"><a href="#-2" class="headerlink" title="^"></a>^</h3><p>当两个对应的二进制位不同（一个为 0，另一个为 1）时，结果位为 1<br>当两个位相同（都为 0 或都为 1）时，结果位为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 0000000000 0000000000 0000000001 10   <strong>a ^ b</strong></p></blockquote><h3 id="-3"><a href="#-3" class="headerlink" title="~"></a>~</h3><p>将每个二进制位中的 0 变为 1，1 变为 0</p><blockquote><p> 0000000000 0000000000 0000000001 01   <strong>a</strong><br> 0000000000 0000000000 0000000000 11   <strong>b</strong><br> 1111 1111 11 1111 1111 11 1111 1111 10 10   <strong>~a</strong><br> 1111 1111 11 1111 1111 11 1111 1111 11 00   <strong>~b</strong></p></blockquote><h2 id="结构体访问操作符"><a href="#结构体访问操作符" class="headerlink" title="结构体访问操作符"></a>结构体访问操作符</h2><h3 id="结构体的简单介绍"><a href="#结构体的简单介绍" class="headerlink" title="结构体的简单介绍"></a>结构体的简单介绍</h3><p>结构是⼀些值的集合，这些值称为成员变量<br>结构的每个成员可以是不同类型的变量，如：标量、数组、指针，甚至是其他结构体</p><p><strong>结构体的语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">member-<span class="built_in">list</span>;</span><br><span class="line">&#125;variable-<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><strong>比如想要描述一名学生：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">char</span> name[<span class="number">20</span>];<span class="comment">//名字</span></span><br><span class="line">   <span class="type">int</span> age;<span class="comment">//年龄 </span></span><br><span class="line">   <span class="type">char</span> sex[<span class="number">5</span>];<span class="comment">//性别</span></span><br><span class="line">   <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//学号 </span></span><br><span class="line"> &#125;; <span class="comment">//分号不能丢</span></span><br></pre></td></tr></table></figure><p><strong>结构体的定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   <span class="type">int</span> y;</span><br><span class="line"> &#125;p1;        <span class="comment">//声明类型的同时定义变量p1        </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p2</span>;</span>    <span class="comment">//定义结构体变量p2 </span></span><br></pre></td></tr></table></figure><p><strong>结构体的初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p3</span> =</span> &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>        </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  <span class="type">char</span> name[<span class="number">15</span>];  </span><br><span class="line">  <span class="type">int</span> age;   </span><br><span class="line">&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">s2</span> =</span> &#123;.age=<span class="number">20</span>, .name=<span class="string">&quot;lisi&quot;</span>&#125;;<span class="comment">//指定顺序初始化</span></span><br></pre></td></tr></table></figure><h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>语法结构：结构体变量.成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x: %d y: %d\n&quot;</span>, p.x, p.y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h3><p>语法结构：结构体指针-&gt;成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> struct Point </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> <span class="title">p</span> =</span> &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> *<span class="title">ptr</span> =</span> &amp;p;</span><br><span class="line">ptr-&gt;x = <span class="number">10</span>;</span><br><span class="line">ptr-&gt;y = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d y = %d\n&quot;</span>, ptr-&gt;x, ptr-&gt;y);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分如果看不太明白的话可以先了解一下后面的指针部分，再来理解代码会容易很多</p><h1 id="操作符的优先级，结合性"><a href="#操作符的优先级，结合性" class="headerlink" title="操作符的优先级，结合性"></a>操作符的优先级，结合性</h1><p>优先级指的是，如果⼀个表达式包含多个运算符，哪个运算符应该优先执行<br>各种运算符的优先级是不⼀样的</p><p>如果两个运算符优先级相同，优先级没办法确定先计算哪个了，这时候就看结合性了，则根据运算符<br>是左结合，还是右结合，决定执行顺序</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/daa8aae6b4482d75e3b86b390c625ef.png" alt="请添加图片描述"></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/cf8ddae9fb79303b2b55ecfb69b151c.png" alt="请添加图片描述"></p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/b0a202ab80069a8d8ab7fda4d8a27d8.png" alt="请添加图片描述"><br>一般来说，可以这样记</p><blockquote><p>！&gt; 算术运算符 &gt; 关系运算符 &gt; 逻辑运算(&amp;&amp; &gt; ||) &gt; 赋值运算符</p></blockquote><h1 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h1><h2 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h2><p>C语言中整型算术运算总是以<strong>普通整型</strong>进行的<br>为了确保每个整型都是普通类型的便于系统运算，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为<strong>整型提升</strong></p><p><strong>保证计算精度</strong><br>例如，在一个 8 位系统中，char类型的取值范围是 - 128 到 127。假设有两个char类型变量a &#x3D; 120和b &#x3D; 10，它们的二进制表示分别是01111000和00001010，如果直接以char类型进行相加，结果可能会溢出，因为char类型的结果可能无法正确存储130这个值。而整型提升将它们转换为int类型（通常是 32 位，有足够的空间来存储运算结果），可以避免这种溢出情况，保证运算结果的准确性</p><p><strong>符合 CPU 运算习惯</strong><br>例如，在很多现代处理器架构中，加法指令可能是针对 32 位或 64 位整数设计的。当对char或short类型进行加法运算时，将它们提升为int类型可以直接使用这些高效的指令，而不需要专门为较小的数据类型设计特殊的、可能效率较低的运算指令</p><p><strong>提升方式：</strong></p><blockquote><ol><li>有符号整数提升是按照变量的数据类型的符号位来提升的</li><li>无符号整数提升，高位补0</li></ol></blockquote><h2 id="算术转化"><a href="#算术转化" class="headerlink" title="算术转化"></a>算术转化</h2><p>如果某个操作符的各个操作数属于不同的类型，那么除非其中⼀个操作数的转换为另⼀个操作数的类<br>型，否则操作就无法进行，下面的层次体系称为<strong>寻常算术转换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="type">float</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="type">int</span></span><br></pre></td></tr></table></figure><p>如果某个操作数的类型在上面这个列表中排名靠后<br>那么首先要转换为另外一个操作数的类型后执行运算</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/da5c088aaed8c19be39c25e1ce4fde2.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.9——青蛙跳台阶、汉诺塔</title>
      <link href="/2024/10/24/C%E8%AF%AD%E8%A8%80/vlog9/"/>
      <url>/2024/10/24/C%E8%AF%AD%E8%A8%80/vlog9/</url>
      
        <content type="html"><![CDATA[<h1 id="青蛙跳台阶专题"><a href="#青蛙跳台阶专题" class="headerlink" title="青蛙跳台阶专题"></a>青蛙跳台阶专题</h1><blockquote><p>题目介绍： 一共有 n 阶台阶，有一只青蛙能向上跳一阶台阶或两阶台阶<br>问：当青蛙跳到第n阶台阶时，有多少种跳法？</p></blockquote><p>这个问题乍一看有些摸不着头脑，我们可以通过举例的方式来找到问题的规律<br>这里我们设青蛙跳上第 n 阶台阶有 Fib(n) 种方法</p><blockquote><p>n &#x3D; 1 时，青蛙跳上第 1 阶台阶的方法：1 种<br>n &#x3D; 2 时，青蛙跳上第 2 阶台阶的方法：2 种<br>n &#x3D; 3 时，青蛙跳上第 3 阶台阶的方法：3 种<br>n &#x3D; 4 时，青蛙跳上第 4 阶台阶的方法：5 种<br>……<br>n &#x3D; n-1 时，青蛙跳上第 n-1 阶台阶的方法：Fib(n-2)+Fib(n-3) 种<br>n &#x3D; n 时，青蛙跳上第 n 阶台阶的方法：Fib(n-1)+Fib(n-2) 种</p></blockquote><p>观察可得，本质上青蛙跳台阶问题实质上就是一个斐波那契数列<br>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/4a23d34ba5b950a1fc8e07ec516d52a.png" alt="在这里插入图片描述"><br>那么根据 vlog.8 中的斐波那契数列求和代码可以很容易写出解决方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib(n - <span class="number">1</span>) + Fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="type">int</span> ret = Fib(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fib(%d)=%d\n&quot;</span>, x, ret);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码在源代码的基础上只进行了略微修改，用的是递归的方法，同样的也可以用迭代的方法简化代码，减少内存占用，防止栈溢出的风险，详细请看上一篇vlog</p><h1 id="汉诺塔专题"><a href="#汉诺塔专题" class="headerlink" title="汉诺塔专题"></a>汉诺塔专题</h1><blockquote><p>题目介绍：从左到右有A、B、C三个柱子，刚开始在A柱上从上到下套有1、2、3盘，其大小逐渐变大，盘子只能一个一个挪，借助于B柱，将A柱上的盘全部转移到C柱上，挪的过程中，盘子一定是上小下大<br>问：转移3个盘子需要多少步？</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/5e7f3f50751431c58b874e487ab88f7.png" alt="在这里插入图片描述"><br>还是通过举例的方法，从三个盘子开始入手会更加简单的发现规律：</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/64fb7310b17b6fe222bb2d6ecc18e93.png" alt="在这里插入图片描述"></p><blockquote><p>先把1盘挪到C柱，2盘挪到B柱，再把1盘挪回B柱，然后把3盘挪到C柱<br>即1、2盘为n-1个盘子</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a18020dd568a613784b1caf5d7711a.png" alt="请添加图片描述"></p><blockquote><p>再接着把1盘挪到A柱<br>即1盘为n-2个盘子</p></blockquote><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f03e23fcc2825f6d46c8feda98e5eee.png" alt="在这里插入图片描述"></p><blockquote><p>最后把2盘放到C柱上，再把1盘放到C柱上</p></blockquote><p>￼<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/67b1fe9a7709968b5a9d84b3d35042f.png" alt="在这里插入图片描述"></p><p>显而易见，这里移动了7次<br>我们定义移动的次数为F(n)</p><blockquote><p>1 个盘子时，需要移动 1 次<br>2 个盘子时，需要移动 3 次<br>3 个盘子时，需要移动 7 次<br>4 个盘子时，需要移动 15 次<br>……<br>n-1 个盘子时，需要移动 2F(n-2) + 1 次<br>n 个盘子时，需要移动 2F(n-1) + 1 次</p></blockquote><p>观察可得公式为 F(n) &#x3D; 2F(n-1) + 1 </p><p>那我们梳理一下过程可知<br>1、首先把n-1个盘子移动到第二根中转柱B上<br>2、再把最后一个也就是最大的那一个盘子移动到第三根目标柱C上<br>3、最后再把剩下的n-1个盘子移动到第三根目标柱C上</p><p>函数自己调用自己，那么可以知道这本质上也是个递归问题，写出以下移动过程代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> pos1, <span class="type">char</span> pos2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %c-&gt;%c &quot;</span>, pos1, pos2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> pos1, <span class="type">char</span> pos2, <span class="type">char</span> pos3)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">move(pos1, pos3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hanoi(n - <span class="number">1</span>, pos1, pos3, pos2);</span><br><span class="line">move(pos1, pos3);</span><br><span class="line">hanoi(n - <span class="number">1</span>, pos2, pos1, pos3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">hanoi(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能看到这里会有些迷糊，其实只要理解了递归的思想，该问题也就迎刃而解了</p><p>有意思的是，在汉诺塔传说中，僧侣想要把64个金片同样从A柱转移到B柱<br>根据公式需要2^64-1次，在古印度那个时代这显然是不可能依靠人一个一个搬运完成的</p><p>如果还有不理解的可以点击文章开头的链接看我的上一篇 vlog 进行辅助知识理解 <strong>OwO</strong></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c39ee5e0ca0444834a53f7e4867d841.png" alt="请添加图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.8——函数递归</title>
      <link href="/2024/10/22/C%E8%AF%AD%E8%A8%80/vlog8/"/>
      <url>/2024/10/22/C%E8%AF%AD%E8%A8%80/vlog8/</url>
      
        <content type="html"><![CDATA[<h1 id="递归的介绍"><a href="#递归的介绍" class="headerlink" title="递归的介绍"></a>递归的介绍</h1><p>在 vlog.2 的 printf 函数的返回值举例中，我们使用多次递归的方式实现了同一个函数的返回值调用，但这只是一个简易的递归，不算真正意义上的递归，那么什么是递归？</p><blockquote><p>在C语言中，<strong>递归就是函数自己调用自己</strong>，如果函数的递归没有限制条件，一直无限循环调用下去，代码最终就会陷入死循环，导致<strong>栈溢出</strong>（Stack overflow）</p></blockquote><p>递归就是递推的意思，递归的思考方式就是将<strong>大事化小</strong>，将复杂的程序化成简单的代码格式，也就是化成一个个子问题求解，知道子程序不再被分解，递归就结束了</p><h1 id="递归的限制条件"><a href="#递归的限制条件" class="headerlink" title="递归的限制条件"></a>递归的限制条件</h1><p>值得注意的是，递归也存在限制条件</p><blockquote><p>• 递归存在限制条件，当满足这个限制条件的时候，递归便不再继续<br>• 每次递归调用之后越来越接近这个限制条件</p></blockquote><h1 id="递归实战应用"><a href="#递归实战应用" class="headerlink" title="递归实战应用"></a>递归实战应用</h1><h2 id="求-n-的阶乘"><a href="#求-n-的阶乘" class="headerlink" title="求 n 的阶乘"></a>求 n 的阶乘</h2><blockquote><p>由数学知识可知：n！&#x3D; n ∗ (n−1)! 当 n &#x3D;&#x3D; 0 的时候，此时 n 的阶乘是 1 ，n &gt; 0时阶乘可根据公式计算</p></blockquote><p>那么我们可以写出阶乘函数 Fact ，Fact(n) 是求 n 的阶乘，那么Fact(n-1)就是求 n-1 的阶乘<br>此处不考虑 n 过大导致栈溢出的情况，只考虑合理范围内的 n</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> n*Fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span> ret = Fact(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的递归思想可以根据画图很容易的理解<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6a92e64b2dfae4900123d936d65d22d.png" alt="在这里插入图片描述"></p><h2 id="顺序打印一个整数的每一位"><a href="#顺序打印一个整数的每一位" class="headerlink" title="顺序打印一个整数的每一位"></a>顺序打印一个整数的每一位</h2><p>输入⼀个整数m，按照顺序打印整数的每⼀位<br>如果n是⼀位数，n的每⼀位就是n自己<br>n是超过1位数的话，就得拆分每⼀位<br>比如：</p><blockquote><p>1234%10就能得到4，然后1234&#x2F;10得到123，这就相当于去掉了4<br>然后继续对123%10，就得到了3，再除10去掉3，以此类推<br>不断的 %10 和 &#x2F;10 操作，直到1234的每一位都得到<br>但是这里有个问题就是得到的数字顺序是倒着的</p></blockquote><p>假设我们用函数Print(n)打印n的每一位<br>那么我们知道1234 % 10 &#x3D; 4，1234 &#x2F; 10 &#x3D; 123</p><blockquote><p> Print(1234)就可以拆分为两步：</p><ol><li>Print(1234&#x2F;10)  &#x2F;&#x2F;打印123的每⼀位 </li><li>printf(1234%10) &#x2F;&#x2F;打印4</li></ol></blockquote><p>以此类推,利用递归思想</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   Print(<span class="number">1234</span>)</span><br><span class="line">==&gt;Print(<span class="number">123</span>)                   +<span class="built_in">printf</span>(<span class="number">4</span>)</span><br><span class="line">==&gt;Print(<span class="number">12</span>)          + <span class="built_in">printf</span>(<span class="number">3</span>)</span><br><span class="line">==&gt;Print(<span class="number">1</span>) + <span class="built_in">printf</span>(<span class="number">2</span>)</span><br><span class="line">==&gt;<span class="built_in">printf</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>直到被打印的数字变成一位数的时候，就不需要再拆分，递归结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">9</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     Print(n/<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    Print(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的函数不断地调用，当函数调用完之后依次从最后一个子程序往第一个程序打印</p><h1 id="递归与迭代"><a href="#递归与迭代" class="headerlink" title="递归与迭代"></a>递归与迭代</h1><p> Fact函数是可以产生正确的结果，但是在递归函数调用的过程中涉及一些运行时的开销</p><blockquote><p>在C语言中每一次函数调用，都需要为本次函数调用在内存的栈区，申请一块内存空间来保存函数调<br>用期间的各种局部变量的值，这块空间被称为运行时堆栈，或者函数栈帧。<br>函数不返回，函数对应的栈帧空间就⼀直占用，所以如果函数调用中存在递归调用的话，每⼀次递归<br>函数调用都会开辟属于自己的栈帧空间，直到函数递归不再继续，开始回归，才逐层释放栈帧空间，<br>所以如果采用函数递归的方式完成代码，递归层次太深，就会浪费太多的栈帧空间，也可能引起栈溢<br>出的问题，而且也很耗时间（后期将推出函数栈帧专题）</p></blockquote><p>通常如果使用递归不合适，就可以使用迭代的方式，那什么是迭代呢？<br>迭代简单来讲就是用循环的方式运行</p><p>举个例子：求第 n 个斐波那契数<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/44bf3109470c7c32176d1af9f53cc0b.png" alt="在这里插入图片描述"><br>如果使用的是递归的方法的话，层次会非常深，冗余的计算会非常多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">     count++;<span class="comment">//统计第3个斐波那契数被计算的次数</span></span><br><span class="line"> <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> <span class="type">int</span> ret = Fib(n);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>根据 count 的次数，在计算第40个斐波那契数的时候，使用递归方式，第3个斐波那契数就被重复计算了39088169次，这些计算是非常冗余的。所以斐波那契数的计算，使用递归是非常不明智的，我们就得想迭代的方式解决</p><p>那么迭代的话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span>(n&gt;<span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> c = a+b;</span><br><span class="line"> a = b;</span><br><span class="line"> b = c;</span><br><span class="line"> n--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> c;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不难看出，似乎用迭代的方式去实现这个代码，效率就要高出很多了，但同时我们也不要一直使用，会容易出现程序错误</p><h1 id="递归经典问题的拓展"><a href="#递归经典问题的拓展" class="headerlink" title="递归经典问题的拓展"></a>递归经典问题的拓展</h1><p>青蛙跳台阶问题<br>汉诺塔问题</p><p>这两个问题将在下一期vlog拓展推出，欢迎大家看我的下一期推文</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/dd9199b39808c8738b61b5e84036f4d.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.7——数组函数实践</title>
      <link href="/2024/10/20/C%E8%AF%AD%E8%A8%80/vlog7/"/>
      <url>/2024/10/20/C%E8%AF%AD%E8%A8%80/vlog7/</url>
      
        <content type="html"><![CDATA[<p>扫雷游戏专题</p><p>掌握了前面的数组与函数的知识，我们可以制作一款大多电脑上都有的简易版经典小游戏——扫雷<br>游戏要求：<br>1.游戏使用菜单可以选择继续游玩或退出游戏<br>2.扫雷为 9 * 9 格子的棋盘<br>3.默认随机布置 10 个雷<br>4.排查雷：<br>如果该位置不是雷，就显示周围有几个雷<br>如果该位置是雷，就炸死游戏结束<br>把除 10 个雷以外的空格都找出来就算游戏胜利<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/98fe0980f23405fa352481ac087957c.png" alt="在这里插入图片描述"></p><h1 id="扫雷游戏的设计分析"><a href="#扫雷游戏的设计分析" class="headerlink" title="扫雷游戏的设计分析"></a>扫雷游戏的设计分析</h1><h2 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h2><p>在扫雷过程中，布置的雷和排查出的雷的信息要分别存储在两个棋盘上<br>因为我们需要在9<em>9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建⼀个9</em>9的数组来存放信息<br>如果这个位置是雷，我们就存放字  1 ，不是雷就存放  0<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/52cdf6b358f3b8c4c2fdf1b3fe212a3.png" alt="在这里插入图片描述"><br>假设我们排查（2，1）这个坐标，访问周围一圈8个蓝色的位置，查获一个雷</p><p>假设我们排查（5，8）这个坐标，访问周围一圈8个蓝色的位置，最下面三个坐标会越界<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/570ae017a400b6eb6b2a596ef06353c.png" alt="在这里插入图片描述"><br>为了防止越界的情况出现，在设计的时候，我们将数组扩大一圈，雷还是布置在原来的地方，周围一圈空在那儿就行了，所以我们将存放数据的数组创建成11*11是比较合适<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d0c74b3d0d2ca33b77210d8eb71b0a0.png" alt="在这里插入图片描述"><br>再接着，假设我们排查了某个位置，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的，那这个雷的个数信息存放在哪里呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能产生混淆和打印上的困难</p><p>解决办法：<br>雷和非雷的信息不要使用数字，使用字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便</p><p>这里我们采用另外⼀种方案，我们专门给⼀个棋盘（对应一个数组mine）存放布置好的雷的信息，再<br>给另外一个棋盘（对应另外一个数组show）存放排查出的雷的信息，这样就互不干扰了，把雷布置到<br>mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期<br>排查参考</p><p>同时为了保持神秘，show数组开始时初始化为字符  ‘ * ‘ ，为了保持两个数组的类型⼀致，可以使用同一<br>套函数处理，mine数组最开始也初始化为字符 ‘ 0 ‘ ，布置雷改成 ‘ 1 ‘<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/a9949132f774a195516a186169845d1.png" alt="在这里插入图片描述"></p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>为了游戏的代码清晰明辨，根据函数的声明和定义，设计三个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test.c <span class="comment">//⽂件中写游戏的测试逻辑  </span></span><br><span class="line">game.c <span class="comment">//⽂件中写游戏中函数的实现等</span></span><br><span class="line">game.h <span class="comment">//⽂件中写游戏需要的数据类型和函数声明等</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="扫雷游戏的实现"><a href="#扫雷游戏的实现" class="headerlink" title="扫雷游戏的实现"></a>扫雷游戏的实现</h1><p><strong>game.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> EASY_COUNT 10</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ROW 9</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> COL 9</span></span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ROWS ROW+2</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> COLS COL+2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化棋盘</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印棋盘</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//布置雷</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//排查雷</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>game.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">InitBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">char</span> <span class="built_in">set</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">         <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">              &#123;</span><br><span class="line">                    board[i][j] = <span class="built_in">set</span>;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="type">void</span> <span class="title function_">DisplayBoard</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span>  i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------扫雷游戏-------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= col; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">                <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, board[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> <span class="title function_">SetMine</span><span class="params">(<span class="type">char</span> board[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="comment">//布置10个雷</span></span><br><span class="line">        <span class="comment">//⽣成随机的坐标，布置雷</span></span><br><span class="line">        <span class="type">int</span> count = EASY_COUNT;</span><br><span class="line">        <span class="keyword">while</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">int</span> x = rand() % row + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> y = rand() % col + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        board[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        count--;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="title function_">GetMineCount</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mine[x<span class="number">-1</span>][y]+mine[x<span class="number">-1</span>][y<span class="number">-1</span>]+mine[x][y - <span class="number">1</span>]+mine[x+<span class="number">1</span>][y<span class="number">-1</span>]</span><br><span class="line">        +mine[x+<span class="number">1</span>][y]+mine[x+<span class="number">1</span>][y+<span class="number">1</span>]+mine[x][y+<span class="number">1</span>]+mine[x<span class="number">-1</span>][y+<span class="number">1</span>] - <span class="number">8</span> * <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> <span class="title function_">FindMine</span><span class="params">(<span class="type">char</span> mine[ROWS][COLS], <span class="type">char</span> show[ROWS][COLS], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line"> &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (win &lt;row*col- EASY_COUNT)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;请输⼊要排查的坐标:&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= row &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= col)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mine[x][y] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;很遗憾，你被炸死了\n&quot;</span>);</span><br><span class="line">                                DisplayBoard(mine, ROW, COL);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">//该位置不是雷，就统计这个坐标周围有⼏个雷</span></span><br><span class="line">                                <span class="type">int</span> count = GetMineCount(mine, x, y);</span><br><span class="line">                                show[x][y] = count + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                                DisplayBoard(show, ROW, COL);</span><br><span class="line">                                win++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;坐标⾮法，重新输⼊\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (win == row * col - EASY_COUNT)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，排雷成功\n&quot;</span>);</span><br><span class="line">                DisplayBoard(mine, ROW, COL);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>test.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;game.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*****   1. play   *****\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;*****   0. exit   *****\n&quot;</span>);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">char</span> mine[ROWS][COLS];<span class="comment">//存放布置好的雷</span></span><br><span class="line">       <span class="type">char</span> show[ROWS][COLS];<span class="comment">//存放排查出的雷的信息</span></span><br><span class="line">       <span class="comment">//初始化棋盘</span></span><br><span class="line">       <span class="comment">//1. mine数组最开始是全&#x27;0&#x27;         </span></span><br><span class="line">       <span class="comment">//2. show数组最开始是全&#x27;*&#x27; </span></span><br><span class="line">       InitBoard(mine, ROWS, COLS, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       InitBoard(show, ROWS, COLS, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">       <span class="comment">//打印棋盘</span></span><br><span class="line">       <span class="comment">//DisplayBoard(mine, ROW, COL);</span></span><br><span class="line">       DisplayBoard(show, ROW, COL);</span><br><span class="line">       <span class="comment">//1. 布置雷 </span></span><br><span class="line">       SetMine(mine, ROW, COL);</span><br><span class="line">       <span class="comment">//DisplayBoard(mine, ROW, COL);</span></span><br><span class="line">       <span class="comment">//2. 排查雷 </span></span><br><span class="line">       FindMine(mine, show, ROW, COL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">       srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">               menu();</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">               <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">               <span class="keyword">switch</span> (input)</span><br><span class="line">               &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                       game();</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;选择错误，重新选择\n&quot;</span>);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (input);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫雷游戏的扩展"><a href="#扫雷游戏的扩展" class="headerlink" title="扫雷游戏的扩展"></a>扫雷游戏的扩展</h1><p>是否可选择游戏难度？<br>是否可标记雷？<br>是否可加上排雷时间显示？<br>如果排查位置不是雷，周围也没有雷，可以展开周围的一片</p><p>以上拓展就不过多展示，可以根据前边所学知识自行拓展<br>在线扫雷游戏：<a href="http://www.minesweeper.cn/">http://www.minesweeper.cn/</a></p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/6ce74d252551be3ce82eea65707eb91.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.6——函数</title>
      <link href="/2024/10/18/C%E8%AF%AD%E8%A8%80/vlog6/"/>
      <url>/2024/10/18/C%E8%AF%AD%E8%A8%80/vlog6/</url>
      
        <content type="html"><![CDATA[<p>函数在我们小学就开始接触，比如：一次函数 y &#x3D; kx + b<br>在C语言中也引入了数学中的函数概念，也叫做子程序，<strong>C语言中的函数就是⼀个完成某项特定的任务的⼀小段代码</strong>，程序其实就是由多个子程序组合而成，提升了开发软件的效率</p><h1 id="函数的介绍"><a href="#函数的介绍" class="headerlink" title="函数的介绍"></a>函数的介绍</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>C语言中规定了各种法则，C语言本身并不提供库函数，但编译器厂商根据国际标准的ANSIC规定的一些函数标准给出了一些函数，这些函数就被称为<strong>库函数</strong></p><p>前面我们学过的printf，scanf等都是库函数中现成的可以直接使用的函数，这些函数方便了程序员对代码功能的实现，一定程度上提升了效率性和保障性</p><p>学习库函数的各种函数对一名合格的程序员来说很重要<br>这是两个学习网站：<br><strong>C&#x2F;C++官方的链接：<a href="https://zh.cppreference.com/w/c/header">https://zh.cppreference.com/w/c/header</a><br>cplusplus.com：<a href="https://legacy.cplusplus.com/reference/clibrary/">https://legacy.cplusplus.com/reference/clibrary/</a></strong></p><p>网站函数的学习形式：</p><ol><li>函数原型</li><li>函数功能介绍</li><li>参数和返回类型说明</li><li>代码举例</li><li>代码输出</li><li>相关知识链接</li></ol><p>注意：库函数是在标准库中对应的头文件中声明的，所以库函数的使用，务必包含对应的头文件，不包含是可能会出现⼀些问题的</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>光有库函数提供的函数远远不足以实现所有的代码功能，所以程序员自行写了许多函数以实现各种功能，这种代码就叫做<strong>自定义函数</strong>，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret_type <span class="title function_">fun_name</span><span class="params">(形式参数)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>• ret_type 是函数返回类型</strong><br>有时候可以是void，表示什么都不返回，当不需要返回数值时，也可以不写返回值的类型</p><p><strong>• fun_name 是函数名</strong><br>函数的名字与其功能相关联，所以函数起名时要根据其功能起有意义的名字，便于程序员解读</p><p><strong>• 括号中放的是形式参数</strong><br>参数要交代清楚类型，名字和参数个数</p><p><strong>• {}括起来的是函数体</strong><br>也就是函数完成功能实现的过程</p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>举个简单的例子：写一个加法函数，完成两个数字的相加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">//输⼊</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"> <span class="comment">//调⽤加法函数，完成a和b的相加</span></span><br><span class="line"> <span class="comment">//求和的结果放在r中</span></span><br><span class="line"> <span class="comment">//to do</span></span><br><span class="line"> <span class="type">int</span> ret = Add(a,b)</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>• a 和 b 为函数的实参</strong><br>实参就是真实传递给函数的参数</p><p><strong>• x 和 y 为函数的形参</strong><br>形参只在形式上存在，并不会一直存在，只有在调用函数时向内存申请空间，使用完函数后形参又被销毁</p><p><strong>• 形参和实参各自是独立的空间</strong><br>在VS2022的监视窗口上可以观察到<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d5387da4bbcac33364b3f09756a407f.png" alt="在这里插入图片描述"><br>x和y确实得到了a和b的值，但是x和y的地址和a和b的地址是不⼀样的<br>所以我们可以理解为形参是实参的⼀份临时拷贝，这叫做<strong>传值调用</strong>（后面在指针部分会详细介绍）</p><h2 id="数组做函数参数"><a href="#数组做函数参数" class="headerlink" title="数组做函数参数"></a>数组做函数参数</h2><p>举个例子：写⼀个函数将⼀个整型数组的内容，全部置为0，再写⼀个函数打印数组的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_arr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> arr[i] = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> sz)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> set_arr(arr, sz);<span class="comment">//设置数组内容为-1</span></span><br><span class="line"> print_arr(arr, sz);<span class="comment">//打印数组内容</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的set_arr函数要能够对数组内容进行设置，就得把数组作为参数传递给函数，同时函数内部在设<br>置数组每个元素的时候，也得遍历数组，需要知道数组的元素个数。所以我们需要给set_arr传递2个参<br>数，⼀个是数组，另外⼀个是数组的元素个数，仔细分析print_arr也是⼀样的，只有拿到了数组和元<br>素个数，才能遍历打印数组的每个元素</p><p>• 函数的形式参数要和函数的实参<strong>个数匹配</strong></p><p>• 函数的实参是数组，形参也是可以写成<strong>数组形式</strong>的</p><p>• 形参如果是一维数组，<strong>数组大小可以省略不写</strong></p><p>• 形参如果是二维数组，<strong>行可以省略，但是列不能省略</strong></p><p>• 数组传参，<strong>形参是不会创建新的数组的</strong></p><p>• 形参操作的数组和实参的数组是<strong>同一个数组</strong></p><h1 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h1><p>在使用函数的时候，比如 main 函数， 自定义的 Add 函数常常需要返回值，也就是 <strong>return 语句</strong></p><p>• return 后边可以是⼀个数值，也可以是⼀个表达式，如果是表达式则先执行表达式，再返回表达式的结果</p><p>• return 后边也可以什么都没有，直接写 return，这种写法适合函数返回类型是 void 的情况</p><p>• return 返回的值和函数返回类型不⼀致，系统会⾃动将返回的值隐式转换为函数的返回类型</p><p>• return 语句执行后，函数就彻底返回，后边的代码不再执行</p><p>• 如果函数中存在 if 等分支的语句，则要保证每种情况下都有 return 返回，否则会出现编译错误</p><h1 id="嵌套调用和链式访问"><a href="#嵌套调用和链式访问" class="headerlink" title="嵌套调用和链式访问"></a>嵌套调用和链式访问</h1><p><strong>嵌套调用</strong>就是函数间的相互调用，函数间的有效相互调用才实现了大型程序<br>举个例子：假设我们计算某年某月有多少天？如果要函数实现，可以设计2个函数</p><p>• is_leap_year()：根据年份确定是否是闰年</p><p>• get_days_of_month()：调用 is_leap_year 确定是否是闰年后，再根据月计算这个月的天数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_leap_year</span><span class="params">(<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(((y%<span class="number">4</span>==<span class="number">0</span>)&amp;&amp;(y%<span class="number">100</span>!=<span class="number">0</span>))||(y%<span class="number">400</span>==<span class="number">0</span>))</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_days_of_month</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> days[] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"> <span class="type">int</span> day = days[m];</span><br><span class="line"> <span class="keyword">if</span> (is_leap_year(y) &amp;&amp; m == <span class="number">2</span>)</span><br><span class="line"> day += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;y, &amp;m);</span><br><span class="line"> <span class="type">int</span> d = get_days_of_month(y, m);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>链式访问</strong>就是将一个函数的返回值作为另外一个函数的参数，像链条一样函数串起来就是函数的链式访问<br>举个有趣的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">43</span>)));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解该代码的关键是理解 printf 的返回值是啥？<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/ed4bc9c57e3d3895e4bc91e19070812.png" alt="在这里插入图片描述"><br>printf函数返回的是打印在屏幕上的字符的个数<br>我们就第⼀个printf打印的是第⼆个printf的返回值，第二个printf打印的是第三个printf的返回值<br>第三个printf打印43，在屏幕上打印2个字符，再返回2<br>第二个printf打印2，在屏幕上打印1个字符，再放回1<br>第一个printf打印1<br>所以屏幕上最终打印：4321</p><h1 id="函数的声明和定义"><a href="#函数的声明和定义" class="headerlink" title="函数的声明和定义"></a>函数的声明和定义</h1><h2 id="单个文件和多个文件"><a href="#单个文件和多个文件" class="headerlink" title="单个文件和多个文件"></a>单个文件和多个文件</h2><p><strong>单个文件</strong>中，还是上面闰年的例子，int is_leap_year 是函数的定义，int ret &#x3D; is_leap_year 是函数的调用</p><p>如果把 is_leap_year 函数放在main函数后面呢？<br>is_leap_year 函数调用的时候，并没有发现前面有 is_leap_year 的定义，就会报警告</p><p>那么如何让解决呢？<br>就是函数调用之前先声明一下 is_leap_year 这个函数，声明函数只要交代清楚：函数名，函数的返回类型和函数的参数就行了</p><p>上面闰年的例子就是正确的写法</p><p><strong>多个文件</strong>中，一般在企业中我们写代码时候，代码可能比较多，不会将所有的代码都放在一个文件中，我们往往会根据程序的功能，将代码拆分放在多个文件中一般情况下，函数的声明、类型的声明放在头文件（.h）中，函数的实现是放在源文件（.c）文件中</p><h2 id="static-和-extern"><a href="#static-和-extern" class="headerlink" title="static 和 extern"></a>static 和 extern</h2><p>在C语言中，static 和 extern 是关键字<br>static ：静态的意思，用于<strong>修饰全局变量，局部变量，函数</strong><br>extern ：用于<strong>声明外部符号</strong></p><p>这里拓展几个名词：<br><strong>作用域</strong>：⼀段程序代码中所用到的名字并不总是有效可用的<br>而限定这个名字的可用性的代码范围就是这个名字的作用域</p><p><strong>生命周期</strong>：变量的创建(申请内存)到变量的销毁(收回内存)之间的⼀个时间段</p><ol><li>局部变量的生命周期是：进入作用域变量创建，生命周期开始，出作用域生命周期结束</li><li>全局变量的生命周期是：整个程序的生命周期</li></ol><p>举个static修饰<strong>局部变量</strong>的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> i++;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> test();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果来看，打印了5个1，局部变量 i 每次进入 test 函数时都会重新定义，也就是重新创建再释放内存，如果我们不想让 i 出函数时被销毁，我们就在 int i &#x3D; 0 前面加上 static ，那么此时 i 出函数的时候是不会销毁的，重新进入函数也就不会重新创建变量，直接上次累积的数值继续计算</p><p>static修饰局部变量改变了变量的生命周期，生命周期改变的本质是改变了变量的存储类型，本<br>来⼀个局部变量是存储在内存的栈区的，但是被 static 修饰后存储到了静态区，存储在静态区的变<br>量和全局变量是⼀样的，生命周期就和程序的生命周期⼀样了，只有程序结束，变量才销毁，内存才<br>回收，但是作用域不变</p><p>举个static修饰<strong>全局变量</strong>的例子：</p><p>add.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_val = <span class="number">2018</span>;</span><br></pre></td></tr></table></figure><p>test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_val);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern 是用来<strong>声明外部符号</strong>的，如果⼀个全局的符号在A文件中定义的，在B文件中想使用，就可以使用 extern 进行声明，然后使用</p><p>如果在 int g_val &#x3D; 2018 前加个 static 在编译的时候会出现链接性错误，全局变量被 static 修饰之后，外部链接属性就变成了内部链接属性，只能在自己所在的源文件内部使用了，其他源文件，即使声明了，也是无法正常使用的（ <strong>static 修饰函数同理</strong>）</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/49c3020ede9a2b4405501955e8cf92e.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.5——数组</title>
      <link href="/2024/10/16/C%E8%AF%AD%E8%A8%80/vlog5/"/>
      <url>/2024/10/16/C%E8%AF%AD%E8%A8%80/vlog5/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的介绍"><a href="#数组的介绍" class="headerlink" title="数组的介绍"></a>数组的介绍</h1><p>数组简单理解就是一组相同类型元素的集合<br>注意：<br>• 数组中存放的是1个或者多个数据，但是数组元素个数不能为0<br>• 数组中存放的多个数据，类型是相同的<br>• 数组分为一维数组和多维数组，常见多维数组为二维数组<br>• 数组可以没有初始值，也可以没有大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1;</span><br><span class="line"><span class="type">int</span> arr2[] = &#123;<span class="number">0</span>&#125;<span class="comment">//大小为1</span></span><br></pre></td></tr></table></figure><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="一维数组的创建与初始化"><a href="#一维数组的创建与初始化" class="headerlink" title="一维数组的创建与初始化"></a>一维数组的创建与初始化</h2><p>一维数组其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arr_name[常量值];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//[]内是元素个数，&#123;&#125;内是初始化的元素</span></span><br></pre></td></tr></table></figure><p>type 可以是 char、float、double等等，也可以是自定义类型的数据<br>数组去掉其数组名剩下的就是数组的类型，比如：int arr1[10] ，arr1数组的类型是 int [10]</p><p>一维数组的<strong>完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>一维数组的<strong>不完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr2[<span class="number">6</span>] = &#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>第一个元素初始化为1，其余元素初始化为0</p><p>一维数组的<strong>错误初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>超出初始化元素的个数</p><p>注意：若 [ ] 内不写个数是可以的，该数组的元素个数根据 { } 的初始化决定</p><h2 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h2><p>数组是有下标的，假设有一组数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>那它的数组和下标对应关系为<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8107b3d10af7dee889c0b10df7c5423.png" alt="在这里插入图片描述"><br>所以C语言为了便于访问数组中的元素，创建了一个操作符 [ ] ，叫<strong>下引用操作符</strong><br>比如我们访问第五个元素，可以使用 arr[4] 访问</p><p>使用循环可以对数组进行打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要知道数组中元素的个数呢？<br>那此时我们可以使用C语言中的一个关键字 sizeof 计算类型或变量的大小<br>那只要计算出一个元素所占字节的个数，数组的元素个数就能算出来<br>这里我们选择第⼀个元素算大小就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> sz = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sz);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> sizeof(arr) 为数组大小， sizeof(arr[0]) 为数组一个元素的大小，这两相除即为元素个数</p><h2 id="一维数组的存储"><a href="#一维数组的存储" class="headerlink" title="一维数组的存储"></a>一维数组的存储</h2><p>要了解一维数组在内存中的存储，我们可以依次打印其各个元素的地址进行观察：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; </span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d] = %p\n &quot;</span>, i, &amp;arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/edd4b39ecd2f6ac1b917f71b07ccd29.png" alt="在这里插入图片描述"><br>从代码的运行结果来看每个数组地址之间相差4个字节，由此可知<strong>一维数组在内存中是连续存放的</strong></p><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="二维数组的创建与初始化"><a href="#二维数组的创建与初始化" class="headerlink" title="二维数组的创建与初始化"></a>二维数组的创建与初始化</h2><p>数组的元素都是内置类型的<br>如果我们把⼀维数组做为数组的元素，这时候就是<strong>二维数组</strong><br>二维数组作为数组元素的数组被称为<strong>三维数组</strong>，二维数组以上的数组统称为<strong>多维数组</strong></p><p>二维数组其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type arr_name[常量值<span class="number">1</span>][常量值<span class="number">2</span>]；</span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>这里的3表示数组有3行，5表示每行有5个元素</p><p>二维数组的<strong>完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr3[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>12345为第一行，23456为第二行，34567为第三行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr4[<span class="number">3</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>12000为第一行，34000为第二行，56000为第三行</p><p>二维数组的<strong>不完全初始化</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure><p>第一行初始化为12000，第二、三行都为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr5[][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr6[][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr7[][<span class="number">5</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>初始化时省略行，但是不能省略列</p><h2 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h2><p>C语言规定，二维数组的行是从0开始的，列也是从0开始的，假设有一数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>那它的数组和下标对应关系为<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/1ac3f24d1e6882aac0a9c2bbcd7156c.png" alt="在这里插入图片描述"><br>访问二维数组的单个元素我们知道了，那如何打印整个二维数组呢？<br>其实我们只要能够按照⼀定的规律产生所有的行和列的数字就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) <span class="comment">//产⽣⾏号</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) <span class="comment">//产⽣列号</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]); <span class="comment">//输出数据</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h2><p>像一维数组⼀样，我们如果想研究⼆维数组在内存中的存储方式，我们也是可以打印出数组所有元素的地址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[%d][%d] = %p\n&quot;</span>, i, j, &amp;arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/c7e26c7de9da82673fd9817d7b9adca.png" alt="在这里插入图片描述"><br>从代码运行结果来看，每个元素的地址间也是相隔4个字节，所以<strong>二维数组中的每个元素都是连续存放的</strong>，像一维数组那样一字排开存储</p><h1 id="C99中的变长数组"><a href="#C99中的变长数组" class="headerlink" title="C99中的变长数组"></a>C99中的变长数组</h1><p>在C99标准之前，C语言在创建数组的时候，数组大小的指定只能使用常量、常量表达式，或者如果我<br>们初始化数据的话，可以省略数组大小，这样的语法限制，让我们创建数组就不够灵活，有时候数组大了浪费空间，有时候数组小了不够用</p><p>于是C99中给了一个<strong>变长数组</strong>的新特性，允许我们使用变量指定数组大小，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = a+b;</span><br><span class="line"><span class="type">int</span> arr[n];</span><br></pre></td></tr></table></figure><p>数组 arr 就是变长数组，它的长度取决于变量 n 的值，编译器没法事先确定，只有运行时才能知道n是多少</p><p>变长数组的根本特征，就是数组长度只有运行时才能确定，所以变长数组不能初始化，它的好处是程<br>序员不必在开发时，随意为数组指定⼀个估计的长度，程序可以在运行时为数组分配精确的长度</p><p>遗憾的是在VS2022上，虽然支持大部分C99的语法，没有支持C99中的变长数组</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/af4c592ff65877f0c42d49814f0f71c.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.4——分支和循环（下）</title>
      <link href="/2024/10/14/C%E8%AF%AD%E8%A8%80/vlog4/"/>
      <url>/2024/10/14/C%E8%AF%AD%E8%A8%80/vlog4/</url>
      
        <content type="html"><![CDATA[<p>猜数字游戏专题</p><p>掌握了前面学习的vlog的知识，尤其是分支与循环，我们可以写一个经典有趣的游戏：猜数字<br>游戏要求：<br>1.电脑自动生成1~100的随机数<br>2.玩家猜数字，程序根据玩家猜的数字，做出猜大了或猜小了的判断，直到玩家猜对为止</p><h1 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h1><h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>rand是C语言中的一种函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span> <span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p> rand 会返回一个随机数，这个随机数的范围在0~RAND_MAX（理论值）之间<br>使用该函数需要包括头文件**#include &lt;stdlib.h&gt;**</p><p>实际上我们多次运行只有 rand 函数的程序会发现，每次打印的随机数都相同，其实只有 rand 函数返回的是一个<strong>伪随机数</strong>，真正的随机数是无法预测下一个数是多少的， rand 函数是基于一个叫 “<strong>种子</strong>” 的基准值生成随机数，种子默认值为1，所以我们想生成完全随机的数，要让种子时刻处于变化状态</p><h2 id="srand"><a href="#srand" class="headerlink" title="srand"></a>srand</h2><p>srand 也是C语言中的一种函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span> <span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed）；</span></span><br></pre></td></tr></table></figure><p> srand 会初始化随机数的生成器，调用 rand 函数前要调用 srand 函数，通过 srand 函数的参数seed来设置rand函数生成随机数的时候的种子，只要种子在变化，每次生成的随机数序列也就变化起来了<br>那也就是说 srand 的种子如果是随机的， rand 就能生成随机数</p><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><p>易知时间是在时刻发生变化的，所以我们可以将时间作为种子来使用<br> time 就是C语言中的一个时间函数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span> <span class="params">(<span class="type">time_t</span>* timer)</span>;</span><br></pre></td></tr></table></figure><p>time 函数会返回当前的日历时间，其实返回的是1970年1月1日0时0分0秒到现在程序运行时间之间的<br>差值，单位是秒，返回的类型是<strong>time_t类型</strong>的，time_t 类型本质上其实就是32位或者64位的整型类型</p><p>time 函数的参数 timer 如果是非NULL的指针的话，函数也会将这个返回的差值放在 timer 指向的内存中带回去，如果 timer 是NULL，就只返回这个时间的差值，time 函数返回的这个时间差也被叫做：时间戳, time 函数的时候需要包含头文件：**#include &lt;time.h&gt;**</p><p>于是完整的生成随机数代码可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand());</span><br></pre></td></tr></table></figure><p>srand函数是不需要频繁调用的，⼀次运行的程序中调用⼀次就够了</p><h2 id="随机数的范围"><a href="#随机数的范围" class="headerlink" title="随机数的范围"></a>随机数的范围</h2><p>生成0~99之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand() % <span class="number">100</span>;<span class="comment">//余数的范围是0~99</span></span><br></pre></td></tr></table></figure><p>生成1~100之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">//%100的余数是0~99,0~99的数字+1,范围是1~100</span></span><br></pre></td></tr></table></figure><p>生成100~200之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> + rand()%(<span class="number">200</span><span class="number">-100</span>+<span class="number">1</span>)<span class="comment">//余数的范围是0~100，加100后就是100~200</span></span><br></pre></td></tr></table></figure><p>生成a~b之间的随机数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + rand()%(b-a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="猜数字游戏的实现"><a href="#猜数字游戏的实现" class="headerlink" title="猜数字游戏的实现"></a>猜数字游戏的实现</h1><p>首先设置主要的菜单界面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">     srand((<span class="type">unsigned</span> <span class="type">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请选择:&gt;&quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">     <span class="keyword">switch</span> (input)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">          game();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;游戏结束\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;选择错误，重新选择\n&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (input);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;****** 1. play ******\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;****** 0. exit ******\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;***********************\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设计主要的猜数字代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> r = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> guess= <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;请猜数字&gt;:&quot;</span>);</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">       <span class="keyword">if</span>(guess &lt; r)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;猜⼩了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(guess &gt; r)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;猜⼤了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，猜对了\n&quot;</span>);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，丰富游戏玩法我们还可以加上猜的次数，自定义函数game可修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">game</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> r = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> guess = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">     <span class="keyword">while</span> (count)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;\n你还有%d次机会\n&quot;</span>, count);</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;请猜数字&gt;:&quot;</span>);</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">       <span class="keyword">if</span> (guess &lt; r)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜⼩了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (guess &gt; r)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜⼤了\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你，猜对了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     count--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;你失败了，正确值是:%d\n&quot;</span>, r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要注意把两个自定义函数 game 和 menu 放在主函数前<br>或者在主函数前加上 void mean() 和 void game() 进行<strong>函数声明</strong> (后面会讲) </p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会继续更新"><a href="#小编会继续更新" class="headerlink" title="小编会继续更新"></a>小编会继续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/3f51b4b4c496208dcc5e4624edf8b88.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.3——分支和循环（上）</title>
      <link href="/2024/10/12/C%E8%AF%AD%E8%A8%80/vlog3/"/>
      <url>/2024/10/12/C%E8%AF%AD%E8%A8%80/vlog3/</url>
      
        <content type="html"><![CDATA[<p>C语言的结构分为顺序结构、选择结构、循环结构，结构化程序设计离不开这三种结构或这三种结构的组合，合理快速的运用这些结构是学好C语言的基础</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p> if 语句，显而易见是如果的意思，通过判断真假来确认语句是否执行，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 表达式 )</span><br><span class="line"> 语句</span><br></pre></td></tr></table></figure><p> 表达式内语句为真，则语句执行，表达式内语句为假，则语句不执行，会直接跳过该语句<br> 在C语言中，0表示为假，非0表示为真<br> <img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/26a9bc676522b65c11c209750b3aacc.png" alt="在这里插入图片描述"><br>如果判断一个事物的正反面写两个 if 语句，就太麻烦了，这里就需要用到 if…else… 语句了<br>例如：输入⼀个年龄，&gt;&#x3D; 18岁就输出：成年，否则就输出：未成年</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"> <span class="keyword">if</span>(age&gt;=<span class="number">18</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成年\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;未成年\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 if 和 else 语句中都默认只控制一条语句，还是上面的例子，如果想要既打出”<strong>成年</strong>“，又想打出”<strong>可以谈恋爱了</strong>“,那就需要用大括号将两个 printf 输出语句括起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> age = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"> <span class="keyword">if</span>(age &gt;= <span class="number">18</span>) <span class="comment">//if 后使⽤&#123;&#125; 控制多条语句-这个块也叫：程序块，或者复合语句</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成年了\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;可以谈恋爱了\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果在 if 语句中嵌套 if 语句呢，这叫做<strong>嵌套 if</strong> ，但是如果连着多个 if 语句嵌套的话，会显得代码特别复杂不易理解，而且花括号多了，检查代码时也很难一一对应不遗漏，所以可以使用 <strong>else if</strong> ，就省去了嵌套的麻烦<br>例如：输入⼀个整数，判断输入的整数是0，还是正数或者负数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"> <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是0\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>) <span class="comment">//这⾥的if 相当于嵌套在else语句中，形成了嵌套结构</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是正数\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输⼊的数字是负数\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意，如果 else 语句前有多个 if  ，可以记住这样⼀条规则， <strong>else 总是跟最接近的 if 匹配</strong>，相当于前面的 if 语句都被悬空了，这就是悬空else问题<br>如果希望else确实和第⼀个if匹配，可以如下例子这样子操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(b == <span class="number">2</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;haha\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分支与循环操作符"><a href="#分支与循环操作符" class="headerlink" title="分支与循环操作符"></a>分支与循环操作符</h1><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>用于比较的操作符称为<strong>关系表达式</strong></p><p>• &gt; 大于运算符<br>• &lt; 小于运算符<br>• &gt;&#x3D; 大于等于运算符<br>• &lt;&#x3D; 小于等于运算符<br>• &#x3D;&#x3D; 相等运算符<br>• !&#x3D; 不相等运算符</p><p>关系表达式通常返回 0 或 1 ，表示真假，比如， 20 &gt; 12 返回 1 ， 12 &gt; 20 返回 0<br>注意不要把相等运算符 &#x3D;&#x3D; 和赋值运算符 &#x3D; 弄混</p><p><strong>要避免多个运算符连用</strong>，举个例子： i &lt; j &lt; k<br>这是个合法表达，但不能保证 j 在 i 和 k 之间，这是因为关系运算符是从左往右运算，即 (i &lt; j) &lt; k<br>所以应改为这种写法 i &lt; j &amp;&amp; j &lt; k</p><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><p>条件操作符也叫三目操作符，需要接受三个操作数，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1 ? exp2 : exp3</span><br></pre></td></tr></table></figure><p>如果 exp1 为真， exp2 计算，计算的结果是整个表达式的结果；如果<br>exp1 为假， exp3 计算，计算的结果是整个表达式的结果</p><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><p>逻辑运算符用于逻辑的判断</p><p>• ! ：逻辑取反运算符（改变单个表达式的真假）<br>• &amp;&amp; ：逻辑与运算符，就是并且的意思（<strong>两侧的表达式都为真，则为真，否则为假</strong>）<br>• || ：逻辑或运算符，就是或者的意思（<strong>两侧至少有⼀个表达式为真，则为真，否则为假</strong>）</p><p>C语言的逻辑运算有个特点，就是优先对左侧的表达式求值，再对表达式右边的值求值<br>如果左边的表达式满足逻辑运算符的条件，就不再对右边的表达式求值，这种情况称为<strong>短路</strong></p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p> switch 语句用于实现分支结构，在循环结构中相当于 else if<br> 使用 switch 能够更好解读代码，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> value1: statement</span><br><span class="line"> <span class="keyword">case</span> value2: statement</span><br><span class="line"> <span class="keyword">default</span>: statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句会依次执行 case 分支，如果找不到对应的分支语句，就执行 default 语句<br>注意：<br>• switch 后的 expression 必须是<strong>整型表达式</strong><br>• case 后的值，必须是<strong>整形常量表达式</strong></p><p>举个例子：输入任意⼀个整数值，计算除3之后的余数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"> <span class="keyword">switch</span>(n%<span class="number">3</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;整除，余数为0\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;余数是1\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;余数是2\n&quot;</span>); </span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;输入错误&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>• case 和后边的数字之间必须有空格<br>• 每⼀个 case 语句中的代码执行完成后，需要加上 break ，才能跳出这个switch语句，否则会继续执行别的语句，就达不到我们想要的分支效果了<br>• default 在语句中没有顺序要求，通常把 default 放最后更符合逻辑</p><h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h1><p>while 语句也是一种常用的循环语句，while 语句的语法结构和 if 语句非常相似<br>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>); <span class="comment">//while后边的条件满⾜，死循环的打印hehe</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上来就是执行判断表达式，表达式的值为0，循环直接结束；表达式的值不为0，则执行循环语<br>句，语句执行完后再继续判断，是否进行下⼀次判断<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/f20cbbda52d46b5c6e2d74c57d871b9.png" alt="在这里插入图片描述"></p><h1 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h1><p>for 循环在循环结构中是最常使用的，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line"> 语句；<span class="comment">//如果循环体想包含更多的语句，可以加上⼤括号</span></span><br></pre></td></tr></table></figure><p>表达式1 用于循环变量的初始化<br>表达式2 用于循环结束条件的判断<br>表达式3 用于循环变量的调整</p><p>举个例子：计算1~100之间3的倍数的数字之和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"> sum += i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行表达式1：初始化循环变量，接下来就是执行表达式2：判断，表达式2的结果如果&#x3D;&#x3D;0，则循环结束<br>表达式2的结果如果!&#x3D;0则执行循环语句，循环语句执行完后，再去执行表达式3：调整循环<br>然后再去表达式2的地方执行判断，表达式2的结果是否为0，决定循环是否继续</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/67d275e42a5e7713bf44cdb77e93b46.png" alt="在这里插入图片描述"><br>整个过程中表达式1：初始化只被执行过一次</p><h1 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a>do-while循环语句</h1><p>do-while 语句在循环结构中使用的最少，其语法形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"> 语句；</span><br><span class="line"><span class="keyword">while</span>(表达式)；</span><br></pre></td></tr></table></figure><p>举个例子：在屏幕上打印1~10的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"> i = i + <span class="number">1</span>;</span><br><span class="line"> &#125;<span class="keyword">while</span>(i&lt;=<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行 do 里的语句，然后判断表达式<br>判断表达式的结果是!&#x3D;0，则继续循环，执行循环语句；判断表达式的结果 &#x3D;&#x3D; 0，则循环结束</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/55608d99ffdd1528aa1b5a45bb3f199.png" alt="在这里插入图片描述"></p><h1 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h1><p>在循环执行的过程中，如果某些状况发生的时候，需要提前终止循环，这是非常常见的现象。C语言中<br>提供了 break 和 continue 两个关键字，就是应用到循环中的。</p><p>• break 的作用是用于永久的终止循环，只要 break 被执行，直接就会跳出循环，继续往后执行<br>• continue 的作用是跳过本次循环中 continue 后边的代码， for 循环中直接跳到循环调整部分，while 循环直接跳到循环判断部分</p><h1 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h1><p>goto 语句可以实现在同⼀个函数内跳转到设置好的标号处<br>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> next;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;haha\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">next:</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;跳过了haha的打印\n&quot;</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>goto 语句如果使用的不当，就会导致在函数内部随意乱跳转，打乱程序的执行流程，所以我们的建<br>议是能不用尽量不去使用；但是 goto 语句也不是一无是处，在多层循环的代码中，如果想快速跳出<br>使用 goto 就非常的方便了<br>比如本来 for 循环想提前退出得使用 break ，⼀个 break 只能跳出⼀层 for 循环，如果3层循环嵌套<br>就得使用3个 break 才能跳出循环，所以在这种情况下我们使用 goto 语句就会更加的快捷</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会持续更新"><a href="#小编会持续更新" class="headerlink" title="小编会持续更新"></a>小编会持续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/60692ff12e67dca25120f3622ddbe14.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.2——C语言数据类型和变量</title>
      <link href="/2024/10/10/C%E8%AF%AD%E8%A8%80/vlog2/"/>
      <url>/2024/10/10/C%E8%AF%AD%E8%A8%80/vlog2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型的介绍"><a href="#数据类型的介绍" class="headerlink" title="数据类型的介绍"></a>数据类型的介绍</h1><h2 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h2><p>C语言的数据类型多种多样，类型不仅是我们了解数据的开始，也是数据初始化、函数自定义等的操作，编译器只有知道了数据的类型，才能进行相应的操作<br><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/2edd3369e3a5a1ac391287b5394a135.png" alt="在这里插入图片描述"></p><p><strong>字符型</strong>：char、[signed] char（有符号字符）、[unsigned] char（无符号字符）</p><p><strong>整型</strong>：int、[signed] int、unsigned int<br><strong>短整型</strong>：short [int]、[signed] short [int]、unsigned int [int]<br><strong>长整型</strong>：long [int]、[signed] long [int]、unsigned long [int]<br><strong>更长的整型</strong>：long long [int]、[signed] long long [int]、unsigned long long [int]</p><p><strong>浮点型</strong>：float、double、long double</p><p><strong>布尔类型</strong>：布尔类型本不是专门的类型，后来为了表示真假，引入了布尔类型_Bool或bool，使用布尔类型必须包含头文件#include &lt;stdbool.h&gt;,布尔类型返回的是<strong>true或false</strong>，表示真假</p><p>注意每种类型的数据都有自己的长度，存储的数据范围有所差异，这里就不过多赘述（详情可看<a href="https://legacy.cplusplus.com/%EF%BC%89">https://legacy.cplusplus.com/）</a></p><h2 id="sizeof操作符"><a href="#sizeof操作符" class="headerlink" title="sizeof操作符"></a>sizeof操作符</h2><p>sizeof是一个关键字，也是个操作符，用于计算操作符数的类型长度，单位是字节<br>sizeof有两种计算方式：<strong>sizeof（类型）、sizeof 表达式</strong><br>这里要注意的是sizeof后边的表达式是不参与真实运算的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="keyword">sizeof</span>(num + <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 这里 num + 20 并不会真正进行加法运算，只是根据 num 的类zd型（int）来确定大小。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of num + 20: %zd\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显而易见这里输出的result的值应为4，在VS2022的X64环境下，常见的int为4个字节，char为1个字节，这里只是根据其类型得出是4个字节。而且sizeof需要用%zd（无符号整型）来打印，sizeof的计算结果是<strong>size_t类型</strong>的。</p><p>sizeof 运算符的返回值，C 语言只规定是<strong>无符号整数</strong>，并没有规定具体的类型，而是留给系统自己去决定， sizeof 到底返回什么类型。不同的系统中，返回值的类型有可能是unsigned int ，也有可能是 unsigned long ，甚至是 unsigned long long ，对应的 printf() 占位符分别是 %u 、 %lu 和 %llu 。这样不利于程序的可移植性。C 语言提供了⼀个解决方法，创造了⼀个类型别名 size_t ，用来统⼀表示 sizeof 的返回值类型。对应当前系统的 sizeof 的返回值类型，可能是 unsigned int ，也可能是unsigned long long</p><h2 id="signed和unsigned"><a href="#signed和unsigned" class="headerlink" title="signed和unsigned"></a>signed和unsigned</h2><p>signed表示一个类型带有正负号，unsigned表示一个类型不带有正负号，也就是正整数，所以对于int来说完整的写法应该是signed int，只不过平常忽略不写，但写了也不算错</p><p>int 类型也可以不带正负号，只表示非负整数，这时就必须使用关键字unsigned声明变量。unsigned int里面的int可以省略，也就是可以写成unsigned，字符char也存在signed、unsigned</p><p>值得注意的是C语言规定char是否默认带有正负号由当前系统决定，这就是说，char 不等同于 signed char ，它有可能是 signed char ，也有可能是unsigned char </p><h1 id="变量的介绍"><a href="#变量的介绍" class="headerlink" title="变量的介绍"></a>变量的介绍</h1><h2 id="创建与初始化"><a href="#创建与初始化" class="headerlink" title="创建与初始化"></a>创建与初始化</h2><p>我们都知道变化的量叫变量，不变的称为常量，创建形式为<strong>data_type name</strong>，第一个为数据类型，第二个为变量名，例如int a &#x3D; 10，在变量在创建的时候就给⼀个初始值，这就叫初始化</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>全局变量</strong>：在大括号外部定义的变量就是全局变量<br>全局变量的使用范围更广，整个工程中想使用，都是有办法使用的</p><p><strong>局部变量</strong>：在大括号内部定义的变量就是局部变量<br>局部变量的使用范围是比较局限，只能在自己所在的局部范围内使用的</p><p>注意当局部变量和全局变量同名时，<strong>局部变量优先使用</strong></p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>内存中有三个区域：栈区、堆区、静态区</p><ol><li>局部变量是放在内存的栈区</li><li>全局变量是放在内存的静态区</li><li>堆区是用来动态内存管理的（后期会介绍）</li></ol><h1 id="操作符的介绍"><a href="#操作符的介绍" class="headerlink" title="操作符的介绍"></a>操作符的介绍</h1><h2 id="算术操作符：-、-、-、-、"><a href="#算术操作符：-、-、-、-、" class="headerlink" title="算术操作符：+、-、*、&#x2F;、%"></a>算术操作符：+、-、*、&#x2F;、%</h2><p>C语⾔中为了方便运算，提供了⼀系列操作符，其中有⼀组操作符叫：算术操作符。<br>分别是： + - * &#x2F; % ，这些操作符需要两个操作数进行计算的都是<strong>双目操作符</strong>，操作符也叫做<strong>运算符</strong></p><p>用+ 和 - 来完成加法和减法</p><p>运算符 * 用来完成乘法</p><p>运算符 &#x2F; 用来完成除法，除号的两端如果是整数，执行的是整数除法，得到的结果也是整数，<strong>如果运算数中至少有一个float浮点数，就能得到浮点数</strong></p><p>运算符 % 表示求模(余)运算，即返回两个整数相除的余值。这个运算符只能用于整数，不能用于浮点数，<strong>负数求模的规则是，结果的正负号由第⼀个运算数的正负号决定</strong></p><h2 id="赋值操作符：-和复合赋值"><a href="#赋值操作符：-和复合赋值" class="headerlink" title="赋值操作符：&#x3D;和复合赋值"></a>赋值操作符：&#x3D;和复合赋值</h2><p>赋值操作符 &#x3D; 是⼀个随时可以给变量赋值的操作符，要赋的值放在右边。赋值也可以连续赋值，从右向左依次赋值</p><p>对一个数进行自增、自减操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a+<span class="number">3</span>;</span><br><span class="line">a = a<span class="number">-2</span>;</span><br></pre></td></tr></table></figure><p>用复合赋值的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">3</span>;</span><br><span class="line">a -= <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>代码会显得更方便简洁，对以上的算术操作符都适用</p><h2 id="单目操作符：-、–、-、"><a href="#单目操作符：-、–、-、" class="headerlink" title="单目操作符：++、–、+、-"></a>单目操作符：++、–、+、-</h2><p>C语言中还有⼀些操作符只有⼀个操作数，被称<br>为单目操作符。 ++、–、+(正)、-(负) 就是单目操作符</p><p><strong>前置++</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = ++a;<span class="comment">//++的操作数是a，是放在a的前⾯的，就是前置++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a , b);</span><br></pre></td></tr></table></figure><p><strong>计算口诀：先+1，后使用</strong><br>a原来是10，先+1，后a变成了11，再使用就是赋值给b，b得到的也是11，所以计算后，a和b都是11</p><p><strong>后置++</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = a++;<span class="comment">//++的操作数是a，是放在a的后⾯的，就是后置++</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a , b);</span><br></pre></td></tr></table></figure><p><strong>计算口诀：先使用，后+1</strong><br>a原来是10，先使用，就是先赋值给b，b得到了10，然后再+1，然后a变成了11，所以直接计算后a是11，b是10</p><p>前置–和后置++与上面同理</p><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>以一段代码做例子就明白了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//a的是int类型, 3.14是double类型，两边的类型不⼀致，编译器会报警告</span></span><br></pre></td></tr></table></figure><p>消除这个警告，就可以使用强制类型转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//意思是将3.14强制类型转换为int类型，这种强制类型转换只取整数部分入代码片</span></span><br></pre></td></tr></table></figure><p>注意强制转化只在万不得已的时候使用</p><h1 id="占位符的介绍及使用"><a href="#占位符的介绍及使用" class="headerlink" title="占位符的介绍及使用"></a>占位符的介绍及使用</h1><p>占位符在printf中这样使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;There are %d apples\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出There are 3 apples，这样输出语句更能提高程序的稳定性和准确性</p><p>除此之外，还有很多常见的占位符<br>• %c ：字符。<br>• %d ：十进制整数<br>• %f ：小数（包含 float 类型和 double 类型）<br>• %p ：指针（用来打印地址）<br>• %s ：字符串。<br>• %u ：无符号整数<br>• %x ：十六进制整数<br>• %zd ： size_t 类型</p><p><strong>限定宽度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, <span class="number">123</span>); <span class="comment">// 输出为 &quot;  123&quot;</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> %5d 表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。输出的值默认是右对齐，即输出内容前面会有空格<br> 如果希望改成左对齐，在输出内容后面添加空格，可以在占位符的 % 的后面插入⼀个 - 号</p><p><strong>总是显示正负号</strong></p><p>默认情况下， printf() 不对正数显示 + 号，只对负数显示 - 号。如果想让正数也输出 + 号，可<br>以在占位符的 % 后面加⼀个 +</p><p><strong>限定小数位数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 Number is 0.50</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Number is %.2f\n&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望小数点后面输出3位（ 0.500 ），占位符就要写成 %.3f<br>也可以和限定宽度结合使用，比如%6.2f，输出为”*<em>0.50”(这里的</em>表示空格）<br>最小宽度和小数位数这两个限定值，都可以用 *代替，通过 printf() 的参数传入</p><p><strong>输出部分字符串</strong></p><p>可以用 %.[m]s 指定输出的长度，其中 [m] 代表⼀个数字，表示所要输出的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%.5s\n&quot;</span>, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出前五个字符，即“hello”</p><h1 id="scanf函数的介绍"><a href="#scanf函数的介绍" class="headerlink" title="scanf函数的介绍"></a>scanf函数的介绍</h1><p>scanf() 函数用于读取用户的键盘输入<br>程序运行到这个语句时，会停下来，等待用户从键盘输入，输入数据、按下回车键后， scanf() 就会处理用户的输入，将其存入变量</p><p>scanf的使用方法与printf类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>不过scanf需要加取地址符号&amp;（后面会讲）</p><p>注意scanf() 的返回值是一个整数，表示成功读取的变量个数。<br>如果没有读取任何项，或者匹配失败，则返回 0 。<br>如果在成功读取任何数据之前，发生了读取错误或者遇到读取到文件结尾，则返回常量 EOF (-1)</p><h1 id="希望读者们多多三连支持"><a href="#希望读者们多多三连支持" class="headerlink" title="希望读者们多多三连支持"></a>希望读者们多多三连支持</h1><h1 id="小编会持续更新"><a href="#小编会持续更新" class="headerlink" title="小编会持续更新"></a>小编会持续更新</h1><h1 id="你们的鼓励就是我前进的动力！"><a href="#你们的鼓励就是我前进的动力！" class="headerlink" title="你们的鼓励就是我前进的动力！"></a>你们的鼓励就是我前进的动力！</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e499c20858c89482285baee013c1b66.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我、重生到500年前凭借C语言改变世界科技vlog.1——C语言常见概念</title>
      <link href="/2024/10/08/C%E8%AF%AD%E8%A8%80/vlog1/"/>
      <url>/2024/10/08/C%E8%AF%AD%E8%A8%80/vlog1/</url>
      
        <content type="html"><![CDATA[<p>​</p><h1 id="C语言是什么？和C-有什么区别？"><a href="#C语言是什么？和C-有什么区别？" class="headerlink" title="C语言是什么？和C++有什么区别？"></a>C语言是什么？和C++有什么区别？</h1><p>定义：C 语言是一种通用的、面向过程的计算机编程语言。它最初由丹尼斯・里奇（Dennis Ritchie）在 20 世纪 70 年代初于贝尔实验室开发，用于编写 UNIX 操作系统。C 语言具有高效、简洁、可移植性强等特点。</p><p>简单来说：人和人交流使用的是自然语言，那么计算机语言就是人和计算机交流的桥梁，C语言就是众多计算机语言中的⼀种</p><p>C语言和C++的区别:C++是C语言的plus版，C语言是面向过程的语言，把大象放进冰箱需要多少步？需要三步，打开冰箱门，放入大象，关闭冰箱，这就是面向过程。C++是面向对象的语言，比C语言难，但是直接学习C++也需要接触面向过程的内容，大象的体重？身高？冰箱的尺寸？制冷效率？这就是面向对象的内容。</p><h1 id="编译器的选择和使用"><a href="#编译器的选择和使用" class="headerlink" title="编译器的选择和使用"></a>编译器的选择和使用</h1><p>我们需要把C语言转化成机器能够执行的机器命令，就需要一些编译器的集成开发环境来实现。<br>那我们常见的C语言编译器都有哪些呢？</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/8857f0d6431ab38cd709e5cb498296d.png" alt="DevC++"></p><p>集成了gcc开发环境，也是学校和一些竞赛常用的，具有小巧灵活的特点，但是对代码风格的养成不太友好，不利于码农写出好看标准的代码，故选择性使用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/e65d9b52ab12f4680575f00495919d3.png" alt="Clion"></p><p>集成了CMake开发环境，编译器可以根据个人习惯配置，还是不错的，但介于他是个收费软件，故不做目前推荐使用</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/7cc95ca71bd8e2d6c6da762a02a578d.png" alt="VS2022"></p><p>集成了MSVC开发环境，安装报包较大一些，安装简单，无需多余配置，企业中也较多使用，中文界面对初学者也很友好,使用起来非常方便，便于培养代码风格，是作者最喜欢用的，故在此推荐使用</p><h1 id="项目、源文件、头文件的介绍"><a href="#项目、源文件、头文件的介绍" class="headerlink" title="项目、源文件、头文件的介绍"></a>项目、源文件、头文件的介绍</h1><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/138971510e0e0be6039199b0bbd6c55.png" alt="在这里插入图片描述"></p><p>安装好VS2022后，我们创建一个空白界面，这就是一个项目</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/d2b2428fd1f2ce8d8ead0bc68427df7.png" alt="在这里插入图片描述"></p><p>如图所示，以.h结尾的就叫做头文件，以.c结尾的就叫做源文件 </p><p>头文件定义：是一种包含函数声明、变量声明、宏定义和类型定义等内容的文件，通常以.h（在 C、C++ 等编程语言中）为扩展名。</p><p>简单来说就是包含了自定义函数以及编译器自带函数等的文件</p><p>源文件定义：源文件是包含实际函数定义、变量定义等可执行代码的文件，在 C、C++ 等语言中通常以.c或.cpp（C++ 源文件）为扩展名。</p><p>简单来说我们在头文件下创建和执行的代码所在的文件就叫源文件</p><h1 id="main函数、printf函数、库函数的介绍"><a href="#main函数、printf函数、库函数的介绍" class="headerlink" title="main函数、printf函数、库函数的介绍"></a>main函数、printf函数、库函数的介绍</h1><p> main函数</p><p>是程序的入口点。这意味着当程序开始运行时，操作系统会首先调用main函数。 它是整个程序执行的起始位置，就像一场演出的开场节目一样，程序的其他部分都是在main函数的调用或控制下逐步执行的。</p><p>main函数也被叫做主函数，在写”hello world”代码时，前面的int表示函数执行结束时返回的类型，所以在main函数最后写return 0；正好前后呼应，返回一个0（假）使代码停止</p><p>• main函数有且仅有⼀个<br>• 即使⼀个项目中有多个.c文件，但是只能有⼀个main函数（因为程序的入口只能有⼀个）<br>• main后边的()不能漏掉了<br>• 代码中不能使用中文符号，比如括号和分号<br>• 一条语句结束后，有分号<br>printf函数<br>实现代码在屏幕上的打印，printf也是个库函数，printf可以打印各种类型的数据<br>库函数<br>一些代码会被我们重复性的去使用，为了提高程序员的代码开发效率，C语言标准规定了一些函数，由编译器进行实现提供给程序员使用，这些函数组成了一个库就被称为标准库，也叫库函数，库函数一般会声明在头文件中，所以使用库函数要包含对应的头文件</p><h1 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h1><p>像int、if、return这类保留名字的符号被称为关键字<br>• 关键字都有特殊的意义，是保留给C语言使用的<br>• 程序员自己在创建标识符的时候是不能和关键字重复的<br>• 关键字也是不能自己创建的。<br>6.字符、字符串、ASC||编码的介绍<br>像a、b、@、&amp;等这些叫做字符，使用单括号将他们括起来<br>像”abcdef”叫做字符串，使用双括号将他们括起来<br>计算机中的数据是以二进制形式存储的，给每个字符都编码一个二进制序列，这个叫做编码，所以出台了一个标准ASC||编码方便相互同通信，敲代码 </p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/74334dbd08f3100de253af978e582e9.png" alt="在这里插入图片描述"></p><p>• 字符A-Z的ASCII码值从65-90<br>• 字符a-z的ASCII码值从97-122<br>• 对应的大小写字符(a和A)的ASCII码值的差值是32<br>• 数字字符0-9的ASCII码值从48-57<br>• 换行\n 的ASCII值是：10<br>• 在这些字符中ASCII码值从0~31 这32个字符是不可打印字符，无法打印在屏幕上观察</p><h1 id="转义字符的介绍"><a href="#转义字符的介绍" class="headerlink" title="转义字符的介绍"></a>转义字符的介绍</h1><p>转义字符其实就是转变代码意思的字符<br>C语言中像这样的转义字符还有一些，具体如下：<br>• ? ：在书写连续多个问号时使用，防止他们被解析成三字母词，在新的编译器上没法验证了。<br>• \ ：用于表示⼀个反斜杠，防止它被解释为⼀个转义序列符。<br>• \a ：警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。<br>• \b ：退格键，光标回退⼀个字符，但不删除字符。<br>• \f ：换页符，光标移到下一页。在现代系统上，这已经反映不出来了，行为改成类似于 \v 。<br>• \n ：换行符。<br>• \r ：回车符，光标移到同一行的开头。<br>• \t ：制表符，光标移到下⼀个水平制表位，通常是下⼀个4&#x2F;8的倍数。<br>• \ddd ：d d d表示1~3个八进制的数字。 如：\130 表示字符X<br>• \xdd ：d d表示2个⼗六进制数字。 如： \x30 表示字符0<br>• \0 ：null 字符，代表没有内容， \0 就是 \ddd 这类转义字符的⼀种，⽤于字符串的结束标志，其<br>ASCII码值是0</p><h1 id="注释的重要性"><a href="#注释的重要性" class="headerlink" title="注释的重要性"></a>注释的重要性</h1><p>注释是一种对代码的说明，通常在&#x2F;&#x2F;后进行注释，注释后的代码编译器会忽略注释，所以注释是给程序员看的，好的注释可以帮助我们理解代码<br>另一种注释方法将注释放在 &#x2F;<em>…</em>&#x2F; 之间，内部可以分行<br>总的来说写注释提高了代码的可读性，能够描述变量和函数的用途，方便代码的维护<br>希望读者们多多三连支持<br>小编会持续更新<br>你们的鼓励就是我前进的动力！</p><p><img src="https://picture-bed000.oss-cn-shenzhen.aliyuncs.com/76973ea184d17f67b7807a7829d0af4.png" alt="在这里插入图片描述"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 开发语言 </tag>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
